<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AgroSense · Panel</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: Arial, sans-serif; background: #0b1220; color: #e9eef7; padding: 16px; min-height: 100vh; }
        .container { width: 100%; max-width: none; margin: 0; }
        h1 { color: #dff7e3; margin-bottom: 6px; text-align: center; font-size: 18px; }
        :root {
            --logo-w: clamp(260px, 52vw, 560px);
            --c-primary: #4CAF50;
            --c-danger: #ff3333;
            --btn-radius: 12px;
            --btn-border: rgba(255,255,255,0.14);
            --btn-bg: rgba(255,255,255,0.08);
            --btn-bg-hover: rgba(255,255,255,0.12);
            --btn-shadow: 0 14px 30px rgba(0,0,0,0.28);
            --btn-shadow-hover: 0 18px 38px rgba(0,0,0,0.34);
        }
        .brand-header { display:flex; align-items:center; justify-content:center; margin: 6px 0 10px; }
        .brand-header img { width: var(--logo-w); max-width: 100%; height: auto; object-fit: contain; display:block; filter: drop-shadow(0 14px 30px rgba(0,0,0,0.55)); }
        .brand-title { display:none; }
        .section { background: #16213e; padding: 20px; border-radius: 12px; margin-bottom: 20px; }
        /* DISPOSITIVO: no sticky (molesta al hacer scroll) */
        #deviceSection { position: relative; z-index: 1; backdrop-filter: blur(8px); background: rgba(22,33,62,0.92); border: 1px solid rgba(255,255,255,0.08); box-shadow: 0 18px 40px rgba(0,0,0,0.30); }
        #deviceSection h2 { margin-bottom: 10px; }
        #deviceSection select { width: 100%; max-width: 100%; min-width: 0; }
        #deviceSection .control-row { flex-wrap: wrap; }
        #deviceSection .control-row label { flex: 0 0 100%; }
        #deviceSection .control-row select { flex: 1 1 100%; }
        .topbar-mini { display:flex; justify-content:space-between; gap: 10px; flex-wrap: wrap; align-items:center; margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.08); }
        .topbar-mini .mini-k { font-size: 11px; color:#8fa3bf; text-transform: uppercase; letter-spacing: .02em; margin-right: 6px; }
        .topbar-mini .mini-v { font-weight: 700; color:#e9eef7; }
        .topbar-mini .right { display:flex; gap: 10px; align-items:center; flex-wrap: wrap; justify-content:flex-end; }
        .pill { display:inline-flex; gap: 8px; align-items:center; padding: 6px 10px; border-radius: 999px; border: 1px solid rgba(255,255,255,0.10); background: rgba(0,0,0,0.10); font-size: 12px; color:#c9d1d9; }
        .section h2 { color: #4CAF50; font-size: 16px; margin-bottom: 15px; border-bottom: 1px solid #333; padding-bottom: 10px; }
        /* Rejilla responsive: evita que en móvil se “salgan” las tarjetas */
        .sensor-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 15px; }
        .sensor-card { --accent: #4CAF50; --accent-soft: rgba(76,175,80,0.18); background: #0f3460; padding: 15px; border-radius: 8px; text-align: center; min-width: 0; border: 1px solid rgba(255,255,255,0.06); box-shadow: 0 10px 26px rgba(0,0,0,0.25); transition: transform 0.12s ease, border-color 0.12s ease, box-shadow 0.12s ease; }
        .sensor-card:hover { transform: translateY(-1px); border-color: rgba(255,255,255,0.12); box-shadow: 0 14px 32px rgba(0,0,0,0.30); }
        .sensor-label { font-size: 11px; color: #ffffff; text-transform: uppercase; margin-bottom: 5px; margin-top: 5px; }
        .sensor-value { font-size: clamp(22px, 6vw, 32px); font-weight: bold; color: var(--accent); }
        .sensor-unit { font-size: 14px; color: var(--accent); opacity: 0.88; }

        /* Estado visual para métricas (voltaje/RSSI/uptime/reinicios) */
        .metric-good .sensor-value { color: #33cc33; }
        .metric-warn .sensor-value { color: #ffcc00; }
        .metric-bad  .sensor-value { color: #ff4d4d; }
        .metric-neutral .sensor-value { color: var(--accent); opacity: 0.92; }

        .metric-good { border-color: rgba(51,204,51,0.25); box-shadow: 0 12px 28px rgba(51,204,51,0.08), 0 10px 26px rgba(0,0,0,0.25); }
        .metric-warn { border-color: rgba(255,204,0,0.25); box-shadow: 0 12px 28px rgba(255,204,0,0.08), 0 10px 26px rgba(0,0,0,0.25); }
        .metric-bad  { border-color: rgba(255,77,77,0.30); box-shadow: 0 12px 28px rgba(255,77,77,0.10), 0 10px 26px rgba(0,0,0,0.25); }
        .metric-neutral { border-color: rgba(255,255,255,0.08); }

        /* Colores por tarjeta (accent): aplica a tarjetas sin “color” propio */
        .sensor-card.accent { position: relative; overflow: hidden; border-color: rgba(255,255,255,0.10); box-shadow: 0 12px 28px rgba(0,0,0,0.25), inset 0 0 0 1px var(--accent-soft); }
        .sensor-card.accent::before {
            content: "";
            position: absolute;
            inset: -140px -180px auto auto;
            width: 280px;
            height: 280px;
            background: radial-gradient(circle, var(--accent-soft), transparent 62%);
            transform: rotate(18deg);
            pointer-events: none;
        }
        .sensor-card.accent::after {
            content: "";
            position: absolute;
            left: 12px;
            right: 12px;
            top: 10px;
            height: 3px;
            border-radius: 999px;
            background: linear-gradient(90deg, transparent, var(--accent), transparent);
            opacity: 0.65;
            pointer-events: none;
        }

        .accent-green { --accent:#22c55e; --accent-soft: rgba(34,197,94,0.18); }
        .accent-cyan { --accent:#22d3ee; --accent-soft: rgba(34,211,238,0.18); }
        .accent-blue { --accent:#60a5fa; --accent-soft: rgba(96,165,250,0.18); }
        .accent-indigo { --accent:#818cf8; --accent-soft: rgba(129,140,248,0.18); }
        .accent-purple { --accent:#a78bfa; --accent-soft: rgba(167,139,250,0.18); }
        .accent-amber { --accent:#fbbf24; --accent-soft: rgba(251,191,36,0.18); }
        .accent-red { --accent:#fb7185; --accent-soft: rgba(251,113,133,0.18); }

        /* Mini “pantalla OLED” dentro de tarjeta */
        .oled-panel {
            margin-top: 10px;
            padding: 10px 12px;
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.12);
            background: radial-gradient(120% 140% at 10% 0%, var(--accent-soft), rgba(0,0,0,0.18));
            box-shadow: 0 14px 30px rgba(0,0,0,0.20), inset 0 0 0 1px rgba(255,255,255,0.04);
            color: rgba(233,238,247,0.92);
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 12px;
            line-height: 1.35;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .oled-panel .oled-k { color: rgba(255, 255, 255, 0.98); font-weight: 900; }
        .oled-panel .oled-v { color: rgba(233,238,247,0.92); font-weight: 900; }
        .oled-panel .oled-v-hum { color: #22c55e; text-shadow: 0 0 12px rgba(34,197,94,0.18); }
        .oled-panel .oled-v-thr { color: #fbbf24; text-shadow: 0 0 12px rgba(251,191,36,0.18); }
        .oled-panel .oled-v-valve { color: #fb7185; text-shadow: 0 0 12px rgba(251,113,133,0.18); }
        .oled-panel .oled-v-v { color: #a78bfa; text-shadow: 0 0 12px rgba(167,139,250,0.18); }
        .oled-panel .oled-v-wifi { color: #22d3ee; text-shadow: 0 0 12px rgba(34,211,238,0.18); }
        .oled-panel .oled-v-ip { color: #60a5fa; text-shadow: 0 0 12px rgba(96,165,250,0.18); }

        /* Chips (para que las tarjetas se vean más “llenas”) */
        .chips { display:flex; flex-wrap:wrap; gap: 8px; margin-top: 10px; justify-content:center; }
        .chip { display:inline-flex; align-items:center; gap: 6px; padding: 6px 10px; border-radius: 999px; border: 1px solid rgba(255,255,255,0.12); background: rgba(255,255,255,0.08); color:#d7deea; font-size: 11px; font-weight: 900; letter-spacing: .01em; }
        .chip .k { opacity: .72; font-weight: 900; }
        .chip .v { color:#ffffff; }
        .chip-ok { border-color: rgba(34,197,94,0.30); background: rgba(34,197,94,0.10); color: rgba(187,247,208,0.95); }
        .chip-warn { border-color: rgba(250,204,21,0.35); background: rgba(250,204,21,0.10); color: rgba(254,249,195,0.98); }
        .chip-bad { border-color: rgba(239,68,68,0.35); background: rgba(239,68,68,0.10); color: rgba(254,202,202,0.98); }
        .chip-neutral { border-color: rgba(148,163,184,0.22); background: rgba(148,163,184,0.08); }

        /* Tarjetas del bloque DISPOSITIVO CONECTADO: más modernas y menos vacías */
        #connectedSection .sensor-grid { grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); }
        #connectedSection .sensor-card { position: relative; overflow: hidden; padding: 54px 16px 16px; }
        #connectedSection .sensor-card::before {
            content: "";
            position: absolute;
            inset: -120px -160px auto auto;
            width: 260px;
            height: 260px;
            background: radial-gradient(circle, var(--accent-soft), transparent 62%);
            transform: rotate(18deg);
            pointer-events: none;
        }
        #connectedSection .sensor-card.accent::after { top: 40px; }
        #connectedSection .sensor-label { font-size: 12px; letter-spacing: .03em; opacity: .96; }
        #connectedSection .sensor-value { font-size: clamp(22px, 5vw, 34px); }
        #connectedSection .sensor-value.small { font-size: 16px; }
        #connectedSection #uptime { white-space: pre-line; line-height: 1.25; }

        /* Neon más marcado en valores pequeños del bloque conectado (IP / sensores-válvulas) */
        #connectedSection .sensor-card.accent .sensor-value.small { color: var(--accent); text-shadow: 0 0 16px var(--accent-soft); }

        /* Zonas / Plantas */
        .zone-off { opacity: 0.62; }
        .sensor-card.card-off { opacity: 0.55; filter: saturate(0.7); }
        .zone-subtitle { color:#8fa3bf; font-size: 12px; margin-top: -6px; margin-bottom: 8px; overflow-wrap: anywhere; word-break: break-word; }
        .zone-row { display:flex; gap: 10px; flex-wrap: wrap; align-items: center; margin-bottom: 12px; }
        .zone-row .control-row { margin-bottom: 0; flex: 1 1 320px; }
        .zone-mini { font-size: 11px; color:#8fa3bf; }
        .mini-btn.tiny { padding: 6px 10px; font-size: 11px; border-radius: 10px; box-shadow: 0 10px 22px rgba(0,0,0,0.18); }
        .sensor-value.small { font-size: 16px; color: #e9eef7; font-weight: 800; word-break: break-word; }
        .valve-indicator { display: flex; align-items: center; justify-content: center; gap: 10px; margin-top: 8px; flex-wrap: wrap; }
        .valve-dot { width: 14px; height: 14px; border-radius: 999px; background: radial-gradient(circle at 30% 30%, rgba(148,163,184,1), rgba(71,85,105,1)); box-shadow: 0 10px 18px rgba(0,0,0,0.35), inset 0 0 0 2px rgba(255,255,255,0.10); position: relative; }
        .valve-dot::after { content:""; position:absolute; inset:-8px; border-radius:999px; opacity:0; transition: opacity .18s ease; }
        .valve-dot.on { background: radial-gradient(circle at 30% 30%, rgba(34,197,94,1), rgba(22,163,74,1)); }
        .valve-dot.on::after { opacity:1; background: radial-gradient(circle, rgba(34,197,94,0.28), transparent 58%); }
        .valve-dot.off { background: radial-gradient(circle at 30% 30%, rgba(239,68,68,1), rgba(185,28,28,1)); }
        .valve-dot.off::after { opacity:1; background: radial-gradient(circle, rgba(239,68,68,0.26), transparent 58%); }
        .valve-text { font-size: 14px; font-weight: bold; color: #ddd; max-width: 100%; overflow: hidden; text-overflow: ellipsis; }
        .leds-container { display: flex; justify-content: center; gap: 15px; margin: 20px 0; }
        .led { width: 40px; height: 40px; border-radius: 50%; border: 3px solid #333; transition: all 0.3s; }
        .control-row { display: flex; gap: 10px; margin-bottom: 15px; align-items: center; }
        .control-row label { flex: 1; color: #ffffff; }
        .control-row input, .control-row select { flex: 2; padding: 10px; border: none; border-radius: 6px; background: #0f3460; color: #fff; font-size: 14px; min-width: 0; }
        .control-row textarea { flex: 2; width: 100%; min-width: 0; padding: 12px; border: 1px solid rgba(255,255,255,0.12); border-radius: 14px; background: rgba(15,52,96,0.55); color: #fff; font-size: 14px; line-height: 1.4; min-height: 140px; resize: vertical; box-shadow: 0 12px 28px rgba(0,0,0,0.18); }
        .control-row input:focus, .control-row select:focus, .control-row textarea:focus { outline: 2px solid rgba(76,175,80,0.35); outline-offset: 2px; }
        .control-row.textarea-row { align-items: flex-start; }
        .control-row.textarea-row label { padding-top: 10px; }
        .control-row input[type="range"] { -webkit-appearance: none; appearance: none; height: 8px; }
        .control-row input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 20px; height: 20px; background: #4CAF50; border-radius: 50%; cursor: pointer; }
        .btn-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin: 15px 0; }
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 12px 10px;
            border: 1px solid var(--btn-border);
            border-radius: var(--btn-radius);
            cursor: pointer;
            font-weight: 800;
            font-size: 12px;
            letter-spacing: .02em;
            box-shadow: var(--btn-shadow);
            transition: transform 0.12s ease, box-shadow 0.18s ease, filter 0.18s ease, background 0.18s ease, border-color 0.18s ease;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        .btn:hover { transform: translateY(-1px); box-shadow: var(--btn-shadow-hover); filter: brightness(1.03); }
        .btn:active { transform: translateY(0); filter: brightness(0.98); }
        .btn:focus-visible { outline: 2px solid rgba(76,175,80,0.45); outline-offset: 2px; }
        .btn-rojo { background: linear-gradient(180deg, rgba(255,77,77,1), rgba(255,51,51,1)); color: white; border-color: rgba(255,77,77,0.35); }
        .btn-verde { background: linear-gradient(180deg, rgba(76,175,80,1), rgba(51,204,51,1)); color: white; border-color: rgba(76,175,80,0.35); }
        .btn-azul { background: linear-gradient(180deg, rgba(59,130,246,1), rgba(51,102,255,1)); color: white; border-color: rgba(59,130,246,0.35); }
        .btn-amarillo { background: linear-gradient(180deg, rgba(255,224,102,1), rgba(255,204,0,1)); color: #0b1220; border-color: rgba(255,204,0,0.35); }
        .btn-cian { background: linear-gradient(180deg, rgba(34,211,238,1), rgba(0,204,204,1)); color: #0b1220; border-color: rgba(34,211,238,0.35); }
        .btn-magenta { background: linear-gradient(180deg, rgba(217,70,239,1), rgba(204,51,204,1)); color: white; border-color: rgba(217,70,239,0.35); }
        .btn-blanco { background: linear-gradient(180deg, rgba(255,255,255,1), rgba(226,232,240,1)); color: #0b1220; border-color: rgba(255,255,255,0.35); }
        /* Botón neutro/off: estilo más moderno (glass + azul) */
        .btn-off {
            background: linear-gradient(180deg, rgba(59,130,246,0.22), rgba(15,23,42,0.70));
            color: rgba(226,232,240,0.92);
            border-color: rgba(56,189,248,0.22);
            box-shadow: 0 14px 30px rgba(0,0,0,0.22);
        }
        .btn-save { background: linear-gradient(180deg, rgba(76,175,80,1), rgba(45,183,95,1)); color: white; width: 100%; padding: 14px; font-size: 15px; margin-top: 10px; border-color: rgba(76,175,80,0.35); }
        .status { text-align: center; font-size: 12px; color: #33cc33; margin-top: 15px; }
        .status.online { color: #4CAF50; }
        .status.offline { color: #ff3333; }
        .current-color { text-align: center; padding: 10px; background: #0f3460; border-radius: 8px; margin: 10px 0; }
        .current-color span { font-weight: bold; color: #4CAF50; }
        /* Gráficas sin scroll: se ajustan al espacio disponible */
        .charts-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
        @media (max-width: 900px) {
            .charts-grid { grid-template-columns: 1fr; }
        }
        .chart-box { text-align: left; min-width: 0; }
        .chart-wrap { position: relative; width: 100%; height: clamp(160px, 24vh, 260px); }
        .chart-wrap canvas { width: 100% !important; height: 100% !important; display: block; }
        /* Las gráficas de tarjetas usan el mismo tamaño que las principales */
        .mini-chart-wrap { height: clamp(160px, 24vh, 260px); margin-top: 10px; }
        .sensor-card.card-off .chart-wrap { opacity: 0.25; }
        .sensor-card.card-off .sensor-value { opacity: 0.75; }
        .btn.active { outline: 2px solid rgba(255,255,255,0.35); opacity: 0.95; }
        .summary { display:flex; justify-content:space-between; gap: 12px; flex-wrap: wrap; margin: 8px 0 0; }
        .summary .k { color: #33cc33; font-size: 11px; text-transform: uppercase; }
        .summary .v { color: #ddd; font-weight: bold; }

        /* En tarjetas con acento, que los KPIs hereden el color */
        .sensor-card.accent .summary .k { color: var(--accent); }
        .sensor-card.accent .summary .v { color: #e9eef7; }

        .hidden { display: none; }

        /* Navegación Cuenta/Dispositivos */
        .top-nav { display:flex; gap: 10px; align-items:center; flex-wrap: wrap; margin: 6px 0 12px; }
        .top-nav .spacer { flex: 1 1 auto; }
        .mini-btn.active { outline: 2px solid rgba(255,255,255,0.30); }

        body.mode-account .container > .section { display: none; }
        body.mode-account #accountSection { display: block; }
        body.mode-account #status { display:none; }

        body.mode-support .container > .section { display: none; }
        body.mode-support #supportSection { display: block; }
        body.mode-support #status { display:none; }

        .tickets-list { display:flex; flex-direction:column; gap: 8px; margin-top: 10px; }
        .ticket-item { padding: 10px; border-radius: 12px; background: rgba(15,52,96,0.35); border: 1px solid rgba(255,255,255,0.08); cursor: pointer; }
        .ticket-item:hover { background: rgba(15,52,96,0.45); }
        .ticket-title { font-weight: 800; }
        .ticket-meta { color: #8fa3bf; font-size: 12px; margin-top: 4px; }
        .messages { border: 1px solid rgba(255,255,255,0.10); border-radius: 12px; background: rgba(0,0,0,0.10); padding: 10px; max-height: 320px; overflow:auto; }
        .msg { padding: 10px; border-radius: 12px; background: rgba(15,52,96,0.22); border: 1px solid rgba(255,255,255,0.06); margin-bottom: 8px; }
        .msg-meta { color:#8fa3bf; font-size: 12px; margin-bottom: 6px; }
        .msg-body { white-space: pre-wrap; }

        /* Selector de canales (más moderno) */
        .channel-cards { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin: 10px 0 6px; }
        @media (max-width: 900px) { .channel-cards { grid-template-columns: 1fr; } }
        .channel-card { --accent: #60a5fa; --accent-soft: rgba(96,165,250,0.18); background: rgba(15,52,96,0.35); border: 1px solid rgba(255,255,255,0.08); border-radius: 12px; padding: 12px; min-width: 0; }
        .channel-card.accent { position: relative; overflow: hidden; border-color: rgba(255,255,255,0.10); box-shadow: 0 12px 28px rgba(0,0,0,0.22), inset 0 0 0 1px var(--accent-soft); }
        .channel-card.accent::before {
            content: "";
            position: absolute;
            inset: -120px -160px auto auto;
            width: 260px;
            height: 260px;
            background: radial-gradient(circle, var(--accent-soft), transparent 62%);
            transform: rotate(18deg);
            pointer-events: none;
        }
        .channel-card.accent::after {
            content: "";
            position: absolute;
            left: 12px;
            right: 12px;
            top: 10px;
            height: 3px;
            border-radius: 999px;
            background: linear-gradient(90deg, transparent, var(--accent), transparent);
            opacity: 0.60;
            pointer-events: none;
        }
        .channel-card.accent .sensor-label { opacity: 0.96; }
        .channel-title { display:flex; align-items:center; justify-content:space-between; gap: 10px; margin-bottom: 8px; }
        .channel-title .sensor-label { margin-bottom: 0; }
        .channel-actions { display:flex; gap: 8px; margin-top: 8px; flex-wrap: wrap; }
        .channel-card select { width: 100%; }

        .mini-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            background: linear-gradient(180deg, rgba(59,130,246,0.22), rgba(34,211,238,0.10));
            border: 1px solid rgba(56,189,248,0.20);
            color: #e9eef7;
            padding: 8px 12px;
            border-radius: var(--btn-radius);
            cursor: pointer;
            font-size: 12px;
            font-weight: 800;
            letter-spacing: .02em;
            box-shadow: 0 12px 26px rgba(0,0,0,0.20);
            transition: transform 0.12s ease, box-shadow 0.18s ease, filter 0.18s ease, background 0.18s ease, border-color 0.18s ease;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        .mini-btn:hover { transform: translateY(-1px); box-shadow: 0 16px 34px rgba(0,0,0,0.28); filter: brightness(1.04); }
        .mini-btn:active { transform: translateY(0); filter: brightness(0.98); }
        .mini-btn:focus-visible { outline: 2px solid rgba(76,175,80,0.45); outline-offset: 2px; }
        .mini-btn.danger { border-color: rgba(255,77,77,0.35); color: #ffd1d1; background: linear-gradient(180deg, rgba(255,77,77,0.18), rgba(255,255,255,0.06)); }
        .mini-btn.primary { border-color: rgba(76,175,80,0.40); color: #d7ffe0; background: linear-gradient(180deg, rgba(76,175,80,0.22), rgba(255,255,255,0.06)); }
        .mini-btn:disabled {
            cursor: not-allowed;
            opacity: 0.72;
            filter: grayscale(0.15);
            background: linear-gradient(180deg, rgba(148,163,184,0.14), rgba(15,23,42,0.55));
            border-color: rgba(148,163,184,0.18);
            box-shadow: 0 10px 22px rgba(0,0,0,0.16);
        }
        .badge { display:inline-flex; align-items:center; justify-content:center; min-width: 18px; height: 18px; padding: 0 6px; border-radius: 999px; font-size: 11px; font-weight: 900; background: rgba(239,68,68,0.95); color: #fff; margin-left: 8px; border: 1px solid rgba(255,255,255,0.20); }
        .badge.hidden { display:none; }

        .conn { display: inline-flex; align-items: center; gap: 8px; margin-top: 6px; font-size: 12px; color: #c9d1d9; opacity: 0.95; }
        .dot { width: 10px; height: 10px; border-radius: 999px; background: #6b7280; position: relative; box-shadow: 0 0 0 2px rgba(255,255,255,0.10) inset, 0 6px 14px rgba(0,0,0,0.35); }
        .dot::after { content:""; position:absolute; inset:-6px; border-radius:999px; opacity:0; background: radial-gradient(circle, rgba(34,197,94,0.22), transparent 55%); transition: opacity .18s ease; }
        .dot.online { background: radial-gradient(circle at 30% 30%, rgba(34,197,94,1), rgba(22,163,74,1)); }
        .dot.offline { background: radial-gradient(circle at 30% 30%, rgba(239,68,68,1), rgba(185,28,28,1)); }
        .dot.unknown { background: radial-gradient(circle at 30% 30%, rgba(148,163,184,1), rgba(71,85,105,1)); }
        .dot.online::after { opacity: 1; }

        /* Secciones plegables */
        .section-head { display:flex; align-items:center; justify-content:space-between; gap: 10px; }
        .collapse-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            background: linear-gradient(180deg, rgba(255,255,255,0.10), rgba(255,255,255,0.06));
            border: 1px solid var(--btn-border);
            color: #e9eef7;
            padding: 7px 10px;
            border-radius: var(--btn-radius);
            cursor: pointer;
            font-size: 12px;
            font-weight: 800;
            letter-spacing: .02em;
            box-shadow: 0 12px 26px rgba(0,0,0,0.20);
            transition: transform 0.12s ease, box-shadow 0.18s ease, filter 0.18s ease, background 0.18s ease, border-color 0.18s ease;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        .collapse-btn:hover { transform: translateY(-1px); box-shadow: 0 16px 34px rgba(0,0,0,0.28); filter: brightness(1.04); }
        .collapse-btn:active { transform: translateY(0); filter: brightness(0.98); }
        .collapse-btn:focus-visible { outline: 2px solid rgba(76,175,80,0.45); outline-offset: 2px; }
        .section.collapsed .section-body { display:none; }

        /* Compacto en móvil */
        @media (max-width: 640px) {
            body { padding: 10px; }
            .section { padding: 14px; margin-bottom: 14px; }
            #deviceSection { top: auto; }
            .sensor-grid { grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 10px; }
            .sensor-card { padding: 12px; }
            .btn-grid { grid-template-columns: repeat(2, 1fr); }
            .device-actions { grid-template-columns: repeat(2, minmax(0, 1fr)); }
            /* Zonas: evitar overflow horizontal en móvil */
            .zone-row { gap: 8px; }
            .zone-row .control-row { flex: 1 1 100%; }
            .zone-subtitle { font-size: 11px; line-height: 1.35; }

            /* Controles: label arriba, control abajo */
            .zone-row .control-row { flex-wrap: wrap; }
            .zone-row .control-row label { flex: 0 0 100%; }
            .zone-row .control-row input,
            .zone-row .control-row select { flex: 1 1 100%; width: 100%; }
        }

        /* Acciones del bloque DISPOSITIVO: 2 por fila en móvil, 4 en desktop */
        .device-actions { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 10px; margin-top: 10px; }
        @media (min-width: 900px) { .device-actions { grid-template-columns: repeat(4, minmax(0, 1fr)); } }
        .device-actions .mini-btn { width: 100%; justify-content: center; }

        /* Iconos en tarjetas (DISPOSITIVO CONECTADO): centrados arriba, sobre la línea de acento */
        #connectedSection .sensor-card .card-ico { position: absolute; left: 50%; right: auto; top: 10px; transform: translateX(-50%); width: 22px; height: 22px; color: var(--accent); opacity: 0.92; filter: drop-shadow(0 0 14px var(--accent-soft)); pointer-events: none; }
        .sensor-card .card-ico svg { width: 100%; height: 100%; display: block; }

        /* Botón renombrar en selects de plantas */
        .zone-rename-btn { flex: 0 0 auto; }
        @media (max-width: 640px) { .zone-rename-btn { width: 100%; } }

        /* Modal ligero (selector de tipo de sensor) */
        .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.55); display:flex; align-items:center; justify-content:center; padding: 16px; z-index: 2200; }
        .modal { width: min(520px, 100%); background: rgba(22,33,62,0.98); border: 1px solid rgba(255,255,255,0.10); border-radius: 14px; padding: 14px; box-shadow: 0 24px 70px rgba(0,0,0,0.55); }
        .modal-title { font-weight: 900; letter-spacing: .02em; margin-bottom: 10px; color:#e9eef7; }
        .choice-grid { display:grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 10px; }
        @media (max-width: 360px) { .choice-grid { grid-template-columns: 1fr; } }
        .modal-actions { display:flex; justify-content:flex-end; gap: 10px; margin-top: 12px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="brand-header">
            <img
                            src="/logo-wide.png?v=20260128r2"
                            srcset="/logo-wide.png?v=20260128r2 1x, /logo-wide@2x.png?v=20260128r2 2x"
              alt="AgroSense"
              onerror="this.style.display='none'"
            />
        </div>
        <div class="status" style="margin-bottom: 12px;">UI vRt1548A</div>

        <div class="top-nav">
            <button class="mini-btn active" id="navDevices" type="button">Dispositivos</button>
            <button class="mini-btn" id="navAccount" type="button">Cuenta</button>
                <button class="mini-btn" id="navSupport" type="button">Soporte <span class="badge hidden" id="supportBadge">0</span></button>
            <span class="spacer"></span>
            <button class="mini-btn danger" id="navLogout" type="button">Salir</button>
        </div>

        <div class="section hidden" id="accountSection">
            <h2> CUENTA</h2>
            <div class="status" id="accountStatus">—</div>
            <div class="control-row"><label>Email:</label><input id="accEmail" type="email" disabled /></div>
            <div class="control-row"><label>Nombre:</label><input id="accFullName" type="text" placeholder="Nombre y apellidos" /></div>
            <div class="control-row"><label>Teléfono:</label><input id="accPhone" type="tel" placeholder="Teléfono" /></div>
            <div class="control-row"><label>Dirección:</label><input id="accAddress" type="text" placeholder="Calle, número, etc." /></div>
            <div class="control-row"><label>Provincia:</label><input id="accProvince" type="text" placeholder="Provincia" /></div>
            <div class="control-row"><label>Ciudad:</label><input id="accCity" type="text" placeholder="Ciudad" /></div>
            <div class="control-row"><label>País:</label><input id="accCountry" type="text" placeholder="País" /></div>
            <div style="display:flex; gap: 10px; flex-wrap: wrap; margin-top: 10px;">
                <button class="mini-btn primary" id="btnSaveProfile" type="button">Guardar</button>
                <button class="mini-btn danger" id="btnDeleteAccount" type="button">Eliminar cuenta</button>
            </div>
            <div class="muted" style="margin-top:10px; font-size:12px; color:#8fa3bf; line-height:1.35;">
                Eliminar cuenta borra tu usuario y desvincula tus dispositivos.
            </div>
        </div>

        <div class="section hidden" id="supportSection">
            <h2> SOPORTE (TICKETS)</h2>
            <div class="status" id="supportStatus">—</div>

            <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.08);"></div>
            <h2 style="margin-top: 10px;"> ABRIR TICKET</h2>
            <div class="control-row"><label>Asunto:</label><input id="tSubject" type="text" placeholder="Ej: No riega / sensor falla" /></div>
            <div class="control-row"><label>Dispositivo (opcional):</label>
                <select id="tDevice" title="Dispositivo (opcional)">
                    <option value="">(sin dispositivo)</option>
                </select>
            </div>
            <div class="control-row textarea-row"><label>Mensaje:</label><textarea id="tMessage" placeholder="Describe el problema..."></textarea></div>
            <button class="btn btn-save" id="btnCreateTicket" type="button">ENVIAR TICKET</button>

            <div style="margin-top: 16px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.08);"></div>
            <h2 style="margin-top: 10px;"> MIS TICKETS</h2>
            <div class="tickets-list" id="ticketsList"></div>

            <div style="margin-top: 16px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.08);"></div>
            <h2 style="margin-top: 10px;"> DETALLE</h2>
            <div class="control-row"><label>ID:</label><input id="tId" type="text" disabled /></div>
            <div class="control-row"><label>Estado:</label><input id="tStatus" type="text" disabled /></div>
            <div class="control-row"><label>Mensajes:</label><div id="tMessages" class="messages" style="flex:2;"></div></div>
            <div class="control-row textarea-row"><label>Responder:</label><textarea id="tReply" placeholder="Añade más información..."></textarea></div>
            <div style="display:flex; gap: 10px; flex-wrap: wrap; margin-top: 10px;">
                <button class="mini-btn primary" id="btnReplyTicket" type="button">Enviar respuesta</button>
                <button class="mini-btn danger" id="btnCloseTicket" type="button">Cerrar ticket</button>
            </div>
        </div>

        <div class="section" id="deviceSection" style="padding: 14px 20px;">
            <h2> DISPOSITIVO</h2>
            <div class="control-row" style="margin-bottom: 0;">
                <label>Seleccionar:</label>
                <select id="deviceSelect" title="Seleccionar dispositivo"></select>
            </div>
            <div class="device-actions">
                <button class="mini-btn primary" id="btnAddDevice" type="button">+ Añadir dispositivo</button>
                <button class="mini-btn danger" id="btnDeleteDevice" type="button" title="Quitar este dispositivo de tu cuenta">Eliminar dispositivo</button>
                <button class="mini-btn" id="btnAddValve" type="button">+ Añadir válvula</button>
                <button class="mini-btn" id="btnAddSensor" type="button">AÑADIR SENSOR</button>
            </div>
            <div class="status" style="margin-top: 10px;" id="deviceMeta">--</div>

            <div class="topbar-mini">
                <div class="right">
                    <span class="pill" title="Conexión del dispositivo">
                        <span class="dot unknown" id="topConnDot"></span>
                        <span id="topConnText">--</span>
                    </span>
                    <span class="pill" id="topStatusText">Conectando...</span>
                </div>
            </div>
            <!-- Mantener el ID para compatibilidad (JS lo actualiza si existe), pero oculto -->
            <span class="hidden" id="topNowEs">--</span>
        </div>
        <div class="section" id="connectedSection">
            <h2> DISPOSITIVO CONECTADO</h2>
            <div class="sensor-grid">
                <div class="sensor-card metric-neutral accent accent-green">
                    <div class="card-ico" aria-hidden="true">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <rect x="4" y="5" width="16" height="11" rx="2" />
                            <path d="M9 19h6" />
                            <path d="M12 16v3" />
                        </svg>
                    </div>
                    <div class="sensor-label">Pantalla (tiempo real)</div>
                    <div class="chips" id="oledMeta"></div>
                    <div class="oled-panel" id="oledPanel">--</div>
                </div>
                <div class="sensor-card metric-neutral accent accent-cyan">
                    <div class="card-ico" aria-hidden="true">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M7 7h10" />
                            <path d="M7 12h10" />
                            <path d="M7 17h10" />
                            <circle cx="5" cy="7" r="1" />
                            <circle cx="5" cy="12" r="1" />
                            <circle cx="5" cy="17" r="1" />
                        </svg>
                    </div>
                    <div class="sensor-label">Sensores / Válvulas (activos)</div>
                    <div class="sensor-value small" id="uptime">--</div>
                    <div class="chips" id="uptimeMeta"></div>
                </div>
                <div class="sensor-card metric-neutral accent accent-blue">
                    <div class="card-ico" aria-hidden="true">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M4 12a8 8 0 0 1 16 0" />
                            <path d="M6 12a6 6 0 0 1 12 0" />
                            <path d="M8 12a4 4 0 0 1 8 0" />
                            <circle cx="12" cy="16" r="1" />
                        </svg>
                    </div>
                    <div class="sensor-label">IP</div>
                    <div class="sensor-value small" id="ip">--</div>
                    <div class="chips" id="ipMeta"></div>
                </div>
                <div class="sensor-card metric-neutral accent accent-purple">
                    <div class="card-ico" aria-hidden="true">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <rect x="7" y="7" width="10" height="10" rx="2" />
                            <path d="M9 3v3M15 3v3M9 18v3M15 18v3" />
                            <path d="M3 9h3M3 15h3M18 9h3M18 15h3" />
                        </svg>
                    </div>
                    <div class="sensor-label">Memoria </div>
                    <div class="sensor-value" id="heap">--</div>
                    <div class="chips" id="heapMeta"></div>
                </div>
                <div class="sensor-card accent accent-amber">
                    <div class="card-ico" aria-hidden="true">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M13 2L4 14h7l-1 8 10-14h-7z" />
                        </svg>
                    </div>
                    <div class="sensor-label">Voltaje</div>
                    <div class="sensor-value" id="voltage">--</div>
                    <div class="chips" id="voltageMeta"></div>
                </div>
                <div class="sensor-card accent accent-indigo">
                    <div class="card-ico" aria-hidden="true">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M5 12.5a10 10 0 0 1 14 0" />
                            <path d="M8 15.5a6 6 0 0 1 8 0" />
                            <path d="M11 18.5a2 2 0 0 1 2 0" />
                        </svg>
                    </div>
                    <div class="sensor-label">WiFi</div>
                    <div class="sensor-value" id="rssi">--</div>
                    <div class="chips" id="wifiMeta"></div>
                </div>
                <div class="sensor-card accent accent-red">
                    <div class="card-ico" aria-hidden="true">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21 12a9 9 0 1 1-3-6.7" />
                            <path d="M21 3v6h-6" />
                        </svg>
                    </div>
                    <div class="sensor-label">Reinicios</div>
                    <div class="sensor-value" id="reboots">--</div>
                    <div class="chips" id="rebootsMeta"></div>
                    <div style="margin-top: 10px;">
                        <button class="mini-btn danger" id="resetRebootsBtn" type="button">Reset a 0</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="section" id="zonesSection">
            <h2> PLANTAS (1–8)</h2>
            <div class="muted" style="margin-top: -6px; margin-bottom: 10px; font-size:12px; color:#8fa3bf; line-height:1.35;">
                Configura cada planta con su sensor de humedad, su válvula y su umbral.
                Si un sensor/válvula no está enviando datos, la zona se verá “apagada”.
            </div>
            <div id="zonesContainer"></div>
        </div>

        <div class="section">
            <h2> GRÁFICAS EN TIEMPO REAL</h2>
            <div style="display:flex; align-items:center; justify-content:space-between; gap: 12px; flex-wrap: wrap; margin: 4px 0 8px;">
                <div>
                    <div class="sensor-label">FECHA / HORA </div>
                    <div style="font-size: 18px; font-weight: bold; color: #ddd;" id="nowEs">--</div>
                    <div class="conn" title="Conexión del dispositivo">
                        <span class="dot unknown" id="connDot"></span>
                        <span id="connText">--</span>
                    </div>
                </div>
                <div style="display:flex; gap: 10px; align-items:center; flex-wrap: wrap; justify-content:flex-end;">
                    <button class="btn btn-azul" id="btnDia" type="button">DÍA</button>
                    <button class="btn btn-azul" id="btnMes" type="button">MES</button>
                    <button class="btn btn-azul" id="btnAno" type="button">AÑO</button>
                </div>
            </div>

            <div class="channel-cards">
                <div class="channel-card accent accent-green">
                    <div class="channel-title">
                        <div class="sensor-label">Sensor de humedad (gráfica)</div>
                    </div>
                    <select id="humChannelSelect" title="Seleccionar sensor de humedad"></select>
                    <div class="channel-actions">
                        <button class="mini-btn" id="btnRenameHum" type="button">Renombrar</button>
                        <button class="mini-btn danger" id="btnDeleteHum" type="button" title="Eliminar sensores añadidos">Eliminar</button>
                    </div>
                </div>
                <div class="channel-card accent accent-red">
                    <div class="channel-title">
                        <div class="sensor-label">Válvula (gráfica)</div>
                    </div>
                    <select id="valveChannelSelect" title="Seleccionar válvula"></select>
                    <div class="channel-actions">
                        <button class="mini-btn" id="btnRenameValve" type="button">Renombrar</button>
                        <button class="mini-btn danger" id="btnDeleteValve" type="button" title="Eliminar válvulas añadidas">Eliminar</button>
                    </div>
                </div>
            </div>
            <div class="summary">
                <div>
                    <div class="k">Humedad Media</div>
                    <div class="v" id="avgHumidity">--</div>
                </div>
                <div>
                    <div class="k">Último punto</div>
                    <div class="v" id="lastPoint">--</div>
                </div>
                <div>
                    <div class="k">Tiempo Válvula ON</div>
                    <div class="v" id="totalValveOn">--</div>
                </div>
                <!-- Mantener estos IDs para que el JS pueda actualizar el periodo, pero sin mostrarlo en la UI -->
                <div class="hidden">
                    <div class="k" id="periodLabel">Periodo</div>
                    <div class="v" id="periodValue">--</div>
                </div>
            </div>
            <div class="charts-grid">
                <div class="sensor-card chart-box accent accent-green">
                    <div class="sensor-label">Humedad del suelo (%)</div>
                    <div class="chart-wrap">
                        <canvas id="humChart"></canvas>
                    </div>
                </div>
                <div class="sensor-card chart-box accent accent-red">
                    <div class="sensor-label">Válvula (ON/OFF) + tiempo activa</div>
                    <div style="display:flex; justify-content:space-between; align-items:center; gap: 10px; margin: 8px 0 6px;">
                        <div class="valve-indicator" style="margin-top: 0; justify-content:flex-start;">
                            <div class="valve-dot" id="valveDotChart"></div>
                            <div class="valve-text" id="valveTextChart">--</div>
                        </div>
                        <div class="sensor-unit" id="valveOnTime">Tiempo ON: --</div>
                    </div>
                    <div class="chart-wrap">
                        <canvas id="valveChart"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <div class="section">
            <h2> CONFIGURACIÓN AUTOMÁTICA</h2>
            <div class="control-row">
                <label>Color si Humedad BAJA:</label>
                <select id="colorBuena" title="Color si humedad baja">
                    <option value="Rojo">Rojo</option>
                    <option value="Verde">Verde</option>
                    <option value="Azul">Azul</option>
                    <option value="Amarillo">Amarillo</option>
                    <option value="Cian">Cian</option>
                    <option value="Magenta">Magenta</option>
                    <option value="Blanco">Blanco</option>
                </select>
            </div>
            <div class="control-row">
                <label>Color si Humedad BUENA:</label>
                <select id="colorBaja" title="Color si humedad buena">
                    <option value="Rojo">Rojo</option>
                    <option value="Verde" selected>Verde</option>
                    <option value="Azul">Azul</option>
                    <option value="Amarillo">Amarillo</option>
                    <option value="Cian">Cian</option>
                    <option value="Magenta">Magenta</option>
                    <option value="Blanco">Blanco</option>
                </select>
            </div>
            <div class="control-row">
                <label>Calibración WET_V (V):</label>
                <input id="wetV" type="number" step="0.001" placeholder="ej: 1.10" />
            </div>
            <div class="control-row">
                <label>Calibración DRY_V (V):</label>
                <input id="dryV" type="number" step="0.001" placeholder="ej: 2.60" />
            </div>
            <div class="control-row">
                <label>Alerta: Humedad baja (min):</label>
                <input id="alertHumLowMin" type="number" min="0" step="1" placeholder="0 = desactivado" />
            </div>
            <div class="control-row">
                <label>Alerta: Válvula ON máx (min):</label>
                <input id="alertValveMaxMin" type="number" min="0" step="1" placeholder="0 = desactivado" />
            </div>
            <div class="control-row">
                <label>Alerta: Sensor muerto (min):</label>
                <input id="alertDeadMin" type="number" min="0" step="1" placeholder="0 = desactivado" />
            </div>
            <div class="control-row">
                <label>Alerta: Voltaje mín (V):</label>
                <input id="alertVmin" type="number" step="0.01" placeholder="vacío = desactivado" />
            </div>
            <div class="control-row">
                <label>Alerta: Voltaje máx (V):</label>
                <input id="alertVmax" type="number" step="0.01" placeholder="vacío = desactivado" />
            </div>
            <div class="control-row">
                <label>Webhook (URL):</label>
                <input id="notifyWebhook" type="url" placeholder="https://..." />
            </div>
            <div class="control-row">
                <label>Telegram Chat ID:</label>
                <input id="notifyTelegram" type="text" placeholder="123456789" />
            </div>
            <div style="display:flex; gap: 10px; flex-wrap: wrap; margin-top: 10px;">
                <button class="mini-btn" id="btnResetDefaults" type="button">Reset a valores por defecto</button>
                <button class="btn btn-save" id="btnSaveConfig" onclick="guardar()" type="button"> GUARDAR CONFIGURACION</button>
            </div>
        </div>

        <div class="section">
            <h2> ALERTAS</h2>
            <div class="status" id="alertsStatus">--</div>
            <div id="alertsList" style="margin-top: 10px; display:flex; flex-direction:column; gap: 8px;"></div>
        </div>

        <div class="status" id="status">Conectando...</div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script>
        let config = { threshold: 25, colorB: 'Rojo', colorG: 'Verde' };

        const DEFAULT_AUTO_CONFIG = {
            wet_v: 1.10,
            dry_v: 2.60,
            alert_humidity_low_minutes: 0,
            alert_valve_on_max_minutes: 0,
            alert_sensor_dead_minutes: 0,
            alert_voltage_min: null,
            alert_voltage_max: null
        };

        function makeDefaultZones(baseThreshold) {
            const thr = Number(baseThreshold);
            const t = Number.isFinite(thr) ? Math.max(0, Math.min(100, thr)) : 25;
            // Por defecto solo dejamos asignada PLANTA 1 (si existe), el resto SIN ASIGNAR.
            // Así plantas 2..8 aparecen apagadas hasta que haya sensores/válvulas reales.
            return Array.from({ length: 8 }, (_, i) => ({
                zone: i + 1,
                soil_channel_index: i === 0 ? 1 : null,
                valve_channel_index: i === 0 ? 1 : null,
                temperature_air_channel_index: null,
                humidity_air_channel_index: null,
                temperature_soil_channel_index: null,
                ph_soil_channel_index: null,
                ec_soil_channel_index: null,
                humidity_low_threshold: t
            }));
        }

        let zonesState = makeDefaultZones(25);

        function normalizeZonesFromServer(raw, baseThreshold) {
            const out = makeDefaultZones(baseThreshold);
            const arr = Array.isArray(raw) ? raw : [];
            for (const z of arr) {
                const zone = Number(z?.zone);
                if (!Number.isInteger(zone) || zone < 1 || zone > 8) continue;
                const idx = zone - 1;

                const soilIdx = z?.soil_channel_index == null ? null : Number(z.soil_channel_index);
                const valveIdx = z?.valve_channel_index == null ? null : Number(z.valve_channel_index);
                const tAirIdx = z?.temperature_air_channel_index == null ? null : Number(z.temperature_air_channel_index);
                const hAirIdx = z?.humidity_air_channel_index == null ? null : Number(z.humidity_air_channel_index);
                const tSoilIdx = z?.temperature_soil_channel_index == null ? null : Number(z.temperature_soil_channel_index);
                const phIdx = z?.ph_soil_channel_index == null ? null : Number(z.ph_soil_channel_index);
                const ecIdx = z?.ec_soil_channel_index == null ? null : Number(z.ec_soil_channel_index);
                const thr = z?.humidity_low_threshold == null ? null : Number(z.humidity_low_threshold);

                out[idx] = {
                    zone,
                    soil_channel_index: Number.isFinite(soilIdx) ? soilIdx : null,
                    valve_channel_index: Number.isFinite(valveIdx) ? valveIdx : null,
                    temperature_air_channel_index: Number.isFinite(tAirIdx) ? tAirIdx : null,
                    humidity_air_channel_index: Number.isFinite(hAirIdx) ? hAirIdx : null,
                    temperature_soil_channel_index: Number.isFinite(tSoilIdx) ? tSoilIdx : null,
                    ph_soil_channel_index: Number.isFinite(phIdx) ? phIdx : null,
                    ec_soil_channel_index: Number.isFinite(ecIdx) ? ecIdx : null,
                    humidity_low_threshold: Number.isFinite(thr)
                        ? Math.max(0, Math.min(100, thr))
                        : out[idx].humidity_low_threshold
                };
            }
            return out;
        }

        function updateZoneSubtitles() {
            const soil = (channels || []).filter(c => c && c.kind === 'soil_sensor');
            const valves = (channels || []).filter(c => c && c.kind === 'valve');
            const tAir = (channels || []).filter(c => c && c.kind === 'temperature_air');
            const hAir = (channels || []).filter(c => c && c.kind === 'humidity_air');
            const tSoil = (channels || []).filter(c => c && c.kind === 'temperature_soil');
            const phSoil = (channels || []).filter(c => c && c.kind === 'ph_soil');
            const ecSoil = (channels || []).filter(c => c && c.kind === 'ec_soil');
            const findName = (arr, idx) => {
                const n = Number(idx);
                const c = arr.find(x => Number(x.channel_index) === n);
                return c ? c.name : null;
            };

            for (let i = 0; i < 8; i++) {
                const zoneNum = i + 1;
                const el = document.getElementById(`zoneSubtitle${zoneNum}`);
                if (!el) continue;
                const z = zonesState[i];
                const sName = z.soil_channel_index == null ? null : findName(soil, z.soil_channel_index);
                const vName = z.valve_channel_index == null ? null : findName(valves, z.valve_channel_index);
                const sTxt = z.soil_channel_index == null ? 'Sensor: (sin asignar)' : `Sensor: ${sName || '—'} (${z.soil_channel_index})`;
                const vTxt = z.valve_channel_index == null ? 'Válvula: (sin asignar)' : `Válvula: ${vName || '—'} (${z.valve_channel_index})`;

                const extraParts = [];
                if (z.temperature_air_channel_index != null) {
                    const nm = findName(tAir, z.temperature_air_channel_index);
                    extraParts.push(`TA: ${nm || '—'} (${z.temperature_air_channel_index})`);
                }
                if (z.humidity_air_channel_index != null) {
                    const nm = findName(hAir, z.humidity_air_channel_index);
                    extraParts.push(`HA: ${nm || '—'} (${z.humidity_air_channel_index})`);
                }
                if (z.temperature_soil_channel_index != null) {
                    const nm = findName(tSoil, z.temperature_soil_channel_index);
                    extraParts.push(`TS: ${nm || '—'} (${z.temperature_soil_channel_index})`);
                }
                if (z.ph_soil_channel_index != null) {
                    const nm = findName(phSoil, z.ph_soil_channel_index);
                    extraParts.push(`pH: ${nm || '—'} (${z.ph_soil_channel_index})`);
                }
                if (z.ec_soil_channel_index != null) {
                    const nm = findName(ecSoil, z.ec_soil_channel_index);
                    extraParts.push(`EC: ${nm || '—'} (${z.ec_soil_channel_index})`);
                }

                const thrTxt = `Umbral: ${Math.round(Number(z.humidity_low_threshold ?? 25))}%`;
                el.textContent = [sTxt, vTxt, ...extraParts, thrTxt].join(' · ');
            }
        }

        function renderZonesUI() {
            const container = document.getElementById('zonesContainer');
            if (!container) return;

            const soil = (channels || [])
                .filter(c => c && c.kind === 'soil_sensor')
                .slice()
                .sort((a, b) => Number(a.channel_index) - Number(b.channel_index));
            const valves = (channels || [])
                .filter(c => c && c.kind === 'valve')
                .slice()
                .sort((a, b) => Number(a.channel_index) - Number(b.channel_index));
            const tAir = (channels || [])
                .filter(c => c && c.kind === 'temperature_air')
                .slice()
                .sort((a, b) => Number(a.channel_index) - Number(b.channel_index));
            const hAir = (channels || [])
                .filter(c => c && c.kind === 'humidity_air')
                .slice()
                .sort((a, b) => Number(a.channel_index) - Number(b.channel_index));
            const tSoil = (channels || [])
                .filter(c => c && c.kind === 'temperature_soil')
                .slice()
                .sort((a, b) => Number(a.channel_index) - Number(b.channel_index));
            const phSoil = (channels || [])
                .filter(c => c && c.kind === 'ph_soil')
                .slice()
                .sort((a, b) => Number(a.channel_index) - Number(b.channel_index));
            const ecSoil = (channels || [])
                .filter(c => c && c.kind === 'ec_soil')
                .slice()
                .sort((a, b) => Number(a.channel_index) - Number(b.channel_index));

            // Importante: NO auto-asignar plantas 2..8.
            // Solo intentamos auto-asignar PLANTA 1 si está sin asignar.
            try {
                const z0 = zonesState?.[0];
                if (z0) {
                    if (z0.soil_channel_index == null && soil.some(x => Number(x.channel_index) === 1)) z0.soil_channel_index = 1;
                    if (z0.valve_channel_index == null && valves.some(x => Number(x.channel_index) === 1)) z0.valve_channel_index = 1;
                }
            } catch {}

            function usedSetFor(kind, excludeIdx) {
                const ZONE_PROP_BY_KIND = {
                    soil: 'soil_channel_index',
                    valve: 'valve_channel_index',
                    temperature_air: 'temperature_air_channel_index',
                    humidity_air: 'humidity_air_channel_index',
                    temperature_soil: 'temperature_soil_channel_index',
                    ph_soil: 'ph_soil_channel_index',
                    ec_soil: 'ec_soil_channel_index'
                };

                const prop = ZONE_PROP_BY_KIND[kind];
                if (!prop) return new Set();
                const s = new Set();
                for (let i = 0; i < 8; i++) {
                    if (i === excludeIdx) continue;
                    const z = zonesState[i];
                    if (!z) continue;
                    const v = z[prop];
                    if (v == null) continue;
                    const n = Number(v);
                    if (Number.isFinite(n)) s.add(n);
                }
                return s;
            }

            const isAnyAssigned = (z) => {
                if (!z) return false;
                return (
                    z.soil_channel_index != null ||
                    z.valve_channel_index != null ||
                    z.temperature_air_channel_index != null ||
                    z.humidity_air_channel_index != null ||
                    z.temperature_soil_channel_index != null ||
                    z.ph_soil_channel_index != null ||
                    z.ec_soil_channel_index != null
                );
            };

            function setCardOffByValueId(valueId, isOff) {
                const el = document.getElementById(valueId);
                const card = el ? el.closest('.sensor-card') : null;
                if (!card) return;
                card.classList.toggle('card-off', !!isOff);
            }

            function updateZoneCardsOff(zoneNum) {
                const zi = zoneNum - 1;
                const z = zonesState?.[zi];
                if (!z) return;
                setCardOffByValueId(`zoneHum${zoneNum}`, z.soil_channel_index == null);
                setCardOffByValueId(`zoneTSoil${zoneNum}`, z.temperature_soil_channel_index == null);
                setCardOffByValueId(`zoneTAir${zoneNum}`, z.temperature_air_channel_index == null);
                setCardOffByValueId(`zoneHAir${zoneNum}`, z.humidity_air_channel_index == null);
                setCardOffByValueId(`zonePH${zoneNum}`, z.ph_soil_channel_index == null);
                setCardOffByValueId(`zoneEC${zoneNum}`, z.ec_soil_channel_index == null);
                setCardOffByValueId(`zoneValve${zoneNum}`, z.valve_channel_index == null);
            }

            function populateSelect(sel, list, currentValue, usedSet, kindLabel) {
                if (!sel) return;
                sel.innerHTML = '';

                const optNone = document.createElement('option');
                optNone.value = '';
                optNone.textContent = '(sin asignar)';
                sel.appendChild(optNone);

                for (const c of list) {
                    const idx = Number(c.channel_index);
                    if (!Number.isFinite(idx)) continue;
                    const opt = document.createElement('option');
                    opt.value = String(idx);
                    const nm = String(c.name || `${kindLabel} ${idx}`);
                    opt.textContent = `${nm} (${idx})`;
                    // No permitir reutilizar el mismo canal en varias plantas
                    if (usedSet.has(idx) && Number(currentValue) !== idx) {
                        opt.disabled = true;
                        opt.textContent = `${nm} (${idx}) — usado en otra planta`;
                    }
                    sel.appendChild(opt);
                }

                sel.value = currentValue == null ? '' : String(currentValue);
            }

            function refreshSelectsForKind({ selectIdPrefix, list, zoneProp, usedKindKey, kindLabel }) {
                for (let zi = 0; zi < 8; zi++) {
                    const zNum = zi + 1;
                    const el = document.getElementById(`${selectIdPrefix}${zNum}`);
                    populateSelect(el, list, zonesState[zi]?.[zoneProp] ?? null, usedSetFor(usedKindKey, zi), kindLabel);
                }
            }

            function addKindSelector({ zoneNum, zoneIndex, zoneRow, labelText, selectIdPrefix, list, zoneProp, usedKindKey, kind, kindLabel }) {
                const row = document.createElement('div');
                row.className = 'control-row';
                const label = document.createElement('label');
                label.textContent = labelText;
                const sel = document.createElement('select');
                sel.id = `${selectIdPrefix}${zoneNum}`;
                sel.title = `Seleccionar ${kindLabel.toLowerCase()} (canal)`;
                populateSelect(sel, list, zonesState[zoneIndex]?.[zoneProp] ?? null, usedSetFor(usedKindKey, zoneIndex), kindLabel);

                const renameBtn = document.createElement('button');
                renameBtn.type = 'button';
                renameBtn.className = 'mini-btn tiny zone-rename-btn';
                renameBtn.textContent = 'Renombrar';
                renameBtn.title = `Renombrar ${kindLabel.toLowerCase()} seleccionado`;

                row.appendChild(label);
                row.appendChild(sel);
                row.appendChild(renameBtn);
                zoneRow.appendChild(row);

                renameBtn.addEventListener('click', async () => {
                    const idx = sel.value === '' ? null : Number(sel.value);
                    if (!Number.isFinite(idx)) return alert('Selecciona un canal para renombrar.');
                    const ch = (channels || []).find(c => c && c.kind === kind && Number(c.channel_index) === idx);
                    if (!ch || !ch.id) return alert('No se encontró el canal.');
                    await renameChannel(ch.id, `${kindLabel.toLowerCase()} (planta ${zoneNum})`);
                    await loadChannels();
                });

                sel.addEventListener('change', () => {
                    const v = sel.value === '' ? null : Number(sel.value);
                    zonesState[zoneIndex][zoneProp] = Number.isFinite(v) ? v : null;
                    refreshSelectsForKind({ selectIdPrefix, list, zoneProp, usedKindKey, kindLabel });
                    updateZoneSubtitles();
                    updateZoneCardsOff(zoneNum);
                    scheduleZoneChartsRebuild();
                    const sec = document.getElementById(`zoneSec${zoneNum}`);
                    const anyAssigned = isAnyAssigned(zonesState[zoneIndex]);
                    if (sec) sec.classList.toggle('zone-off', !anyAssigned);
                });
            }

            async function saveZoneConfig(zoneNum, btnEl) {
                const i = zoneNum - 1;
                const z = zonesState[i];
                if (!z) return;
                const headersBase = { 'Content-Type': 'application/json' };

                async function doSave(headers, body) {
                    return fetch(`/api/config/${encodeURIComponent(deviceCode)}`, {
                        method: 'POST',
                        headers,
                        credentials: 'include',
                        body: JSON.stringify(body)
                    });
                }

                const saved = (getSavedToken(deviceCode) || '').trim();
                const headers1 = { ...headersBase };
                if (saved) headers1['X-Device-Token'] = saved;

                // Traemos config actual y solo tocamos zones
                const rCfg = await fetch(`/api/config/${encodeURIComponent(deviceCode)}`, { credentials: 'include' });
                if (rCfg.status === 401) return doLogout();
                const cfg = await rCfg.json().catch(() => ({}));
                const baseThr = Number(cfg?.humidity_low_threshold ?? config.threshold ?? 25);
                const zones = normalizeZonesFromServer(cfg?.zones, baseThr);
                zones[i] = {
                    zone: zoneNum,
                    soil_channel_index: z.soil_channel_index == null ? null : Number(z.soil_channel_index),
                    valve_channel_index: z.valve_channel_index == null ? null : Number(z.valve_channel_index),
                    temperature_air_channel_index: z.temperature_air_channel_index == null ? null : Number(z.temperature_air_channel_index),
                    humidity_air_channel_index: z.humidity_air_channel_index == null ? null : Number(z.humidity_air_channel_index),
                    temperature_soil_channel_index: z.temperature_soil_channel_index == null ? null : Number(z.temperature_soil_channel_index),
                    ph_soil_channel_index: z.ph_soil_channel_index == null ? null : Number(z.ph_soil_channel_index),
                    ec_soil_channel_index: z.ec_soil_channel_index == null ? null : Number(z.ec_soil_channel_index),
                    humidity_low_threshold: z.humidity_low_threshold == null ? null : Number(z.humidity_low_threshold)
                };

                const body = {
                    // Compat: muchos firmwares/ OLED solo leen el umbral global.
                    // Si hay umbral por planta, usamos PLANTA 1 como umbral global.
                    humidity_low_threshold: (zones && zones[0] && zones[0].humidity_low_threshold != null)
                        ? Number(zones[0].humidity_low_threshold)
                        : (cfg?.humidity_low_threshold ?? config.threshold),
                    humidity_low_color: cfg?.humidity_low_color ?? config.colorB,
                    humidity_good_color: cfg?.humidity_good_color ?? config.colorG,
                    wet_v: cfg?.wet_v,
                    dry_v: cfg?.dry_v,
                    alert_humidity_low_minutes: cfg?.alert_humidity_low_minutes ?? 0,
                    alert_valve_on_max_minutes: cfg?.alert_valve_on_max_minutes ?? 0,
                    alert_sensor_dead_minutes: cfg?.alert_sensor_dead_minutes ?? 0,
                    alert_voltage_min: (cfg?.alert_voltage_min == null ? null : cfg.alert_voltage_min),
                    alert_voltage_max: (cfg?.alert_voltage_max == null ? null : cfg.alert_voltage_max),
                    notify_webhook_url: (cfg?.notify_webhook_url == null ? null : cfg.notify_webhook_url),
                    notify_telegram_chat_id: (cfg?.notify_telegram_chat_id == null ? null : cfg.notify_telegram_chat_id),
                    zones
                };

                if (btnEl) btnEl.disabled = true;
                const oldText = btnEl ? btnEl.textContent : '';
                if (btnEl) btnEl.textContent = 'Guardando…';

                try {
                    let res = await doSave(headers1, body);
                    if (res.status === 401 || res.status === 403) {
                        const msg = saved
                            ? 'Token guardado inválido o caducado. Pega el token correcto:'
                            : 'Este dispositivo requiere token para guardar. Pégalo aquí:';
                        const t = (prompt(msg) || '').trim();
                        if (t) {
                            saveToken(deviceCode, t);
                            const headers2 = { ...headersBase, 'X-Device-Token': t };
                            res = await doSave(headers2, body);
                        }
                    }
                    if (!res.ok) throw new Error('Error guardando');
                    if (btnEl) btnEl.textContent = 'Guardado';
                    setTimeout(() => {
                        if (btnEl) btnEl.textContent = oldText || 'Guardar';
                    }, 1200);
                } finally {
                    if (btnEl) btnEl.disabled = false;
                }
            }

            container.innerHTML = '';

            for (let i = 0; i < 8; i++) {
                const zoneNum = i + 1;

                const sec = document.createElement('div');
                sec.className = 'section';
                sec.id = `zoneSec${zoneNum}`;

                const h2 = document.createElement('h2');
                h2.textContent = `PLANTA ${zoneNum}`;
                sec.appendChild(h2);

                const subtitle = document.createElement('div');
                subtitle.className = 'zone-subtitle';
                subtitle.id = `zoneSubtitle${zoneNum}`;
                subtitle.textContent = '—';
                sec.appendChild(subtitle);

                const zoneRow = document.createElement('div');
                zoneRow.className = 'zone-row';

                // Selector sensor
                {
                    const row = document.createElement('div');
                    row.className = 'control-row';
                    const label = document.createElement('label');
                    label.textContent = 'Sensor de humedad:';
                    const sel = document.createElement('select');
                    sel.id = `zoneSoilSel${zoneNum}`;
                    sel.title = 'Seleccionar sensor de humedad (canal)';
                    populateSelect(sel, soil, zonesState[i]?.soil_channel_index ?? null, usedSetFor('soil', i), 'Sensor');
                    const renameBtn = document.createElement('button');
                    renameBtn.type = 'button';
                    renameBtn.className = 'mini-btn tiny zone-rename-btn';
                    renameBtn.textContent = 'Renombrar';
                    renameBtn.title = 'Renombrar el sensor seleccionado';
                    row.appendChild(label);
                    row.appendChild(sel);
                    row.appendChild(renameBtn);
                    zoneRow.appendChild(row);

                    renameBtn.addEventListener('click', async () => {
                        const idx = sel.value === '' ? null : Number(sel.value);
                        if (!Number.isFinite(idx)) return alert('Selecciona un sensor para renombrar.');
                        const ch = (channels || []).find(c => c && c.kind === 'soil_sensor' && Number(c.channel_index) === idx);
                        if (!ch || !ch.id) return alert('No se encontró el canal.');
                        await renameChannel(ch.id, `el sensor (planta ${zoneNum})`);
                        await loadChannels();
                    });

                    sel.addEventListener('change', () => {
                        const v = sel.value === '' ? null : Number(sel.value);
                        zonesState[i].soil_channel_index = Number.isFinite(v) ? v : null;
                        // Refrescar disables para no reutilizar canales
                        for (let zi = 0; zi < 8; zi++) {
                            const zNum = zi + 1;
                            const sSel = document.getElementById(`zoneSoilSel${zNum}`);
                            populateSelect(sSel, soil, zonesState[zi]?.soil_channel_index ?? null, usedSetFor('soil', zi), 'Sensor');
                        }
                        updateZoneSubtitles();
                        updateZoneCardsOff(zoneNum);
                        scheduleZoneChartsRebuild();
                        // Apagar visualmente si queda sin asignar
                        const sec = document.getElementById(`zoneSec${zoneNum}`);
                        const anyAssigned = isAnyAssigned(zonesState[i]);
                        if (sec) sec.classList.toggle('zone-off', !anyAssigned);
                    });
                }

                // Sensores extra
                addKindSelector({
                    zoneNum,
                    zoneIndex: i,
                    zoneRow,
                    labelText: 'Temperatura aire:',
                    selectIdPrefix: 'zoneTAirSel',
                    list: tAir,
                    zoneProp: 'temperature_air_channel_index',
                    usedKindKey: 'temperature_air',
                    kind: 'temperature_air',
                    kindLabel: 'Temperatura aire'
                });
                addKindSelector({
                    zoneNum,
                    zoneIndex: i,
                    zoneRow,
                    labelText: 'Humedad aire:',
                    selectIdPrefix: 'zoneHAirSel',
                    list: hAir,
                    zoneProp: 'humidity_air_channel_index',
                    usedKindKey: 'humidity_air',
                    kind: 'humidity_air',
                    kindLabel: 'Humedad aire'
                });
                addKindSelector({
                    zoneNum,
                    zoneIndex: i,
                    zoneRow,
                    labelText: 'Temperatura tierra:',
                    selectIdPrefix: 'zoneTSoilSel',
                    list: tSoil,
                    zoneProp: 'temperature_soil_channel_index',
                    usedKindKey: 'temperature_soil',
                    kind: 'temperature_soil',
                    kindLabel: 'Temperatura tierra'
                });
                addKindSelector({
                    zoneNum,
                    zoneIndex: i,
                    zoneRow,
                    labelText: 'pH tierra:',
                    selectIdPrefix: 'zonePHSoilSel',
                    list: phSoil,
                    zoneProp: 'ph_soil_channel_index',
                    usedKindKey: 'ph_soil',
                    kind: 'ph_soil',
                    kindLabel: 'pH tierra'
                });
                addKindSelector({
                    zoneNum,
                    zoneIndex: i,
                    zoneRow,
                    labelText: 'EC tierra:',
                    selectIdPrefix: 'zoneECSoilSel',
                    list: ecSoil,
                    zoneProp: 'ec_soil_channel_index',
                    usedKindKey: 'ec_soil',
                    kind: 'ec_soil',
                    kindLabel: 'EC tierra'
                });

                // Selector válvula
                {
                    const row = document.createElement('div');
                    row.className = 'control-row';
                    const label = document.createElement('label');
                    label.textContent = 'Válvula:';
                    const sel = document.createElement('select');
                    sel.id = `zoneValveSel${zoneNum}`;
                    sel.title = 'Seleccionar válvula (canal)';
                    populateSelect(sel, valves, zonesState[i]?.valve_channel_index ?? null, usedSetFor('valve', i), 'Válvula');
                    const renameBtn = document.createElement('button');
                    renameBtn.type = 'button';
                    renameBtn.className = 'mini-btn tiny zone-rename-btn';
                    renameBtn.textContent = 'Renombrar';
                    renameBtn.title = 'Renombrar la válvula seleccionada';
                    row.appendChild(label);
                    row.appendChild(sel);
                    row.appendChild(renameBtn);
                    zoneRow.appendChild(row);

                    renameBtn.addEventListener('click', async () => {
                        const idx = sel.value === '' ? null : Number(sel.value);
                        if (!Number.isFinite(idx)) return alert('Selecciona una válvula para renombrar.');
                        const ch = (channels || []).find(c => c && c.kind === 'valve' && Number(c.channel_index) === idx);
                        if (!ch || !ch.id) return alert('No se encontró el canal.');
                        await renameChannel(ch.id, `la válvula (planta ${zoneNum})`);
                        await loadChannels();
                    });

                    sel.addEventListener('change', () => {
                        const v = sel.value === '' ? null : Number(sel.value);
                        zonesState[i].valve_channel_index = Number.isFinite(v) ? v : null;
                        // Refrescar disables para no reutilizar canales
                        for (let zi = 0; zi < 8; zi++) {
                            const zNum = zi + 1;
                            const vSel = document.getElementById(`zoneValveSel${zNum}`);
                            populateSelect(vSel, valves, zonesState[zi]?.valve_channel_index ?? null, usedSetFor('valve', zi), 'Válvula');
                        }
                        updateZoneSubtitles();
                        updateZoneCardsOff(zoneNum);
                        scheduleZoneChartsRebuild();
                        const sec = document.getElementById(`zoneSec${zoneNum}`);
                        const anyAssigned = isAnyAssigned(zonesState[i]);
                        if (sec) sec.classList.toggle('zone-off', !anyAssigned);
                    });
                }

                // Umbral por planta
                {
                    const row = document.createElement('div');
                    row.className = 'control-row';
                    const label = document.createElement('label');
                    label.textContent = 'Umbral riego automático:';
                    const wrap = document.createElement('div');
                    wrap.style.display = 'flex';
                    wrap.style.gap = '10px';
                    wrap.style.alignItems = 'center';
                    wrap.style.flex = '2';
                    const rng = document.createElement('input');
                    rng.type = 'range';
                    rng.min = '1';
                    rng.max = '100';
                    rng.id = `zoneThr${zoneNum}`;
                    rng.title = 'Umbral de humedad baja (zona)';
                    const val = document.createElement('span');
                    val.id = `zoneThrVal${zoneNum}`;
                    val.style.width = '50px';
                    val.style.textAlign = 'right';

                    const btn = document.createElement('button');
                    btn.type = 'button';
                    btn.className = 'mini-btn primary tiny';
                    btn.textContent = 'Guardar';
                    btn.title = 'Guardar umbral (y asignación) solo de esta planta';

                    wrap.appendChild(rng);
                    wrap.appendChild(val);
                    wrap.appendChild(btn);
                    row.appendChild(label);
                    row.appendChild(wrap);
                    zoneRow.appendChild(row);

                    rng.addEventListener('input', () => {
                        const n = Number(rng.value);
                        zonesState[i].humidity_low_threshold = Number.isFinite(n) ? Math.max(0, Math.min(100, n)) : zonesState[i].humidity_low_threshold;
                        val.textContent = `${zonesState[i].humidity_low_threshold}%`;
                        updateZoneSubtitles();
                    });

                    btn.addEventListener('click', async () => {
                        await saveZoneConfig(zoneNum, btn);
                    });
                }

                sec.appendChild(zoneRow);

                const grid = document.createElement('div');
                grid.className = 'sensor-grid';

                const humCard = document.createElement('div');
                humCard.className = 'sensor-card metric-neutral accent accent-green';
                humCard.innerHTML = `<div class="sensor-label">Humedad (zona)</div><div class="sensor-value" id="zoneHum${zoneNum}">--</div><div class="sensor-unit">%</div><div class="chart-wrap"><canvas id="zoneHumChart${zoneNum}"></canvas></div>`;

                const tSoilCard = document.createElement('div');
                tSoilCard.className = 'sensor-card metric-neutral accent accent-purple';
                tSoilCard.innerHTML = `<div class="sensor-label">Temp. tierra</div><div class="sensor-value" id="zoneTSoil${zoneNum}">--</div><div class="sensor-unit">°C</div><div class="chart-wrap"><canvas id="zoneTSoilChart${zoneNum}"></canvas></div>`;

                const tAirCard = document.createElement('div');
                tAirCard.className = 'sensor-card metric-neutral accent accent-blue';
                tAirCard.innerHTML = `<div class="sensor-label">Temp. aire</div><div class="sensor-value" id="zoneTAir${zoneNum}">--</div><div class="sensor-unit">°C</div><div class="chart-wrap"><canvas id="zoneTAirChart${zoneNum}"></canvas></div>`;

                const hAirCard = document.createElement('div');
                hAirCard.className = 'sensor-card metric-neutral accent accent-indigo';
                hAirCard.innerHTML = `<div class="sensor-label">Humedad aire</div><div class="sensor-value" id="zoneHAir${zoneNum}">--</div><div class="sensor-unit">%</div><div class="chart-wrap"><canvas id="zoneHAirChart${zoneNum}"></canvas></div>`;

                const phCard = document.createElement('div');
                phCard.className = 'sensor-card metric-neutral accent accent-amber';
                phCard.innerHTML = `<div class="sensor-label">pH tierra</div><div class="sensor-value" id="zonePH${zoneNum}">--</div><div class="sensor-unit">pH</div><div class="chart-wrap"><canvas id="zonePHChart${zoneNum}"></canvas></div>`;

                const ecCard = document.createElement('div');
                ecCard.className = 'sensor-card metric-neutral accent accent-cyan';
                ecCard.innerHTML = `<div class="sensor-label">EC tierra</div><div class="sensor-value" id="zoneEC${zoneNum}">--</div><div class="sensor-unit">mS/cm</div><div class="chart-wrap"><canvas id="zoneECChart${zoneNum}"></canvas></div>`;

                const valveCard = document.createElement('div');
                valveCard.className = 'sensor-card metric-neutral accent accent-red';
                valveCard.innerHTML = `<div class="sensor-label">Válvula (zona)</div><div class="sensor-value" id="zoneValve${zoneNum}">--</div><div class="valve-indicator"><div class="valve-dot" id="zoneValveDot${zoneNum}"></div><div class="valve-text" id="zoneValveText${zoneNum}">--</div></div><div class="chart-wrap"><canvas id="zoneValveChart${zoneNum}"></canvas></div>`;

                const statusCard = document.createElement('div');
                statusCard.className = 'sensor-card metric-neutral accent accent-cyan';
                statusCard.innerHTML = `<div class="sensor-label">Estado</div><div class="sensor-value" id="zoneState${zoneNum}">--</div><div class="sensor-unit zone-mini" id="zoneAge${zoneNum}"></div>`;

                const zoneSummary = document.createElement('div');
                zoneSummary.className = 'summary';
                zoneSummary.style.marginTop = '10px';
                zoneSummary.innerHTML = `
                    <div>
                        <div class="k">Humedad Media</div>
                        <div class="v" id="zoneAvgHumidity${zoneNum}">--</div>
                    </div>
                    <div>
                        <div class="k">Último punto</div>
                        <div class="v" id="zoneLastPoint${zoneNum}">--</div>
                    </div>
                    <div>
                        <div class="k">Tiempo Válvula ON</div>
                        <div class="v" id="zoneTotalValveOn${zoneNum}">--</div>
                    </div>`;

                grid.appendChild(humCard);
                grid.appendChild(tSoilCard);
                grid.appendChild(tAirCard);
                grid.appendChild(hAirCard);
                grid.appendChild(phCard);
                grid.appendChild(ecCard);
                grid.appendChild(valveCard);
                grid.appendChild(statusCard);

                sec.appendChild(zoneSummary);
                sec.appendChild(grid);
                container.appendChild(sec);

                // Tarjetas visibles siempre, pero apagadas si su canal no está asignado
                updateZoneCardsOff(zoneNum);
            }

            applyZonesStateToUI();
            initCollapsibles();
            updateZoneSubtitles();
            scheduleZoneChartsRebuild();

            // Marcar OFF las zonas sin asignar desde el primer render
            for (let i = 0; i < 8; i++) {
                const zoneNum = i + 1;
                const sec = document.getElementById(`zoneSec${zoneNum}`);
                const z = zonesState[i];
                const anyAssigned = isAnyAssigned(z);
                if (sec) sec.classList.toggle('zone-off', !anyAssigned);
            }
        }

        function applyZonesStateToUI() {
            for (let i = 0; i < 8; i++) {
                const zoneNum = i + 1;
                const z = zonesState[i];
                const soilSel = document.getElementById(`zoneSoilSel${zoneNum}`);
                const valveSel = document.getElementById(`zoneValveSel${zoneNum}`);
                const tAirSel = document.getElementById(`zoneTAirSel${zoneNum}`);
                const hAirSel = document.getElementById(`zoneHAirSel${zoneNum}`);
                const tSoilSel = document.getElementById(`zoneTSoilSel${zoneNum}`);
                const phSel = document.getElementById(`zonePHSoilSel${zoneNum}`);
                const ecSel = document.getElementById(`zoneECSoilSel${zoneNum}`);
                const thr = document.getElementById(`zoneThr${zoneNum}`);
                const thrVal = document.getElementById(`zoneThrVal${zoneNum}`);

                if (soilSel) soilSel.value = z.soil_channel_index == null ? '' : String(z.soil_channel_index);
                if (valveSel) valveSel.value = z.valve_channel_index == null ? '' : String(z.valve_channel_index);
                if (tAirSel) tAirSel.value = z.temperature_air_channel_index == null ? '' : String(z.temperature_air_channel_index);
                if (hAirSel) hAirSel.value = z.humidity_air_channel_index == null ? '' : String(z.humidity_air_channel_index);
                if (tSoilSel) tSoilSel.value = z.temperature_soil_channel_index == null ? '' : String(z.temperature_soil_channel_index);
                if (phSel) phSel.value = z.ph_soil_channel_index == null ? '' : String(z.ph_soil_channel_index);
                if (ecSel) ecSel.value = z.ec_soil_channel_index == null ? '' : String(z.ec_soil_channel_index);
                if (thr) thr.value = String(Math.round(Number(z.humidity_low_threshold ?? 25)));
                if (thrVal) thrVal.textContent = `${Math.round(Number(z.humidity_low_threshold ?? 25))}%`;
            }
        }

        function updateZonesFromLatestPayload(payload) {
            lastChannelsLatestPayload = payload || null;
            const ch = Array.isArray(payload?.channels) ? payload.channels : [];
            const byKey = new Map();
            for (const c of ch) {
                const kind = String(c?.kind || '');
                const idx = Number(c?.channel_index);
                if (!kind || !Number.isFinite(idx)) continue;
                byKey.set(`${kind}:${idx}`, c.latest || null);
            }

            const STALE_MIN = 10;

            // Heurística anti-datos-falsos:
            // Si solo hay 1 sensor y 1 válvula con datos recientes, mantenemos solo PLANTA 1 asignada.
            // Esto es local (no guarda nada en servidor).
            try {
                const presentSoil = new Set();
                const presentValve = new Set();
                for (const c of ch) {
                    const kind = String(c?.kind || '');
                    const idx = Number(c?.channel_index);
                    if (!Number.isFinite(idx)) continue;
                    const age = c?.latest?.age_minutes;
                    const okAge = (age == null) || (Number(age) <= STALE_MIN);
                    if (!okAge) continue;
                    if (kind === 'soil_sensor' && c?.latest?.value != null) presentSoil.add(idx);
                    if (kind === 'valve' && c?.latest?.state != null) presentValve.add(idx);
                }
                if (presentSoil.size <= 1 && presentValve.size <= 1) {
                    for (let i = 1; i < 8; i++) {
                        const z = zonesState[i];
                        if (!z) continue;
                        z.soil_channel_index = null;
                        z.valve_channel_index = null;
                    }
                }
            } catch {}

            for (let i = 0; i < 8; i++) {
                const zoneNum = i + 1;
                const z = zonesState[i];
                const sec = document.getElementById(`zoneSec${zoneNum}`);

                const soilIdx = z.soil_channel_index;
                const valveIdx = z.valve_channel_index;
                const tAirIdx = z.temperature_air_channel_index;
                const hAirIdx = z.humidity_air_channel_index;
                const tSoilIdx = z.temperature_soil_channel_index;
                const phIdx = z.ph_soil_channel_index;
                const ecIdx = z.ec_soil_channel_index;
                const soilLatest = soilIdx == null ? null : byKey.get(`soil_sensor:${soilIdx}`);
                const valveLatest = valveIdx == null ? null : byKey.get(`valve:${valveIdx}`);
                const tAirLatest = tAirIdx == null ? null : byKey.get(`temperature_air:${tAirIdx}`);
                const hAirLatest = hAirIdx == null ? null : byKey.get(`humidity_air:${hAirIdx}`);
                const tSoilLatest = tSoilIdx == null ? null : byKey.get(`temperature_soil:${tSoilIdx}`);
                const phLatest = phIdx == null ? null : byKey.get(`ph_soil:${phIdx}`);
                const ecLatest = ecIdx == null ? null : byKey.get(`ec_soil:${ecIdx}`);

                // Mini gráficas: ingerir puntos en tiempo real si existen
                if (soilIdx != null && soilLatest) ingestMiniChartPoint(`zoneHumChart${zoneNum}`, soilLatest, { kind: 'value' });
                if (tSoilIdx != null && tSoilLatest) ingestMiniChartPoint(`zoneTSoilChart${zoneNum}`, tSoilLatest, { kind: 'value' });
                if (tAirIdx != null && tAirLatest) ingestMiniChartPoint(`zoneTAirChart${zoneNum}`, tAirLatest, { kind: 'value' });
                if (hAirIdx != null && hAirLatest) ingestMiniChartPoint(`zoneHAirChart${zoneNum}`, hAirLatest, { kind: 'value' });
                if (phIdx != null && phLatest) ingestMiniChartPoint(`zonePHChart${zoneNum}`, phLatest, { kind: 'value' });
                if (ecIdx != null && ecLatest) ingestMiniChartPoint(`zoneECChart${zoneNum}`, ecLatest, { kind: 'value' });
                if (valveIdx != null && valveLatest) ingestMiniChartPoint(`zoneValveChart${zoneNum}`, valveLatest, { kind: 'valve' });

                const humEl = document.getElementById(`zoneHum${zoneNum}`);
                const tAirEl = document.getElementById(`zoneTAir${zoneNum}`);
                const hAirEl = document.getElementById(`zoneHAir${zoneNum}`);
                const tSoilEl = document.getElementById(`zoneTSoil${zoneNum}`);
                const phEl = document.getElementById(`zonePH${zoneNum}`);
                const ecEl = document.getElementById(`zoneEC${zoneNum}`);
                const valveEl = document.getElementById(`zoneValve${zoneNum}`);
                const dotEl = document.getElementById(`zoneValveDot${zoneNum}`);
                const txtEl = document.getElementById(`zoneValveText${zoneNum}`);
                const stateEl = document.getElementById(`zoneState${zoneNum}`);
                const ageEl = document.getElementById(`zoneAge${zoneNum}`);

                const soilAge = soilLatest?.age_minutes;
                const valveAge = valveLatest?.age_minutes;
                const tAirAge = tAirLatest?.age_minutes;
                const hAirAge = hAirLatest?.age_minutes;
                const tSoilAge = tSoilLatest?.age_minutes;
                const phAge = phLatest?.age_minutes;
                const ecAge = ecLatest?.age_minutes;
                const soilOk = soilLatest && soilLatest.value != null && (soilAge == null || Number(soilAge) <= STALE_MIN);
                const valveOk = valveLatest && valveLatest.state != null && (valveAge == null || Number(valveAge) <= STALE_MIN);
                const tAirOk = tAirLatest && tAirLatest.value != null && (tAirAge == null || Number(tAirAge) <= STALE_MIN);
                const hAirOk = hAirLatest && hAirLatest.value != null && (hAirAge == null || Number(hAirAge) <= STALE_MIN);
                const tSoilOk = tSoilLatest && tSoilLatest.value != null && (tSoilAge == null || Number(tSoilAge) <= STALE_MIN);
                const phOk = phLatest && phLatest.value != null && (phAge == null || Number(phAge) <= STALE_MIN);
                const ecOk = ecLatest && ecLatest.value != null && (ecAge == null || Number(ecAge) <= STALE_MIN);

                if (humEl) {
                    const v = soilLatest?.value;
                    const num = v == null ? null : Number(v);
                    humEl.textContent = soilOk && Number.isFinite(num) ? num.toFixed(1) : '--';
                }

                if (tAirEl) {
                    const v = tAirLatest?.value;
                    const num = v == null ? null : Number(v);
                    tAirEl.textContent = tAirOk && Number.isFinite(num) ? num.toFixed(1) : '--';
                }
                if (hAirEl) {
                    const v = hAirLatest?.value;
                    const num = v == null ? null : Number(v);
                    hAirEl.textContent = hAirOk && Number.isFinite(num) ? num.toFixed(1) : '--';
                }
                if (tSoilEl) {
                    const v = tSoilLatest?.value;
                    const num = v == null ? null : Number(v);
                    tSoilEl.textContent = tSoilOk && Number.isFinite(num) ? num.toFixed(1) : '--';
                }
                if (phEl) {
                    const v = phLatest?.value;
                    const num = v == null ? null : Number(v);
                    phEl.textContent = phOk && Number.isFinite(num) ? num.toFixed(2) : '--';
                }
                if (ecEl) {
                    const v = ecLatest?.value;
                    const num = v == null ? null : Number(v);
                    ecEl.textContent = ecOk && Number.isFinite(num) ? num.toFixed(2) : '--';
                }

                if (valveEl || dotEl || txtEl) {
                    const s = valveLatest?.state;
                    const st = s == null ? null : Number(s);
                    const isOn = valveOk && Number.isFinite(st) && st >= 1;
                    if (valveEl) valveEl.textContent = valveOk ? (isOn ? 'ON' : 'OFF') : '--';
                    if (dotEl) dotEl.className = 'valve-dot' + (valveOk ? (isOn ? ' on' : ' off') : '');
                    if (txtEl) txtEl.textContent = valveOk ? (isOn ? 'ENCENDIDA' : 'APAGADA') : 'SIN DATOS';
                }

                const anyAssigned = (
                    soilIdx != null || valveIdx != null ||
                    tAirIdx != null || hAirIdx != null ||
                    tSoilIdx != null || phIdx != null || ecIdx != null
                );
                const anyOk = soilOk || valveOk || tAirOk || hAirOk || tSoilOk || phOk || ecOk;
                if (stateEl) stateEl.textContent = !anyAssigned ? 'SIN ASIGNAR' : (anyOk ? 'ACTIVA' : 'APAGADA');

                const parts = [];
                if (soilIdx != null) parts.push(`S${soilIdx}:${soilLatest?.age_minutes ?? '--'}m`);
                if (tSoilIdx != null) parts.push(`TS${tSoilIdx}:${tSoilLatest?.age_minutes ?? '--'}m`);
                if (tAirIdx != null) parts.push(`TA${tAirIdx}:${tAirLatest?.age_minutes ?? '--'}m`);
                if (hAirIdx != null) parts.push(`HA${hAirIdx}:${hAirLatest?.age_minutes ?? '--'}m`);
                if (phIdx != null) parts.push(`pH${phIdx}:${phLatest?.age_minutes ?? '--'}m`);
                if (ecIdx != null) parts.push(`EC${ecIdx}:${ecLatest?.age_minutes ?? '--'}m`);
                if (valveIdx != null) parts.push(`V${valveIdx}:${valveLatest?.age_minutes ?? '--'}m`);
                if (ageEl) ageEl.textContent = parts.join(' · ');

                if (sec) sec.classList.toggle('zone-off', !anyAssigned || (anyAssigned && !anyOk));
            }
        }

        let channels = [];
        let humChannelId = null;
        let valveChannelId = null;

        let lastRebootsBase = null;
        let lastSampleMsForInterval = null;

        // --- Cuenta / navegación ---
        const navDevicesBtn = document.getElementById('navDevices');
        const navAccountBtn = document.getElementById('navAccount');
        const navSupportBtn = document.getElementById('navSupport');
            const supportBadge = document.getElementById('supportBadge');
        const navLogoutBtn = document.getElementById('navLogout');

        const accountSection = document.getElementById('accountSection');
        const accountStatus = document.getElementById('accountStatus');
        const accEmail = document.getElementById('accEmail');
        const accFullName = document.getElementById('accFullName');
        const accPhone = document.getElementById('accPhone');
        const accAddress = document.getElementById('accAddress');
        const accProvince = document.getElementById('accProvince');
        const accCity = document.getElementById('accCity');
        const accCountry = document.getElementById('accCountry');
        const btnSaveProfile = document.getElementById('btnSaveProfile');
        const btnDeleteAccount = document.getElementById('btnDeleteAccount');

        const supportSection = document.getElementById('supportSection');
        const supportStatus = document.getElementById('supportStatus');
        const tSubject = document.getElementById('tSubject');
        const tDevice = document.getElementById('tDevice');
        const tMessage = document.getElementById('tMessage');
        const btnCreateTicket = document.getElementById('btnCreateTicket');
        const ticketsList = document.getElementById('ticketsList');
        const tId = document.getElementById('tId');
        const tStatus = document.getElementById('tStatus');
        const tMessages = document.getElementById('tMessages');
        const tReply = document.getElementById('tReply');
        const btnReplyTicket = document.getElementById('btnReplyTicket');
        const btnCloseTicket = document.getElementById('btnCloseTicket');

        let selectedTicketId = null;

        function setAccountStatus(text, isErr = false) {
            if (!accountStatus) return;
            accountStatus.textContent = text || '—';
            accountStatus.className = 'status' + (isErr ? ' offline' : ' online');
        }

        function setView(view) {
            const isAccount = view === 'account';
            const isSupport = view === 'support';
            document.body.classList.toggle('mode-account', isAccount);
            document.body.classList.toggle('mode-support', isSupport);
            accountSection?.classList.toggle('hidden', !isAccount);
            supportSection?.classList.toggle('hidden', !isSupport);
            navDevicesBtn?.classList.toggle('active', !isAccount && !isSupport);
            navAccountBtn?.classList.toggle('active', isAccount);
            navSupportBtn?.classList.toggle('active', isSupport);
        }

        function setSupportStatus(text, isErr = false) {
            if (!supportStatus) return;
            supportStatus.textContent = text || '—';
            supportStatus.className = 'status' + (isErr ? ' offline' : ' online');
        }

        async function supportApi(path, opts = {}) {
            const r = await fetch(path, Object.assign({}, opts, { credentials: 'include' }));
            if (r.status === 401) return doLogout();
            const text = await r.text();
            let j = null;
            try { j = text ? JSON.parse(text) : null; } catch { j = { raw: text }; }
            if (!r.ok) throw new Error((j && j.error) ? j.error : `HTTP ${r.status}`);
            return j;
        }

            function setSupportBadge(n) {
                if (!supportBadge) return;
                const count = Math.max(0, Number(n) || 0);
                supportBadge.textContent = String(count);
                supportBadge.classList.toggle('hidden', count <= 0);
                // Si hay no leídos, resaltamos el botón
                navSupportBtn?.classList.toggle('primary', count > 0);
            }

            async function refreshSupportBadge() {
                try {
                    const j = await supportApi('/api/tickets/unread-count');
                    setSupportBadge(j.unread_count || 0);
                } catch {
                    // silencioso
                }
            }

        function safeText(el, text) {
            if (!el) return;
            el.textContent = text == null ? '' : String(text);
        }

        function renderTicketMessages(messages) {
            if (!tMessages) return;
            const rows = Array.isArray(messages) ? messages : [];
            if (!rows.length) {
                tMessages.innerHTML = '<div class="muted">Sin mensajes</div>';
                return;
            }
            tMessages.innerHTML = '';
            for (const m of rows) {
                const wrap = document.createElement('div');
                wrap.className = 'msg';
                const meta = document.createElement('div');
                meta.className = 'msg-meta';
                meta.textContent = `${m.author_type === 'admin' ? 'Soporte' : 'Tú'} · ${m.created_at_madrid || m.created_at || ''}`;
                const body = document.createElement('div');
                body.className = 'msg-body';
                body.textContent = String(m.body || '');
                wrap.appendChild(meta);
                wrap.appendChild(body);
                tMessages.appendChild(wrap);
            }
            tMessages.scrollTop = tMessages.scrollHeight;
        }

        function renderTicketsList(tickets) {
            if (!ticketsList) return;
            const rows = Array.isArray(tickets) ? tickets : [];
            ticketsList.innerHTML = '';
            if (!rows.length) {
                const empty = document.createElement('div');
                empty.className = 'muted';
                empty.textContent = 'No tienes tickets todavía.';
                ticketsList.appendChild(empty);
                return;
            }
            for (const t of rows) {
                const item = document.createElement('div');
                item.className = 'ticket-item';
                    if (t.has_unread) item.style.borderColor = 'rgba(239,68,68,0.55)';
                const title = document.createElement('div');
                title.className = 'ticket-title';
                title.textContent = t.subject || '(sin asunto)';
                const meta = document.createElement('div');
                meta.className = 'ticket-meta';
                meta.textContent = `${t.status || ''} · ${t.priority || ''}${t.device_code ? ' · ' + t.device_code : ''}`;
                item.appendChild(title);
                item.appendChild(meta);
                item.addEventListener('click', async () => {
                    await selectTicket(t.id);
                });
                ticketsList.appendChild(item);
            }
        }

        async function loadTickets() {
            try {
                setSupportStatus('Cargando tickets...', false);
                const j = await supportApi('/api/tickets');
                renderTicketsList(j.tickets || []);
                if (selectedTicketId) await selectTicket(selectedTicketId, true);
                    await refreshSupportBadge();
                setSupportStatus('Listo.', false);
            } catch (e) {
                setSupportStatus(e.message || 'Error cargando tickets', true);
            }
        }

        async function selectTicket(id, silent = false) {
            const tid = String(id || '').trim();
            if (!tid) return;
            selectedTicketId = tid;
            try {
                if (!silent) setSupportStatus('Cargando ticket...', false);
                const j = await supportApi(`/api/tickets/${encodeURIComponent(tid)}`);
                safeText(tId, j.ticket?.id || tid);
                safeText(tStatus, j.ticket?.status || '');
                renderTicketMessages(j.messages || []);
                    try { await supportApi(`/api/tickets/${encodeURIComponent(tid)}/mark-read`, { method: 'POST' }); } catch {}
                    await refreshSupportBadge();
                if (!silent) setSupportStatus('Ticket cargado.', false);
            } catch (e) {
                if (!silent) setSupportStatus(e.message || 'Error', true);
            }
        }

        async function populateTicketDeviceSelect() {
            if (!tDevice) return;
            const select = document.getElementById('deviceSelect');
            // Mantener opción "sin dispositivo"
            const keep = [{ value: '', text: '(sin dispositivo)' }];
            const opts = select ? Array.from(select.options || []).map(o => ({ value: o.value, text: o.textContent })) : [];
            const all = keep.concat(opts.filter(o => o.value));
            tDevice.innerHTML = '';
            for (const o of all) {
                const opt = document.createElement('option');
                opt.value = o.value;
                opt.textContent = o.text;
                tDevice.appendChild(opt);
            }
        }

        async function createTicket() {
            try {
                setSupportStatus('Enviando ticket...', false);
                const payload = {
                    subject: String(tSubject.value || '').trim(),
                    device_code: String(tDevice.value || '').trim() || null,
                    message: String(tMessage.value || '').trim()
                };
                if (!payload.subject || payload.subject.length < 3) throw new Error('Asunto demasiado corto');
                if (!payload.message || payload.message.length < 3) throw new Error('Mensaje demasiado corto');

                const j = await supportApi('/api/tickets', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                tSubject.value = '';
                tMessage.value = '';
                selectedTicketId = j.ticket_id || null;
                await loadTickets();
                if (selectedTicketId) await selectTicket(selectedTicketId, true);
                setSupportStatus('Ticket creado.', false);
            } catch (e) {
                setSupportStatus(e.message || 'Error creando ticket', true);
            }
        }

        async function replyToTicket() {
            if (!selectedTicketId) return setSupportStatus('Selecciona un ticket.', true);
            const body = String(tReply.value || '').trim();
            if (!body) return setSupportStatus('Escribe un mensaje.', true);
            try {
                setSupportStatus('Enviando respuesta...', false);
                await supportApi(`/api/tickets/${encodeURIComponent(selectedTicketId)}/messages`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ body })
                });
                tReply.value = '';
                await selectTicket(selectedTicketId, true);
                await loadTickets();
                setSupportStatus('Enviado.', false);
            } catch (e) {
                setSupportStatus(e.message || 'Error', true);
            }
        }

        async function closeTicket() {
            if (!selectedTicketId) return setSupportStatus('Selecciona un ticket.', true);
            const ok = confirm('¿Seguro que quieres cerrar este ticket?');
            if (!ok) return;
            try {
                setSupportStatus('Cerrando...', false);
                await supportApi(`/api/tickets/${encodeURIComponent(selectedTicketId)}/close`, { method: 'POST' });
                await selectTicket(selectedTicketId, true);
                await loadTickets();
                setSupportStatus('Ticket cerrado.', false);
            } catch (e) {
                setSupportStatus(e.message || 'Error', true);
            }
        }

        async function doLogout() {
            try { await fetch('/api/auth/logout', { method: 'POST', credentials: 'include' }); } catch {}
            const next = encodeURIComponent(location.pathname + location.search + location.hash);
            window.location.href = `/login?next=${next}`;
        }

        async function loadProfileIntoForm() {
            try {
                setAccountStatus('Cargando...', false);
                const r = await fetch('/api/me/profile', { credentials: 'include' });
                if (r.status === 401) return doLogout();
                const p = await r.json().catch(() => ({}));
                accEmail.value = p.email || '';
                accFullName.value = p.full_name || '';
                accPhone.value = p.phone || '';
                accAddress.value = p.address || '';
                accProvince.value = p.province || '';
                accCity.value = p.city || '';
                accCountry.value = p.country || '';
                setAccountStatus('Listo.', false);
            } catch {
                setAccountStatus('No se pudo cargar tu perfil.', true);
            }
        }

        async function saveProfileFromForm() {
            try {
                setAccountStatus('Guardando...', false);
                const payload = {
                    full_name: String(accFullName.value || '').trim() || undefined,
                    phone: String(accPhone.value || '').trim() || null,
                    address: String(accAddress.value || '').trim() || null,
                    province: String(accProvince.value || '').trim() || null,
                    city: String(accCity.value || '').trim() || null,
                    country: String(accCountry.value || '').trim() || null
                };
                const r = await fetch('/api/me/profile', {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify(payload)
                });
                if (r.status === 401) return doLogout();
                const j = await r.json().catch(() => ({}));
                if (!r.ok) throw new Error(j.error || 'No se pudo guardar');
                setAccountStatus('Guardado.', false);
            } catch (e) {
                setAccountStatus(e.message || 'Error guardando.', true);
            }
        }

        async function deleteAccount() {
            const ok = confirm('¿Seguro que quieres eliminar tu cuenta? Esta acción no se puede deshacer.');
            if (!ok) return;
            try {
                setAccountStatus('Eliminando cuenta...', false);
                const r = await fetch('/api/me', { method: 'DELETE', credentials: 'include' });
                const j = await r.json().catch(() => ({}));
                if (!r.ok) throw new Error(j.error || 'No se pudo eliminar');
                window.location.href = '/login';
            } catch (e) {
                setAccountStatus(e.message || 'Error eliminando.', true);
            }
        }

        navDevicesBtn?.addEventListener('click', () => setView('devices'));
        navAccountBtn?.addEventListener('click', async () => {
            setView('account');
            await loadProfileIntoForm();
        });
        navSupportBtn?.addEventListener('click', async () => {
            setView('support');
            try {
                await loadDevices();
                await populateTicketDeviceSelect();
            } catch {}
            await loadTickets();
        });
        navLogoutBtn?.addEventListener('click', doLogout);
        btnSaveProfile?.addEventListener('click', saveProfileFromForm);
        btnDeleteAccount?.addEventListener('click', deleteAccount);
        btnCreateTicket?.addEventListener('click', createTicket);
        btnReplyTicket?.addEventListener('click', replyToTicket);
        btnCloseTicket?.addEventListener('click', closeTicket);

            // Polling ligero: badge de tickets no leídos
            setTimeout(() => { refreshSupportBadge(); }, 800);
            setInterval(() => { refreshSupportBadge(); }, 15000);

        function rebootsOffsetKey(code) { return `rebootsOffset:${code}`; }
        function getLocalRebootsOffset(code) {
            try {
                const v = localStorage.getItem(rebootsOffsetKey(code));
                if (v == null || v === '') return 0;
                const n = Number(v);
                return Number.isFinite(n) && n >= 0 ? n : 0;
            } catch { return 0; }
        }
        function setLocalRebootsOffset(code, offset) {
            try { localStorage.setItem(rebootsOffsetKey(code), String(Math.max(0, Number(offset) || 0))); } catch {}
        }

        let chartsRebuildTimer = null;
        function scheduleChartsRebuild() {
            if (chartsRebuildTimer) return;
            chartsRebuildTimer = setTimeout(() => {
                chartsRebuildTimer = null;
                rebuildCharts();
            }, 1200);
        }

        // --- Mini gráficas por planta (una por tarjeta) ---
        let zoneChartsRebuildTimer = null;
        function scheduleZoneChartsRebuild() {
            if (zoneChartsRebuildTimer) return;
            zoneChartsRebuildTimer = setTimeout(() => {
                zoneChartsRebuildTimer = null;
                rebuildZoneMiniCharts();
            }, 900);
        }

        const DEFAULT_DEVICE = 'RIEGO_001';
        let deviceCode = (() => {
            const m = location.pathname.match(/\/panel\/([^\/?#]+)/);
            return m ? decodeURIComponent(m[1]) : DEFAULT_DEVICE;
        })();

        let hasDevices = true;

        function tokenStorageKey(code) { return `deviceToken:${code}`; }
        function getSavedToken(code) {
            try { return localStorage.getItem(tokenStorageKey(code)) || ''; } catch { return ''; }
        }
        function saveToken(code, token) {
            try { localStorage.setItem(tokenStorageKey(code), token || ''); } catch {}
        }

        function consumeTokenFromUrl() {
            try {
                const params = new URLSearchParams(location.search);
                const t = (params.get('token') || params.get('t') || '').trim();
                if (!t) return;
                saveToken(deviceCode, t);
                params.delete('token');
                params.delete('t');
                const qs = params.toString();
                const next = location.pathname + (qs ? `?${qs}` : '') + location.hash;
                history.replaceState({}, '', next);
            } catch {}
        }

        consumeTokenFromUrl();

        async function loadDevices() {
            const section = document.getElementById('deviceSection');
            const select = document.getElementById('deviceSelect');
            const meta = document.getElementById('deviceMeta');
            try {
                const r = await fetch('/api/devices', { credentials: 'include' });
                if (r.status === 401) {
                    const next = encodeURIComponent(location.pathname + location.search + location.hash);
                    window.location.href = `/login?next=${next}`;
                    return false;
                }
                const list = await r.json();

                if (!Array.isArray(list)) throw new Error('Sin lista');
                if (list.length === 0) {
                    hasDevices = false;
                    select.innerHTML = '';
                    meta.textContent = 'No hay dispositivos asignados a tu cuenta. Pulsa “+ Añadir dispositivo”.';
                    return true;
                }
                hasDevices = true;

                select.innerHTML = '';
                for (const d of list) {
                    const opt = document.createElement('option');
                    opt.value = d.device_code;
                    opt.textContent = `${d.device_code} — ${d.name || ''}`.trim();
                    select.appendChild(opt);
                }

                const exists = list.some(d => d.device_code === deviceCode);
                if (!exists) {
                    deviceCode = list[0].device_code;
                    history.replaceState({}, '', `/panel/${encodeURIComponent(deviceCode)}`);
                }
                select.value = deviceCode;

                const current = list.find(d => d.device_code === deviceCode);
                const lastSeen = current?.last_seen_madrid || (current?.last_seen ? new Date(current.last_seen).toLocaleString('es-ES', { timeZone: TZ, hour12: false }) : '--');
                const lastSeenDate = current?.last_seen ? parseTsToDate(current.last_seen) : null;
                const ageMin = lastSeenDate ? Math.max(0, Math.round((nowAdjusted().getTime() - lastSeenDate.getTime()) / 60000)) : null;
                const ageText = ageMin == null ? '' : ` (hace ${ageMin} min)`;
                meta.textContent = `${current?.name || deviceCode}${current?.location ? ' · ' + current.location : ''}`;

                select.addEventListener('change', () => {
                    const next = select.value;
                    if (next && next !== deviceCode) window.location.href = `/panel/${encodeURIComponent(next)}`;
                });

            } catch {
                if (section) section.style.display = 'none';
                return false;
            }

            return true;
        }

        async function loadChannels() {
            try {
                const r = await fetch(`/api/channels/${encodeURIComponent(deviceCode)}`);
                if (!r.ok) throw new Error('channels failed');
                const j = await r.json();
                channels = Array.isArray(j.channels) ? j.channels : [];

                const hums = channels.filter(c => c.kind === 'soil_sensor');
                const valves = channels.filter(c => c.kind === 'valve');

                const humSel = document.getElementById('humChannelSelect');
                const valveSel = document.getElementById('valveChannelSelect');
                humSel.innerHTML = '';
                valveSel.innerHTML = '';

                for (const c of hums) {
                    const opt = document.createElement('option');
                    opt.value = c.id;
                    opt.textContent = `${c.name} (${c.channel_index})`;
                    humSel.appendChild(opt);
                }
                for (const c of valves) {
                    const opt = document.createElement('option');
                    opt.value = c.id;
                    opt.textContent = `${c.name} (${c.channel_index})`;
                    valveSel.appendChild(opt);
                }

                if (!humChannelId || !hums.some(c => c.id === humChannelId)) humChannelId = hums[0]?.id || null;
                if (!valveChannelId || !valves.some(c => c.id === valveChannelId)) valveChannelId = valves[0]?.id || null;

                humSel.value = humChannelId || '';
                valveSel.value = valveChannelId || '';

                humSel.onchange = () => { humChannelId = humSel.value || null; scheduleChartsRebuild(); };
                valveSel.onchange = () => { valveChannelId = valveSel.value || null; scheduleChartsRebuild(); };

                const renameHumBtn = document.getElementById('btnRenameHum');
                const renameValveBtn = document.getElementById('btnRenameValve');
                if (renameHumBtn) renameHumBtn.disabled = hums.length === 0;
                if (renameValveBtn) renameValveBtn.disabled = valves.length === 0;

                // Si no hay canales, ocultar gráficas (pero normalmente habrá canal 1 por defecto)
                document.getElementById('humChannelSelect').disabled = hums.length === 0;
                document.getElementById('valveChannelSelect').disabled = valves.length === 0;

                // Re-render zonas para actualizar selects/labels
                renderZonesUI();

            } catch (e) {
                // Si falla, no rompemos
            }
        }

        // --- Zona horaria España (Europe/Madrid) ---
        const TZ = 'Europe/Madrid';
        const fmtNowEs = new Intl.DateTimeFormat('es-ES', {
            timeZone: TZ,
            year: 'numeric', month: '2-digit', day: '2-digit',
            hour: '2-digit', minute: '2-digit', second: '2-digit',
            hour12: false
        });
        const fmtDateEs = new Intl.DateTimeFormat('es-ES', {
            timeZone: TZ,
            year: 'numeric', month: '2-digit', day: '2-digit'
        });

        // Si el reloj del PC está mal, ajustamos con la hora del servidor.
        let serverClockOffsetMs = null; // server_now_ms - Date.now()
        function nowAdjusted() {
            return new Date(Date.now() + (serverClockOffsetMs == null ? 0 : serverClockOffsetMs));
        }

        function setConnectionUI(status) {
            const s = (status || 'unknown').toString().toLowerCase();
            const pairs = [
                { dot: document.getElementById('connDot'), text: document.getElementById('connText') },
                { dot: document.getElementById('topConnDot'), text: document.getElementById('topConnText') }
            ].filter(p => p.dot && p.text);
            if (!pairs.length) return;

            for (const { dot, text } of pairs) {
                dot.classList.remove('online', 'offline', 'unknown');
                if (s === 'online') {
                    dot.classList.add('online');
                    text.textContent = 'Online';
                } else if (s === 'offline') {
                    dot.classList.add('offline');
                    text.textContent = 'Offline';
                } else {
                    dot.classList.add('unknown');
                    text.textContent = '--';
                }
            }

            if (s === 'online') {
            } else if (s === 'offline') {
            } else {
            }
        }

        // Cache del último payload de /api/channels/:device_code/latest
        let lastChannelsLatestPayload = null;

        function setStatusText(text) {
            const st = document.getElementById('status');
            const top = document.getElementById('topStatusText');
            if (st) st.textContent = text;
            if (top) top.textContent = text;
        }

        function setStatusClass(isOnline) {
            const st = document.getElementById('status');
            if (!st) return;
            st.className = isOnline ? 'status online' : 'status offline';
        }

        async function withBusy(btn, busyText, fn) {
            if (!btn) return fn();
            const prevText = btn.textContent;
            const prevDisabled = btn.disabled;
            btn.disabled = true;
            if (busyText) btn.textContent = busyText;
            try { return await fn(); }
            finally {
                btn.disabled = prevDisabled;
                btn.textContent = prevText;
            }
        }

        function initCollapsibles() {
            const sections = Array.from(document.querySelectorAll('.section'));
            for (const sec of sections) {
                if (sec.id === 'deviceSection') continue;
                if (sec.dataset.collapsibleInit === '1') continue;

                const h2 = sec.querySelector('h2');
                if (!h2) continue;

                const head = document.createElement('div');
                head.className = 'section-head';

                const body = document.createElement('div');
                body.className = 'section-body';

                const title = (h2.textContent || '').trim() || 'section';
                const key = `ui:collapsed:${title}`;

                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = 'collapse-btn';
                const applyState = (collapsed) => {
                    sec.classList.toggle('collapsed', !!collapsed);
                    btn.textContent = collapsed ? 'Mostrar' : 'Ocultar';
                    try { localStorage.setItem(key, collapsed ? '1' : '0'); } catch {}
                    // Al mostrar/ocultar zonas, reconstruimos mini-gráficas de plantas visibles
                    try { scheduleZoneChartsRebuild(); } catch {}
                };

                const stored = (() => {
                    try { return localStorage.getItem(key); } catch { return null; }
                })();
                const initialCollapsed = stored === '1';
                applyState(initialCollapsed);

                btn.addEventListener('click', () => applyState(!sec.classList.contains('collapsed')));

                // Reestructurar DOM: h2 + botón en head; el resto dentro de body
                head.appendChild(h2);
                head.appendChild(btn);

                const toMove = [];
                for (const child of Array.from(sec.childNodes)) {
                    if (child === h2) continue;
                    if (child.nodeType === 3 && String(child.textContent || '').trim() === '') continue;
                    toMove.push(child);
                }
                for (const n of toMove) body.appendChild(n);

                sec.appendChild(head);
                sec.appendChild(body);
                sec.dataset.collapsibleInit = '1';
            }
        }

        function getMadridParts(date) {
            const parts = new Intl.DateTimeFormat('sv-SE', {
                timeZone: TZ,
                year: 'numeric', month: '2-digit', day: '2-digit',
                hour: '2-digit', minute: '2-digit',
                hourCycle: 'h23'
            }).formatToParts(date);
            const m = Object.fromEntries(parts.map(p => [p.type, p.value]));
            return { y: m.year, mo: m.month, d: m.day, h: m.hour, mi: m.minute };
        }

        function getMadridPartsFull(date) {
            const parts = new Intl.DateTimeFormat('sv-SE', {
                timeZone: TZ,
                year: 'numeric', month: '2-digit', day: '2-digit',
                hour: '2-digit', minute: '2-digit', second: '2-digit',
                hourCycle: 'h23'
            }).formatToParts(date);
            const m = Object.fromEntries(parts.map(p => [p.type, p.value]));
            return { y: m.year, mo: m.month, d: m.day, h: m.hour, mi: m.minute, s: m.second };
        }

        function parseTsToDate(ts) {
            if (ts == null) return null;
            if (ts instanceof Date) return ts;
            if (typeof ts === 'number') {
                // Heurística: si viene en segundos (muy pequeño), convertir a ms
                const ms = ts < 1e12 ? ts * 1000 : ts;
                const d = new Date(ms);
                return Number.isNaN(d.getTime()) ? null : d;
            }
            const d = new Date(String(ts));
            return Number.isNaN(d.getTime()) ? null : d;
        }
        function pad2(n) { return String(n).padStart(2, '0'); }
        function formatUptimeSeconds(sec) {
            const n = Number(sec);
            if (!Number.isFinite(n) || n < 0) return '--';
            return formatDuration(n * 1000);
        }
        function formatDuration(ms) {
            const s = Math.floor(ms / 1000);
            const hh = Math.floor(s / 3600);
            const mm = Math.floor((s % 3600) / 60);
            const ss = s % 60;
            if (hh > 0) return `${hh}h ${pad2(mm)}m ${pad2(ss)}s`;
            if (mm > 0) return `${mm}m ${pad2(ss)}s`;
            return `${ss}s`;
        }

        function formatIntervalSeconds(sec) {
            const n = Number(sec);
            if (!Number.isFinite(n) || n <= 0) return '--';
            // Mostrar compacto: segundos si < 90s, si no duración
            if (n < 90) return `${Math.round(n)}s`;
            return formatDuration(n * 1000);
        }

        function escapeHtml(s) {
            return String(s ?? '').replace(/[&<>"']/g, (c) => ({
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#39;'
            }[c]));
        }

        function setChips(el, chips) {
            if (!el) return;
            const arr = Array.isArray(chips) ? chips.filter(Boolean) : [];
            if (arr.length === 0) {
                el.innerHTML = '';
                return;
            }
            el.innerHTML = arr.map(c => {
                const variant = c.variant ? ` chip-${escapeHtml(c.variant)}` : '';
                const title = c.title ? ` title="${escapeHtml(c.title)}"` : '';
                const k = c.k == null ? '' : `<span class="k">${escapeHtml(c.k)}</span>`;
                const v = c.v == null ? '' : `<span class="v">${escapeHtml(c.v)}</span>`;
                return `<span class="chip${variant}"${title}>${k}${v}</span>`;
            }).join('');
        }

        function setMetricStateById(valueId, state, title) {
            const valueEl = document.getElementById(valueId);
            const card = valueEl ? valueEl.closest('.sensor-card') : null;
            if (!card) return;
            card.classList.remove('metric-good', 'metric-warn', 'metric-bad', 'metric-neutral');
            card.classList.add(state);
            if (title) card.title = title;
        }

        function updateThresholdCard() {
            const el = document.getElementById('uptime');
            if (!el) return;
            const t = Number(config.threshold);
            el.textContent = Number.isFinite(t) ? String(Math.round(t)) : '--';
            // Colorear el valor del umbral para que destaque
            // (bajo = verde, medio = amarillo, alto = rojo)
            if (!Number.isFinite(t)) {
                setMetricStateById('uptime', 'metric-neutral', 'Umbral de humedad baja configurado');
            } else if (t <= 30) {
                setMetricStateById('uptime', 'metric-good', 'Umbral bajo');
            } else if (t <= 50) {
                setMetricStateById('uptime', 'metric-warn', 'Umbral medio');
            } else {
                setMetricStateById('uptime', 'metric-bad', 'Umbral alto');
            }
        }

        function updateConnectedDeviceCards(data) {
            const createdAt = parseTsToDate(data?.created_at);
            const createdAtLabel = (data && data.created_at_madrid)
                ? String(data.created_at_madrid)
                : (createdAt ? createdAt.toLocaleString('es-ES', { timeZone: TZ, hour12: false }) : '--');

            // OLED meta (chips compactos, sin texto repetido)
            const oledMeta = document.getElementById('oledMeta');
            const createdMs = createdAt ? createdAt.getTime() : null;
            let deltaSec = null;
            if (createdMs != null && lastSampleMsForInterval != null) {
                const d = (createdMs - lastSampleMsForInterval) / 1000;
                // Ignorar valores raros (p.ej. reloj cambiado / lecturas duplicadas)
                if (Number.isFinite(d) && d > 0.5 && d < 3600) deltaSec = d;
            }
            if (createdMs != null) lastSampleMsForInterval = createdMs;

            const pLast = createdAt ? getMadridPartsFull(createdAt) : null;
            const lastTimeTxt = pLast ? `${pLast.h}:${pLast.mi}:${pLast.s}` : '--';
            const nowTxt = fmtNowEs.format(nowAdjusted());
            setChips(oledMeta, [
                { k: 'Δ', v: (deltaSec == null ? '--' : formatIntervalSeconds(deltaSec)), variant: (deltaSec != null && deltaSec <= 90) ? 'ok' : 'neutral', title: 'Tiempo entre lecturas (aprox.)' },
                { k: 'Últ', v: lastTimeTxt, variant: (createdAtLabel === '--') ? 'neutral' : 'ok', title: createdAtLabel === '--' ? '' : createdAtLabel },
                { k: 'Now', v: String(nowTxt).slice(-8), variant: 'neutral' },
            ]);

            const uptimeEl = document.getElementById('uptime');

            // Sensores/válvulas activos (dato reciente) según /api/channels/:device_code/latest
            try {
                const ch = Array.isArray(lastChannelsLatestPayload?.channels) ? lastChannelsLatestPayload.channels : [];
                let soilTotal = 0;
                let valveTotal = 0;
                for (const c of ch) {
                    const kind = String(c?.kind || '');
                    if (kind === 'soil_sensor') {
                        soilTotal++;
                    }
                    if (kind === 'valve') {
                        valveTotal++;
                    }
                }

                if (uptimeEl) {
                    const sTxt = `${soilTotal} ${soilTotal === 1 ? 'sensor' : 'sensores'}`;
                    const vTxt = `${valveTotal} ${valveTotal === 1 ? 'válvula' : 'válvulas'}`;
                    uptimeEl.textContent = `${sTxt}\n${vTxt}`;
                }
                const uptimeMeta = document.getElementById('uptimeMeta');
                setChips(uptimeMeta, []);
            } catch {
                if (uptimeEl) uptimeEl.textContent = '--';
                const uptimeMeta = document.getElementById('uptimeMeta');
                setChips(uptimeMeta, []);
            }

            const ipEl = document.getElementById('ip');
            if (ipEl) {
                const ip = (data && data.ip != null) ? String(data.ip).trim() : '';
                ipEl.textContent = ip || '--';
            }

            const ipMeta = document.getElementById('ipMeta');
            setChips(ipMeta, [
                { k: 'Red', v: 'LAN', variant: 'neutral' },
                { k: 'OK', v: (ipEl && ipEl.textContent && ipEl.textContent !== '--') ? 'sí' : '—', variant: (ipEl && ipEl.textContent && ipEl.textContent !== '--') ? 'ok' : 'neutral' },
            ]);

            const heapEl = document.getElementById('heap');
            if (heapEl) {
                const hb = (data?.heap_free == null ? null : Number(data.heap_free));
                const kb = (hb == null || Number.isNaN(hb)) ? null : Math.max(0, Math.round(hb / 1024));
                heapEl.textContent = kb == null ? '--' : String(kb);
            }

            const heapMeta = document.getElementById('heapMeta');
            setChips(heapMeta, [
                { k: 'Unidad', v: 'KB', variant: 'neutral' },
                { k: 'Libre', v: (heapEl && heapEl.textContent) ? heapEl.textContent : '--', variant: 'neutral' },
            ]);

            // WiFi: SSID + RSSI
            {
                const ssidRaw = (data && (data.wifi_ssid != null ? data.wifi_ssid : (data.ssid != null ? data.ssid : null)));
                const ssid = ssidRaw == null ? '' : String(ssidRaw).trim();
                const rssi = (data?.wifi_rssi == null ? null : Number(data.wifi_rssi));
                const rssiOk = !(rssi == null || Number.isNaN(rssi) || rssi === 0);
                const rssiEl = document.getElementById('rssi');
                const wifiConnected = !!ssid || rssiOk;
                if (rssiEl) {
                    // Mostrar el SSID grande (lo que el usuario quiere ver)
                    rssiEl.textContent = ssid ? ssid : (rssiOk ? `${Math.trunc(rssi)} dBm` : 'SIN WIFI');
                    // Evitar que una red larga rompa layout
                    rssiEl.style.wordBreak = 'break-word';
                }
                const wifiMeta = document.getElementById('wifiMeta');
                const rssiTxt = rssiOk ? `${Math.trunc(rssi)} dBm` : '-- dBm';
                const rssiVariant = !rssiOk ? 'neutral' : (rssi >= -60 ? 'ok' : (rssi >= -75 ? 'warn' : 'bad'));
                setChips(wifiMeta, [
                    { k: 'RSSI', v: rssiTxt, variant: rssiVariant },
                    { k: 'Estado', v: wifiConnected ? 'OK' : 'NO', variant: wifiConnected ? 'ok' : 'bad' },
                ]);
            }

            // Pantalla OLED (aprox: como OLED para PLANTA 1)
            try {
                const panel = document.getElementById('oledPanel');
                if (panel) {
                    const z0 = zonesState && zonesState[0] ? zonesState[0] : null;
                    const soilIdx = (z0 && z0.soil_channel_index != null) ? Number(z0.soil_channel_index) : 1;
                    const valveIdx = (z0 && z0.valve_channel_index != null) ? Number(z0.valve_channel_index) : 1;
                    const thr = (z0 && z0.humidity_low_threshold != null) ? Number(z0.humidity_low_threshold) : null;

                    const ch = Array.isArray(lastChannelsLatestPayload?.channels) ? lastChannelsLatestPayload.channels : [];
                    const byKey = new Map();
                    for (const c of ch) {
                        const kind = String(c?.kind || '');
                        const idx = Number(c?.channel_index);
                        if (!kind || !Number.isFinite(idx)) continue;
                        byKey.set(`${kind}:${idx}`, c?.latest || null);
                    }

                    const soilLatest = byKey.get(`soil_sensor:${soilIdx}`) || null;
                    const valveLatest = byKey.get(`valve:${valveIdx}`) || null;

                    const hum = soilLatest?.value == null ? null : Number(soilLatest.value);
                    const humTxt = Number.isFinite(hum) ? `${hum.toFixed(1)}%` : '--%';
                    const thrTxt = Number.isFinite(thr) ? `${Math.round(thr)}%` : '--%';

                    const st = valveLatest?.state == null ? null : Number(valveLatest.state);
                    const valveTxt = (st == null || Number.isNaN(st)) ? '--' : (st >= 1 ? 'ON' : 'OFF');

                    const v = (data?.voltage == null ? null : Number(data.voltage));
                    const vTxt = (v == null || Number.isNaN(v)) ? '--.-V' : `${v.toFixed(2)}V`;
                    const rssi = (data?.wifi_rssi == null ? null : Number(data.wifi_rssi));
                    const rssiTxt = (rssi == null || Number.isNaN(rssi) || rssi === 0) ? '--dBm' : `${Math.trunc(rssi)}dBm`;
                    const ssidRaw = (data && (data.wifi_ssid != null ? data.wifi_ssid : (data.ssid != null ? data.ssid : null)));
                    const ssid = ssidRaw == null ? '' : String(ssidRaw).trim();

                    const now = nowAdjusted();
                    const p = getMadridPartsFull(now);
                    const timeTxt = `${p.h}:${p.mi}:${p.s}`;
                    const ip = (data && data.ip != null) ? String(data.ip).trim() : '';

                    const ssidShort = ssid ? ssid.slice(0, 10) : '';
                    const ipShort = ip ? ip : '';
                    panel.innerHTML =
                        `<span class="oled-k">OLED</span> <span class="oled-v">${escapeHtml(timeTxt)}</span><br>` +
                        `<span class="oled-k">PL1</span> <span class="oled-k">HUM</span> <span class="oled-v oled-v-hum">${escapeHtml(humTxt)}</span>  <span class="oled-k">UMBRAL</span> <span class="oled-v oled-v-thr">${escapeHtml(thrTxt)}</span><br>` +
                        `<span class="oled-k">VAL</span> <span class="oled-v oled-v-valve">${escapeHtml(valveTxt)}</span>   <span class="oled-k">V</span> <span class="oled-v oled-v-v">${escapeHtml(vTxt)}</span><br>` +
                        `<span class="oled-k">WiFi</span> <span class="oled-v oled-v-wifi">${escapeHtml(rssiTxt)}${ssidShort ? ` ${escapeHtml(ssidShort)}` : ''}</span>${ipShort ? `  <span class="oled-k">IP</span> <span class="oled-v oled-v-ip">${escapeHtml(ipShort)}</span>` : ''}`;
                }
            } catch {
                const panel = document.getElementById('oledPanel');
                if (panel) panel.textContent = '--';
            }
        }

        // --- Persistencia ("datos que va recibiendo") ---
        const STORE_KEY = 'riego_stats_v1';
        function loadStore() {
            try {
                const raw = localStorage.getItem(STORE_KEY);
                if (!raw) return { minutes: {}, days: {}, months: {}, last: null };
                const obj = JSON.parse(raw);
                return {
                    minutes: obj.minutes || {},
                    days: obj.days || {},
                    months: obj.months || {},
                    last: obj.last || null
                };
            } catch {
                return { minutes: {}, days: {}, months: {}, last: null };
            }
        }
        function saveStore(store) {
            localStorage.setItem(STORE_KEY, JSON.stringify(store));
        }
        function ensureBucket(map, key) {
            if (!map[key]) map[key] = { humSum: 0, humCount: 0, valveOnMs: 0 };
            return map[key];
        }
        function pruneStore(store) {
            const dayKeys = Object.keys(store.days).sort();
            if (dayKeys.length > 370) {
                for (let i = 0; i < dayKeys.length - 370; i++) delete store.days[dayKeys[i]];
            }
            const monthKeys = Object.keys(store.months).sort();
            if (monthKeys.length > 36) {
                for (let i = 0; i < monthKeys.length - 36; i++) delete store.months[monthKeys[i]];
            }
            // minutes: mantener últimos 2 días (según keys de days)
            const keepDays = new Set(dayKeys.slice(-2));
            const minuteKeys = Object.keys(store.minutes);
            for (const mk of minuteKeys) {
                const dayPart = mk.slice(0, 10);
                if (!keepDays.has(dayPart)) delete store.minutes[mk];
            }
        }
        function ingestSample(store, sampleMs, humidity, valveIsOn) {
            const now = new Date(sampleMs);
            const p = getMadridParts(now);
            const dayKey = `${p.y}-${p.mo}-${p.d}`;
            const monthKey = `${p.y}-${p.mo}`;
            const minuteKey = `${dayKey}T${p.h}:${p.mi}`;

            // Tiempo ON entre muestras (usamos el estado anterior)
            let dt = 0;
            if (store.last && typeof store.last.t === 'number') {
                dt = Math.max(0, sampleMs - store.last.t);
            }
            const prevOn = store.last ? !!store.last.on : false;
            const onMs = prevOn ? dt : 0;

            const bMin = ensureBucket(store.minutes, minuteKey);
            const bDay = ensureBucket(store.days, dayKey);
            const bMonth = ensureBucket(store.months, monthKey);

            bMin.valveOnMs += onMs;
            bDay.valveOnMs += onMs;
            bMonth.valveOnMs += onMs;

            if (!Number.isNaN(humidity)) {
                bMin.humSum += humidity; bMin.humCount += 1;
                bDay.humSum += humidity; bDay.humCount += 1;
                bMonth.humSum += humidity; bMonth.humCount += 1;
            }

            store.last = { t: sampleMs, on: !!valveIsOn };
            pruneStore(store);
            saveStore(store);
        }

        // --- Modo de visualización ---
        let viewMode = 'day'; // day | month | year
        function setActiveModeButtons(mode) {
            document.getElementById('btnDia').classList.toggle('active', mode === 'day');
            document.getElementById('btnMes').classList.toggle('active', mode === 'month');
            document.getElementById('btnAno').classList.toggle('active', mode === 'year');
        }
        setActiveModeButtons(viewMode);

        document.getElementById('btnDia').addEventListener('click', () => { viewMode = 'day'; setActiveModeButtons(viewMode); rebuildCharts(); });
        document.getElementById('btnMes').addEventListener('click', () => { viewMode = 'month'; setActiveModeButtons(viewMode); rebuildCharts(); });
        document.getElementById('btnAno').addEventListener('click', () => { viewMode = 'year'; setActiveModeButtons(viewMode); rebuildCharts(); });

        // --- Datos para Chart.js ---
        const humLabels = [];
        const humSeries = [];
        const valveLabels = [];
        const valveSeries = [];
        function setSeries(labels, series, newLabels, newSeries) {
            labels.length = 0;
            series.length = 0;
            for (const x of newLabels) labels.push(x);
            for (const y of newSeries) series.push(y);
        }

        const humChart = new Chart(document.getElementById('humChart'), {
            type: 'line',
            data: {
                labels: humLabels,
                datasets: [{
                    label: 'Humedad (%)',
                    data: humSeries,
                    borderColor: '#22c55e',
                    backgroundColor: 'rgba(34, 197, 94, 0.15)',
                    fill: true,
                    tension: 0.25,
                    pointRadius: 0
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                plugins: { legend: { display: false } },
                scales: {
                    y: {
                        min: 0,
                        max: 100,
                        ticks: {
                            color: '#aaa',
                            stepSize: 5,
                            callback: (v) => `${v}%`
                        },
                        grid: { color: 'rgba(255,255,255,0.06)' }
                    },
                    x: { ticks: { color: '#888', maxTicksLimit: 6 }, grid: { color: 'rgba(255,255,255,0.04)' } }
                }
            }
        });

        const valveChart = new Chart(document.getElementById('valveChart'), {
            type: 'line',
            data: {
                labels: valveLabels,
                datasets: [{
                    label: 'Válvula (0/1)',
                    data: valveSeries,
                    borderColor: '#fb7185',
                    backgroundColor: 'rgba(251, 113, 133, 0.12)',
                    fill: true,
                    stepped: true,
                    tension: 0,
                    pointRadius: 0
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                plugins: { legend: { display: false } },
                scales: {
                    y: {
                        min: 0,
                        max: 1,
                        ticks: {
                            color: '#aaa',
                            stepSize: 1,
                            callback: (v) => (v >= 0.5 ? 'ON' : 'OFF')
                        },
                        grid: { color: 'rgba(255,255,255,0.06)' }
                    },
                    x: { ticks: { color: '#888', maxTicksLimit: 6 }, grid: { color: 'rgba(255,255,255,0.04)' } }
                }
            }
        });

        // --- Mini charts por planta (RAW 24h, tiempo real) ---
        const zoneMiniCharts = new Map();

        function destroyZoneMiniCharts() {
            for (const v of zoneMiniCharts.values()) {
                try { v.chart?.destroy(); } catch {}
            }
            zoneMiniCharts.clear();
        }

        function getChannelIdByKindIndex(kind, idx) {
            const n = Number(idx);
            if (!kind || !Number.isFinite(n)) return null;
            const c = (channels || []).find(x => x && x.kind === kind && Number(x.channel_index) === n);
            return c ? c.id : null;
        }

        function miniLabelForDate(d) {
            const p = getMadridPartsFull(d);
            return `${p.h}:${p.mi}`;
        }

        function ensureMiniChart(canvasId, { stepped = false, yMin = undefined, yMax = undefined, yTickCb = undefined, yTickStep = undefined } = {}) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return null;
            if (zoneMiniCharts.has(canvasId)) return zoneMiniCharts.get(canvasId);

            const card = canvas.closest('.sensor-card');
            const cs = card ? getComputedStyle(card) : null;
            const accent = cs ? (cs.getPropertyValue('--accent').trim() || '#60a5fa') : '#60a5fa';
            const accentSoft = cs ? (cs.getPropertyValue('--accent-soft').trim() || 'rgba(96,165,250,0.14)') : 'rgba(96,165,250,0.14)';

            const labels = [];
            const series = [];
            const ts = [];

            const chart = new Chart(canvas, {
                type: 'line',
                data: {
                    labels,
                    datasets: [{
                        label: '',
                        data: series,
                        borderColor: accent,
                        backgroundColor: accentSoft,
                        fill: true,
                        stepped: !!stepped,
                        tension: stepped ? 0 : 0.25,
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    plugins: { legend: { display: false }, tooltip: { enabled: true } },
                    scales: {
                        y: {
                            min: yMin,
                            max: yMax,
                            ticks: {
                                color: '#aaa',
                                callback: yTickCb,
                                stepSize: yTickStep
                            },
                            grid: { color: 'rgba(255,255,255,0.06)' }
                        },
                        x: {
                            ticks: { color: '#888', maxTicksLimit: 4 },
                            grid: { color: 'rgba(255,255,255,0.04)' }
                        }
                    }
                }
            });

            const entry = { chart, labels, series, ts, lastTsMs: null };
            zoneMiniCharts.set(canvasId, entry);
            return entry;
        }

        async function loadMiniChartHistory(canvasId, channelId, { kind } = {}) {
            if (!channelId) return;
            // RAW: el backend ya limita a últimas 24h por defecto
            const url = `/api/channel/history/${encodeURIComponent(deviceCode)}/${encodeURIComponent(channelId)}?step=raw&limit=600`;
            const r = await fetch(url, { credentials: 'include' });
            if (!r.ok) return;
            const payload = await r.json().catch(() => null);
            const rows = Array.isArray(payload?.rows) ? payload.rows : [];

            const entry = zoneMiniCharts.get(canvasId);
            if (!entry) return;

            const labels = [];
            const series = [];
            const tsArr = [];
            let lastTsMs = null;

            for (const row of rows) {
                const d = parseTsToDate(row?.ts);
                if (!d) continue;
                const tsMs = d.getTime();
                lastTsMs = tsMs;
                tsArr.push(tsMs);
                labels.push(row?.ts_madrid_label || miniLabelForDate(d));
                if (kind === 'valve') {
                    const s = row?.state == null ? null : Number(row.state);
                    series.push(Number.isFinite(s) ? (s >= 1 ? 1 : 0) : null);
                } else {
                    const v = row?.value == null ? null : Number(row.value);
                    series.push(Number.isFinite(v) ? v : null);
                }
            }

            entry.labels.length = 0;
            entry.series.length = 0;
            entry.ts.length = 0;
            for (const x of labels) entry.labels.push(x);
            for (const y of series) entry.series.push(y);
            for (const t of tsArr) entry.ts.push(t);
            entry.lastTsMs = lastTsMs;
            entry.chart.update('none');

            try {
                const m = String(canvasId).match(/^zone(Hum|Valve)Chart(\d+)$/);
                if (m) updateZoneSummary(Number(m[2]));
            } catch {}
        }

        function ingestMiniChartPoint(canvasId, latest, { kind } = {}) {
            const entry = zoneMiniCharts.get(canvasId);
            if (!entry) return;
            const d = parseTsToDate(latest?.ts || latest?.ts_raw || latest?.ts_madrid);
            if (!d) return;
            const tsMs = d.getTime();
            if (entry.lastTsMs != null && tsMs <= entry.lastTsMs) return;

            const val = (kind === 'valve')
                ? (latest?.state == null ? null : (Number(latest.state) >= 1 ? 1 : 0))
                : (latest?.value == null ? null : Number(latest.value));

            entry.labels.push(miniLabelForDate(d));
            entry.series.push((val == null || !Number.isFinite(val)) ? null : val);
            entry.ts.push(tsMs);
            entry.lastTsMs = tsMs;

            const MAX_POINTS = 600;
            if (entry.labels.length > MAX_POINTS) {
                entry.labels.splice(0, entry.labels.length - MAX_POINTS);
                entry.series.splice(0, entry.series.length - MAX_POINTS);
                entry.ts.splice(0, entry.ts.length - MAX_POINTS);
            }

            entry.chart.update('none');

            try {
                const m = String(canvasId).match(/^zone(Hum|Valve)Chart(\d+)$/);
                if (m) updateZoneSummary(Number(m[2]));
            } catch {}
        }

        async function rebuildZoneMiniCharts() {
            // Nota: renderZonesUI reconstruye el DOM, así que destruimos y recreamos.
            destroyZoneMiniCharts();
            if (!deviceCode) return;
            if (!Array.isArray(zonesState) || zonesState.length === 0) return;

            const defs = [
                { kind: 'soil_sensor', prop: 'soil_channel_index', canvas: (z) => `zoneHumChart${z}`, yMin: 0, yMax: 100, yTickStep: 5, yTickCb: (v) => `${v}%` },
                { kind: 'temperature_soil', prop: 'temperature_soil_channel_index', canvas: (z) => `zoneTSoilChart${z}` },
                { kind: 'temperature_air', prop: 'temperature_air_channel_index', canvas: (z) => `zoneTAirChart${z}` },
                { kind: 'humidity_air', prop: 'humidity_air_channel_index', canvas: (z) => `zoneHAirChart${z}`, yMin: 0, yMax: 100, yTickStep: 5, yTickCb: (v) => `${v}%` },
                { kind: 'ph_soil', prop: 'ph_soil_channel_index', canvas: (z) => `zonePHChart${z}`, yMin: 0, yMax: 14 },
                { kind: 'ec_soil', prop: 'ec_soil_channel_index', canvas: (z) => `zoneECChart${z}` },
                { kind: 'valve', prop: 'valve_channel_index', canvas: (z) => `zoneValveChart${z}`, stepped: true, yMin: 0, yMax: 1, yTickStep: 1, yTickCb: (v) => (Number(v) >= 0.5 ? 'ON' : 'OFF') }
            ];

            for (let i = 0; i < 8; i++) {
                const zoneNum = i + 1;
                const sec = document.getElementById(`zoneSec${zoneNum}`);
                if (sec && sec.classList.contains('collapsed')) continue;
                const z = zonesState[i];
                if (!z) continue;

                for (const def of defs) {
                    const idx = z[def.prop];
                    if (idx == null) continue;
                    const channelId = getChannelIdByKindIndex(def.kind, idx);
                    if (!channelId) continue;

                    const canvasId = def.canvas(zoneNum);
                    ensureMiniChart(canvasId, { stepped: def.stepped, yMin: def.yMin, yMax: def.yMax, yTickCb: def.yTickCb, yTickStep: def.yTickStep });
                    await loadMiniChartHistory(canvasId, channelId, { kind: def.kind === 'valve' ? 'valve' : 'value' });
                }
            }
        }

        function formatLastPointText(mode, dateObj, fallbackLabel) {
            if (dateObj instanceof Date && !Number.isNaN(dateObj.getTime())) {
                const p = getMadridPartsFull(dateObj);
                if (mode === 'year') return `Mes ${p.mo}`;
                if (mode === 'month') return `Día ${p.d}`;
                return `Día ${p.d} ${p.h}:${p.mi}:${p.s}`;
            }
            const lbl = (fallbackLabel == null) ? '' : String(fallbackLabel);
            if (!lbl) return '--';
            if (mode === 'year') return `Mes ${lbl}`;
            if (mode === 'month') return `Día ${lbl}`;
            return lbl.startsWith('Día ') ? lbl : `Día ${lbl}`;
        }

        function updateZoneSummary(zoneNum) {
            const avgEl = document.getElementById(`zoneAvgHumidity${zoneNum}`);
            const lastEl = document.getElementById(`zoneLastPoint${zoneNum}`);
            const onEl = document.getElementById(`zoneTotalValveOn${zoneNum}`);
            if (!avgEl && !lastEl && !onEl) return;

            const humEntry = zoneMiniCharts.get(`zoneHumChart${zoneNum}`) || null;
            const valveEntry = zoneMiniCharts.get(`zoneValveChart${zoneNum}`) || null;

            // Humedad media
            if (avgEl) {
                let sum = 0;
                let cnt = 0;
                const arr = humEntry?.series || [];
                for (const v of arr) {
                    const n = Number(v);
                    if (!Number.isFinite(n)) continue;
                    sum += n;
                    cnt += 1;
                }
                avgEl.textContent = cnt ? `${(sum / cnt).toFixed(1)}%` : '--';
            }

            // Tiempo válvula ON (basado en deltas entre puntos)
            if (onEl) {
                let onMs = 0;
                const s = valveEntry?.series || [];
                const t = valveEntry?.ts || [];
                for (let i = 1; i < Math.min(s.length, t.length); i++) {
                    const dt = Math.max(0, Number(t[i]) - Number(t[i - 1]));
                    const prevOn = Number(s[i - 1]) >= 0.5;
                    if (prevOn) onMs += dt;
                }
                onEl.textContent = onMs ? formatDuration(onMs) : '--';
            }

            // Último punto: el más reciente entre humedad y válvula
            if (lastEl) {
                const humLast = humEntry?.lastTsMs != null ? Number(humEntry.lastTsMs) : null;
                const valveLast = valveEntry?.lastTsMs != null ? Number(valveEntry.lastTsMs) : null;
                const lastMs = (humLast != null && valveLast != null)
                    ? Math.max(humLast, valveLast)
                    : (humLast != null ? humLast : (valveLast != null ? valveLast : null));
                lastEl.textContent = lastMs != null ? formatLastPointText('day', new Date(lastMs)) : '--';
            }
        }

        function rebuildChartsFromStore(storeOpt) {
            const store = storeOpt || loadStore();
            const now = nowAdjusted();
            const p = getMadridParts(now);

            let labels = [];
            let hum = [];
            let valve = [];
            let totalHumSum = 0;
            let totalHumCount = 0;
            let totalValveOnMs = 0;

            if (viewMode === 'day') {
                document.getElementById('periodLabel').textContent = 'Día';
                document.getElementById('periodValue').textContent = `${fmtDateEs.format(now)} (últimas 24h)`;

                const entries = Object.entries(store.minutes).sort((a, b) => a[0].localeCompare(b[0]));
                const last = entries.slice(-1440); // 24h * 60
                for (const [k, v] of last) {
                    const avg = v.humCount ? (v.humSum / v.humCount) : null;
                    // Mostrar DD HH:mm para que al cambiar de día se note
                    labels.push(`${k.slice(8, 10)} ${k.slice(11)}`);
                    hum.push(avg === null ? null : Number(avg.toFixed(2)));
                    const duty = Math.max(0, Math.min(1, (v.valveOnMs || 0) / 60000));
                    valve.push(Number(duty.toFixed(2)));
                    totalHumSum += v.humSum || 0;
                    totalHumCount += v.humCount || 0;
                    totalValveOnMs += v.valveOnMs || 0;
                }

                valveChart.options.scales.y.min = 0;
                valveChart.options.scales.y.max = 1;
                valveChart.options.scales.y.ticks.callback = (v) => (v >= 0.5 ? 'ON' : 'OFF');
                valveChart.options.scales.y.ticks.stepSize = 1;
                valveChart.data.datasets[0].label = 'Válvula (duty 0..1)';

            } else if (viewMode === 'month') {
                const monthKey = `${p.y}-${p.mo}`;
                document.getElementById('periodLabel').textContent = 'Mes';
                document.getElementById('periodValue').textContent = `${p.mo}/${p.y}`;

                const entries = Object.entries(store.days)
                    .filter(([k]) => k.startsWith(monthKey + '-'))
                    .sort((a, b) => a[0].localeCompare(b[0]));

                for (const [k, v] of entries) {
                    const avg = v.humCount ? (v.humSum / v.humCount) : null;
                    labels.push(k.slice(8, 10));
                    hum.push(avg === null ? null : Number(avg.toFixed(2)));
                    valve.push(Number(((v.valveOnMs || 0) / 3600000).toFixed(2))); // horas
                    totalHumSum += v.humSum || 0;
                    totalHumCount += v.humCount || 0;
                    totalValveOnMs += v.valveOnMs || 0;
                }

                valveChart.options.scales.y.min = 0;
                valveChart.options.scales.y.max = undefined;
                valveChart.options.scales.y.ticks.callback = undefined;
                valveChart.options.scales.y.ticks.stepSize = undefined;
                valveChart.data.datasets[0].label = 'Válvula (horas ON/día)';

            } else {
                const yearKey = `${p.y}-`;
                document.getElementById('periodLabel').textContent = 'Año';
                document.getElementById('periodValue').textContent = `${p.y}`;

                const entries = Object.entries(store.months)
                    .filter(([k]) => k.startsWith(yearKey))
                    .sort((a, b) => a[0].localeCompare(b[0]));

                for (const [k, v] of entries) {
                    const avg = v.humCount ? (v.humSum / v.humCount) : null;
                    labels.push(k.slice(5, 7));
                    hum.push(avg === null ? null : Number(avg.toFixed(2)));
                    valve.push(Number(((v.valveOnMs || 0) / 3600000).toFixed(1))); // horas ON/mes
                    totalHumSum += v.humSum || 0;
                    totalHumCount += v.humCount || 0;
                    totalValveOnMs += v.valveOnMs || 0;
                }

                valveChart.options.scales.y.min = 0;
                valveChart.options.scales.y.max = undefined;
                valveChart.options.scales.y.ticks.callback = undefined;
                valveChart.options.scales.y.ticks.stepSize = undefined;
                valveChart.data.datasets[0].label = 'Válvula (horas ON/mes)';
            }

            const avgHum = totalHumCount ? (totalHumSum / totalHumCount) : null;
            document.getElementById('avgHumidity').textContent = avgHum === null ? '--' : `${avgHum.toFixed(1)}%`;
            document.getElementById('totalValveOn').textContent = totalValveOnMs ? formatDuration(totalValveOnMs) : '--';
            document.getElementById('valveOnTime').textContent = `Tiempo ON (periodo): ${totalValveOnMs ? formatDuration(totalValveOnMs) : '--'}`;

            const lastPointEl = document.getElementById('lastPoint');
            if (lastPointEl) {
                const lastDate = store.last && typeof store.last.t === 'number' ? new Date(store.last.t) : null;
                const fallback = labels.length ? String(labels[labels.length - 1]) : '';
                lastPointEl.textContent = formatLastPointText(viewMode, lastDate, fallback);
            }

            setSeries(humLabels, humSeries, labels, hum);
            setSeries(valveLabels, valveSeries, labels, valve);
            humChart.update('none');
            valveChart.update('none');

            const valveDotChart = document.getElementById('valveDotChart');
            const valveTextChart = document.getElementById('valveTextChart');
            if (store.last && store.last.on) {
                valveDotChart.className = 'valve-dot on';
                valveTextChart.textContent = 'ENCENDIDA';
            } else if (store.last) {
                valveDotChart.className = 'valve-dot off';
                valveTextChart.textContent = 'APAGADA';
            } else {
                valveDotChart.className = 'valve-dot';
                valveTextChart.textContent = 'SIN DATOS';
            }
        }

        function rangeForMode(mode) {
            const now = nowAdjusted();
            // DÍA: usar RAW para que se vea en tiempo real (segundos) y no “a saltos” por minuto.
            if (mode === 'day') return { from: null, to: null, step: 'raw', bucketMs: null };
            if (mode === 'month') return { from: new Date(now.getFullYear(), now.getMonth(), 1), to: now, step: '1h', bucketMs: 3600000 };
            return { from: new Date(now.getFullYear(), 0, 1), to: now, step: '1h', bucketMs: 3600000 }; // year
        }

        function dayKeyForTs(ts) {
            const p = getMadridParts(new Date(ts));
            return `${p.y}-${p.mo}-${p.d}`;
        }
        function monthKeyForTs(ts) {
            const p = getMadridParts(new Date(ts));
            return `${p.y}-${p.mo}`;
        }

        async function rebuildChartsFromServer() {
            // Para rendimiento: limitar puntos en DÍA (raw) y usar canales
            if (!humChannelId && !valveChannelId) throw new Error('no channels');

            const now = nowAdjusted();
            const range = rangeForMode(viewMode);
            let step;
            let limit;
            if (viewMode === 'day') { step = 'raw'; limit = 1500; }
            else if (viewMode === 'month') { step = '1h'; limit = 2000; }
            else { step = '1h'; limit = 4000; }

            const rangeQs = (range && range.from && range.to)
                ? `&from=${encodeURIComponent(range.from.toISOString())}&to=${encodeURIComponent(range.to.toISOString())}`
                : '';

            const baseHum = humChannelId ? `/api/channel/history/${encodeURIComponent(deviceCode)}/${encodeURIComponent(humChannelId)}?step=${encodeURIComponent(step)}&limit=${limit}${rangeQs}` : null;
            const baseValve = valveChannelId ? `/api/channel/history/${encodeURIComponent(deviceCode)}/${encodeURIComponent(valveChannelId)}?step=${encodeURIComponent(step)}&limit=${limit}${rangeQs}` : null;

            async function rebuildChartsFromSensorHistoryFallback() {
                // Fallback robusto: usar sensor_data (siempre existe aunque el dispositivo esté offline)
                const url = `/api/sensor/history/${encodeURIComponent(deviceCode)}?step=${encodeURIComponent(step)}&limit=${limit}${rangeQs}`;
                const r = await fetch(url);
                if (!r.ok) throw new Error('sensor history failed');
                const payload = await r.json();
                const rows = Array.isArray(payload.rows) ? payload.rows : [];

                // Convertir a “shape” parecido a channel history
                const humRows = rows
                    .filter(x => x && x.humidity != null)
                    .map(x => ({ ts: x.ts, ts_madrid: x.ts_madrid, ts_madrid_label: x.ts_madrid_label, ts_madrid_day_key: x.ts_madrid_day_key, ts_madrid_month_key: x.ts_madrid_month_key, value: x.humidity }));

                const valveRows = rows
                    .map(x => {
                        // raw: valve_state (string), bucket: valve_on (0/1)
                        const s = (x && x.valve_on != null) ? Number(x.valve_on) : null;
                        if (Number.isFinite(s)) return { ts: x.ts, ts_madrid: x.ts_madrid, ts_madrid_label: x.ts_madrid_label, ts_madrid_day_key: x.ts_madrid_day_key, ts_madrid_month_key: x.ts_madrid_month_key, state: s >= 1 ? 1 : 0 };
                        const vs = String(x?.valve_state || '').toUpperCase();
                        if (!vs) return { ts: x.ts, ts_madrid: x.ts_madrid, ts_madrid_label: x.ts_madrid_label, ts_madrid_day_key: x.ts_madrid_day_key, ts_madrid_month_key: x.ts_madrid_month_key, state: null };
                        const on = (vs === 'ON' || vs === '1' || vs === 'TRUE');
                        return { ts: x.ts, ts_madrid: x.ts_madrid, ts_madrid_label: x.ts_madrid_label, ts_madrid_day_key: x.ts_madrid_day_key, ts_madrid_month_key: x.ts_madrid_month_key, state: on ? 1 : 0 };
                    });

                // Reutilizar la misma lógica de pintado (como si viniera de channels)
                const fakeHumPayload = { rows: humRows, range: payload.range };
                const fakeValvePayload = { rows: valveRows, range: payload.range };

                // Copia mínima de las variables que usa el bloque de render
                const humRows2 = humRows;
                const valveRows2 = valveRows;

                let labels = [];
                let hum = [];
                let valve = [];
                let totalHumSum = 0;
                let totalHumCount = 0;
                let totalValveOnMs = 0;

                if (viewMode === 'day') {
                    document.getElementById('periodLabel').textContent = 'Día';
                    const rangeTo = parseTsToDate(fakeHumPayload?.range?.to || fakeValvePayload?.range?.to) || now;
                    document.getElementById('periodValue').textContent = `${fmtDateEs.format(rangeTo)} (últimas 24h, histórico)`;

                    const labelSource = humRows2.length ? humRows2 : valveRows2;
                    for (const r of labelSource) labels.push(r.ts_madrid_label || (r.ts_madrid || String(r.ts || '')));

                    for (const r of humRows2) {
                        const v = r.value == null ? null : Number(r.value);
                        hum.push(v == null || Number.isNaN(v) ? null : Number(v.toFixed(2)));
                        if (v != null && !Number.isNaN(v)) { totalHumSum += v; totalHumCount += 1; }
                    }

                    let prevT = null;
                    let prevOn = false;
                    for (const r of valveRows2) {
                        const d = parseTsToDate(r.ts);
                        const onNow = Number(r.state || 0) >= 1;
                        valve.push(onNow ? 1 : 0);
                        const t = d ? d.getTime() : null;
                        if (t != null && prevT != null) {
                            const dt = Math.max(0, t - prevT);
                            if (prevOn) totalValveOnMs += dt;
                        }
                        prevT = t;
                        prevOn = onNow;
                    }

                    while (hum.length < labels.length) hum.push(null);
                    while (valve.length < labels.length) valve.push(null);

                    valveChart.options.scales.y.min = 0;
                    valveChart.options.scales.y.max = 1;
                    valveChart.options.scales.y.ticks.callback = (v) => (v >= 0.5 ? 'ON' : 'OFF');
                    valveChart.options.scales.y.ticks.stepSize = 1;
                    valveChart.data.datasets[0].label = 'Válvula (0/1)';
                } else if (viewMode === 'month') {
                    const pNow = getMadridParts(nowAdjusted());
                    document.getElementById('periodLabel').textContent = 'Mes';
                    document.getElementById('periodValue').textContent = `${pNow.mo}/${pNow.y}`;

                    const byDayHum = {};
                    for (const r of humRows2) {
                        const k = r.ts_madrid_day_key || dayKeyForTs(r.ts);
                        const b = byDayHum[k] || (byDayHum[k] = { sum: 0, cnt: 0 });
                        const v = r.value == null ? null : Number(r.value);
                        if (v != null && !Number.isNaN(v)) { b.sum += v; b.cnt += 1; }
                    }
                    const byDayValve = {};
                    for (const r of valveRows2) {
                        const k = r.ts_madrid_day_key || dayKeyForTs(r.ts);
                        const b = byDayValve[k] || (byDayValve[k] = { on: 0, cnt: 0 });
                        const s = Number(r.state || 0) >= 1 ? 1 : 0;
                        b.on += s;
                        b.cnt += 1;
                    }
                    const keys = Array.from(new Set([...Object.keys(byDayHum), ...Object.keys(byDayValve)])).sort();
                    for (const k of keys) {
                        labels.push(k.slice(8, 10));
                        const hB = byDayHum[k];
                        const vB = byDayValve[k];
                        const avg = hB && hB.cnt ? (hB.sum / hB.cnt) : null;
                        hum.push(avg == null ? null : Number(avg.toFixed(2)));
                        const onHours = vB && vB.cnt ? (vB.on / vB.cnt) * 24 : 0;
                        valve.push(Number(onHours.toFixed(2)));
                        if (hB) { totalHumSum += hB.sum; totalHumCount += hB.cnt; }
                        if (vB) { totalValveOnMs += (vB.cnt ? (vB.on / vB.cnt) * 24 * 3600000 : 0); }
                    }

                    valveChart.options.scales.y.min = 0;
                    valveChart.options.scales.y.max = undefined;
                    valveChart.options.scales.y.ticks.callback = undefined;
                    valveChart.options.scales.y.ticks.stepSize = undefined;
                    valveChart.data.datasets[0].label = 'Válvula (horas ON/día)';
                } else {
                    const pNow = getMadridParts(nowAdjusted());
                    document.getElementById('periodLabel').textContent = 'Año';
                    document.getElementById('periodValue').textContent = `${pNow.y}`;

                    const byMonthHum = {};
                    for (const r of humRows2) {
                        const k = r.ts_madrid_month_key || monthKeyForTs(r.ts);
                        const b = byMonthHum[k] || (byMonthHum[k] = { sum: 0, cnt: 0 });
                        const v = r.value == null ? null : Number(r.value);
                        if (v != null && !Number.isNaN(v)) { b.sum += v; b.cnt += 1; }
                    }
                    const byMonthValve = {};
                    for (const r of valveRows2) {
                        const k = r.ts_madrid_month_key || monthKeyForTs(r.ts);
                        const b = byMonthValve[k] || (byMonthValve[k] = { on: 0, cnt: 0 });
                        const s = Number(r.state || 0) >= 1 ? 1 : 0;
                        b.on += s;
                        b.cnt += 1;
                    }
                    const keys = Array.from(new Set([...Object.keys(byMonthHum), ...Object.keys(byMonthValve)])).sort();
                    for (const k of keys) {
                        labels.push(k.slice(5, 7));
                        const hB = byMonthHum[k];
                        const vB = byMonthValve[k];
                        const avg = hB && hB.cnt ? (hB.sum / hB.cnt) : null;
                        hum.push(avg == null ? null : Number(avg.toFixed(2)));
                        const onHours = vB && vB.cnt ? (vB.on / vB.cnt) * (30 * 24) : 0;
                        valve.push(Number(onHours.toFixed(1)));
                        if (hB) { totalHumSum += hB.sum; totalHumCount += hB.cnt; }
                        if (vB) { totalValveOnMs += (vB.cnt ? (vB.on / vB.cnt) * (30 * 24) * 3600000 : 0); }
                    }

                    valveChart.options.scales.y.min = 0;
                    valveChart.options.scales.y.max = undefined;
                    valveChart.options.scales.y.ticks.callback = undefined;
                    valveChart.options.scales.y.ticks.stepSize = undefined;
                    valveChart.data.datasets[0].label = 'Válvula (horas ON/mes)';
                }

                const avgHum = totalHumCount ? (totalHumSum / totalHumCount) : null;
                document.getElementById('avgHumidity').textContent = avgHum === null ? '--' : `${avgHum.toFixed(1)}%`;
                document.getElementById('totalValveOn').textContent = totalValveOnMs ? formatDuration(totalValveOnMs) : '--';
                document.getElementById('valveOnTime').textContent = `Tiempo ON (periodo): ${totalValveOnMs ? formatDuration(totalValveOnMs) : '--'}`;

                const lastPointEl = document.getElementById('lastPoint');
                if (lastPointEl) {
                    const lastLabel = labels.length ? String(labels[labels.length - 1]) : '';
                    let lastDate = null;
                    if (viewMode === 'day') {
                        const lastRow = humRows2.length ? humRows2[humRows2.length - 1] : (valveRows2.length ? valveRows2[valveRows2.length - 1] : null);
                        const d = lastRow ? parseTsToDate(lastRow.ts) : null;
                        lastDate = d || null;
                    }
                    lastPointEl.textContent = formatLastPointText(viewMode, lastDate, lastLabel);
                }

                setSeries(humLabels, humSeries, labels, hum);
                setSeries(valveLabels, valveSeries, labels, valve);
                humChart.update('none');
                valveChart.update('none');
            }

            const [humRes, valveRes] = await Promise.all([
                baseHum ? fetch(baseHum) : Promise.resolve(null),
                baseValve ? fetch(baseValve) : Promise.resolve(null)
            ]);

            if (baseHum && (!humRes || !humRes.ok)) return rebuildChartsFromSensorHistoryFallback();
            if (baseValve && (!valveRes || !valveRes.ok)) return rebuildChartsFromSensorHistoryFallback();

            const humPayload = humRes ? await humRes.json() : { rows: [] };
            const valvePayload = valveRes ? await valveRes.json() : { rows: [] };

            const humRows = Array.isArray(humPayload.rows) ? humPayload.rows : [];
            const valveRows = Array.isArray(valvePayload.rows) ? valvePayload.rows : [];

            // Si el backend no está rellenando channel_samples (o están desfasados),
            // la gráfica puede quedarse “clavada” en un timestamp antiguo.
            // En ese caso, usamos el store local (alimentado por /api/sensor/latest).
            {
                const lastRow = humRows.length ? humRows[humRows.length - 1] : (valveRows.length ? valveRows[valveRows.length - 1] : null);
                const lastTs = lastRow ? parseTsToDate(lastRow.ts) : null;
                const ageMs = lastTs ? (now.getTime() - lastTs.getTime()) : Infinity;
                // Si el último punto es muy viejo o no existe, usar histórico de sensor_data.
                if (!lastTs || !Number.isFinite(ageMs) || ageMs > 10 * 60000) {
                    return rebuildChartsFromSensorHistoryFallback();
                }
            }

            let labels = [];
            let hum = [];
            let valve = [];
            let totalHumSum = 0;
            let totalHumCount = 0;
            let totalValveOnMs = 0;

            if (viewMode === 'day') {
                document.getElementById('periodLabel').textContent = 'Día';
                const rangeTo = parseTsToDate(humPayload?.range?.to || valvePayload?.range?.to) || now;
                document.getElementById('periodValue').textContent = `${fmtDateEs.format(rangeTo)} (últimas 24h, tiempo real)`;

                // Unificar labels por timestamp: usamos los del sensor si existen, si no los de válvula.
                const labelSource = humRows.length ? humRows : valveRows;
                for (const r of labelSource) {
                    labels.push(r.ts_madrid_label || (r.ts_madrid || String(r.ts || '')));
                }

                // Serie humedad
                for (const r of humRows) {
                    const v = r.value == null ? null : Number(r.value);
                    hum.push(v == null || Number.isNaN(v) ? null : Number(v.toFixed(2)));
                    if (v != null && !Number.isNaN(v)) { totalHumSum += v; totalHumCount += 1; }
                }

                // Serie válvula + tiempo ON
                let prevT = null;
                let prevOn = false;
                for (const r of valveRows) {
                    const d = parseTsToDate(r.ts);
                    const onNow = Number(r.state || 0) >= 1;
                    valve.push(onNow ? 1 : 0);
                    const t = d ? d.getTime() : null;
                    if (t != null && prevT != null) {
                        const dt = Math.max(0, t - prevT);
                        if (prevOn) totalValveOnMs += dt;
                    }
                    prevT = t;
                    prevOn = onNow;
                }

                // Alinear longitudes (Chart.js agradece arrays consistentes)
                while (hum.length < labels.length) hum.push(null);
                while (valve.length < labels.length) valve.push(null);

                // Estado actual en tarjeta de la gráfica según el último valor del canal
                const valveDotChart = document.getElementById('valveDotChart');
                const valveTextChart = document.getElementById('valveTextChart');
                const lastV = valveRows.length ? valveRows[valveRows.length - 1] : null;
                if (lastV && Number(lastV.state || 0) >= 1) {
                    valveDotChart.className = 'valve-dot on';
                    valveTextChart.textContent = 'ENCENDIDA';
                } else if (lastV) {
                    valveDotChart.className = 'valve-dot off';
                    valveTextChart.textContent = 'APAGADA';
                } else {
                    valveDotChart.className = 'valve-dot';
                    valveTextChart.textContent = 'SIN DATOS';
                }

                valveChart.options.scales.y.min = 0;
                valveChart.options.scales.y.max = 1;
                valveChart.options.scales.y.ticks.callback = (v) => (v >= 0.5 ? 'ON' : 'OFF');
                valveChart.options.scales.y.ticks.stepSize = 1;
                valveChart.data.datasets[0].label = 'Válvula (0/1)';

            } else if (viewMode === 'month') {
                const pNow = getMadridParts(nowAdjusted());
                document.getElementById('periodLabel').textContent = 'Mes';
                document.getElementById('periodValue').textContent = `${pNow.mo}/${pNow.y}`;

                // En month/year, backend ya devuelve buckets por hora; agrupamos a días aquí (usando claves Madrid del backend)
                const byDayHum = {};
                for (const r of humRows) {
                    const k = r.ts_madrid_day_key || dayKeyForTs(r.ts);
                    const b = byDayHum[k] || (byDayHum[k] = { sum: 0, cnt: 0 });
                    const v = r.value == null ? null : Number(r.value);
                    if (v != null && !Number.isNaN(v)) { b.sum += v; b.cnt += 1; }
                }
                const byDayValve = {};
                for (const r of valveRows) {
                    const k = r.ts_madrid_day_key || dayKeyForTs(r.ts);
                    const b = byDayValve[k] || (byDayValve[k] = { on: 0, cnt: 0 });
                    const s = Number(r.state || 0) >= 1 ? 1 : 0;
                    b.on += s;
                    b.cnt += 1;
                }
                const keys = Array.from(new Set([...Object.keys(byDayHum), ...Object.keys(byDayValve)])).sort();
                for (const k of keys) {
                    labels.push(k.slice(8, 10));
                    const hB = byDayHum[k];
                    const vB = byDayValve[k];
                    const avg = hB && hB.cnt ? (hB.sum / hB.cnt) : null;
                    hum.push(avg == null ? null : Number(avg.toFixed(2)));
                    // Horas ON estimadas: (porcentaje de horas con state=1) * 24
                    const onHours = vB && vB.cnt ? (vB.on / vB.cnt) * 24 : 0;
                    valve.push(Number(onHours.toFixed(2)));
                    if (hB) { totalHumSum += hB.sum; totalHumCount += hB.cnt; }
                    if (vB) { totalValveOnMs += (vB.cnt ? (vB.on / vB.cnt) * 24 * 3600000 : 0); }
                }

                valveChart.options.scales.y.min = 0;
                valveChart.options.scales.y.max = undefined;
                valveChart.options.scales.y.ticks.callback = undefined;
                valveChart.options.scales.y.ticks.stepSize = undefined;
                valveChart.data.datasets[0].label = 'Válvula (horas ON/día)';

            } else {
                const pNow = getMadridParts(nowAdjusted());
                document.getElementById('periodLabel').textContent = 'Año';
                document.getElementById('periodValue').textContent = `${pNow.y}`;

                const byMonthHum = {};
                for (const r of humRows) {
                    const k = r.ts_madrid_month_key || monthKeyForTs(r.ts);
                    const b = byMonthHum[k] || (byMonthHum[k] = { sum: 0, cnt: 0 });
                    const v = r.value == null ? null : Number(r.value);
                    if (v != null && !Number.isNaN(v)) { b.sum += v; b.cnt += 1; }
                }
                const byMonthValve = {};
                for (const r of valveRows) {
                    const k = r.ts_madrid_month_key || monthKeyForTs(r.ts);
                    const b = byMonthValve[k] || (byMonthValve[k] = { on: 0, cnt: 0 });
                    const s = Number(r.state || 0) >= 1 ? 1 : 0;
                    b.on += s;
                    b.cnt += 1;
                }
                const keys = Array.from(new Set([...Object.keys(byMonthHum), ...Object.keys(byMonthValve)])).sort();
                for (const k of keys) {
                    labels.push(k.slice(5, 7));
                    const hB = byMonthHum[k];
                    const vB = byMonthValve[k];
                    const avg = hB && hB.cnt ? (hB.sum / hB.cnt) : null;
                    hum.push(avg == null ? null : Number(avg.toFixed(2)));
                    const onHours = vB && vB.cnt ? (vB.on / vB.cnt) * (30 * 24) : 0; // aprox
                    valve.push(Number(onHours.toFixed(1)));
                    if (hB) { totalHumSum += hB.sum; totalHumCount += hB.cnt; }
                    if (vB) { totalValveOnMs += (vB.cnt ? (vB.on / vB.cnt) * (30 * 24) * 3600000 : 0); }
                }

                valveChart.options.scales.y.min = 0;
                valveChart.options.scales.y.max = undefined;
                valveChart.options.scales.y.ticks.callback = undefined;
                valveChart.options.scales.y.ticks.stepSize = undefined;
                valveChart.data.datasets[0].label = 'Válvula (horas ON/mes)';
            }

            const avgHum = totalHumCount ? (totalHumSum / totalHumCount) : null;
            document.getElementById('avgHumidity').textContent = avgHum === null ? '--' : `${avgHum.toFixed(1)}%`;
            document.getElementById('totalValveOn').textContent = totalValveOnMs ? formatDuration(totalValveOnMs) : '--';
            document.getElementById('valveOnTime').textContent = `Tiempo ON (periodo): ${totalValveOnMs ? formatDuration(totalValveOnMs) : '--'}`;

            const lastPointEl = document.getElementById('lastPoint');
            if (lastPointEl) {
                const lastLabel = labels.length ? String(labels[labels.length - 1]) : '';
                let lastDate = null;
                if (viewMode === 'day') {
                    const lastRow = humRows.length ? humRows[humRows.length - 1] : (valveRows.length ? valveRows[valveRows.length - 1] : null);
                    lastDate = lastRow ? (parseTsToDate(lastRow.ts) || null) : null;
                }
                lastPointEl.textContent = formatLastPointText(viewMode, lastDate, lastLabel);
            }

            setSeries(humLabels, humSeries, labels, hum);
            setSeries(valveLabels, valveSeries, labels, valve);
            humChart.update('none');
            valveChart.update('none');
        }

        function rebuildCharts(storeOpt) {
            if (storeOpt) return rebuildChartsFromStore(storeOpt);
            rebuildChartsFromServer().catch(() => rebuildChartsFromStore());
        }

        function tickClock() {
            const t = fmtNowEs.format(nowAdjusted());
            document.getElementById('nowEs').textContent = t;
            const topNow = document.getElementById('topNowEs');
            if (topNow) topNow.textContent = t;
        }
        tickClock();
        setInterval(tickClock, 1000);

        async function cargarConfig() {
            try {
                const res = await fetch(`/api/config/${encodeURIComponent(deviceCode)}`, { credentials: 'include' });
                const cfg = await res.json();

                let threshold = parseFloat(cfg.humidity_low_threshold);
                if (isNaN(threshold) || threshold < 1) threshold = 25;
                if (threshold > 100) threshold = 100;

                config.threshold = threshold;
                config.colorB = cfg.humidity_low_color || 'Rojo';
                config.colorG = cfg.humidity_good_color || 'Verde';

                const thresholdEl = document.getElementById('threshold');
                const thresholdValueEl = document.getElementById('thresholdValue');
                const colorBuenaEl = document.getElementById('colorBuena');
                const colorBajaEl = document.getElementById('colorBaja');

                // Umbral global ya no se configura en UI (cada planta tiene su propio umbral).
                // Mantenemos config.threshold solo por compatibilidad/legacy.
                if (thresholdEl) thresholdEl.value = String(config.threshold);
                if (thresholdValueEl) thresholdValueEl.textContent = config.threshold + '%';
                if (colorBuenaEl) colorBuenaEl.value = config.colorB;
                if (colorBajaEl) colorBajaEl.value = config.colorG;

                // Campos avanzados
                document.getElementById('wetV').value = (cfg.wet_v == null ? String(DEFAULT_AUTO_CONFIG.wet_v) : cfg.wet_v);
                document.getElementById('dryV').value = (cfg.dry_v == null ? String(DEFAULT_AUTO_CONFIG.dry_v) : cfg.dry_v);
                document.getElementById('alertHumLowMin').value = cfg.alert_humidity_low_minutes ?? DEFAULT_AUTO_CONFIG.alert_humidity_low_minutes;
                document.getElementById('alertValveMaxMin').value = cfg.alert_valve_on_max_minutes ?? DEFAULT_AUTO_CONFIG.alert_valve_on_max_minutes;
                document.getElementById('alertDeadMin').value = cfg.alert_sensor_dead_minutes ?? DEFAULT_AUTO_CONFIG.alert_sensor_dead_minutes;
                document.getElementById('alertVmin').value = (cfg.alert_voltage_min == null ? '' : cfg.alert_voltage_min);
                document.getElementById('alertVmax').value = (cfg.alert_voltage_max == null ? '' : cfg.alert_voltage_max);
                document.getElementById('notifyWebhook').value = (cfg.notify_webhook_url == null ? '' : cfg.notify_webhook_url);
                document.getElementById('notifyTelegram').value = (cfg.notify_telegram_chat_id == null ? '' : cfg.notify_telegram_chat_id);

                // Zonas (8 plantas): umbral y asignación por canal
                zonesState = normalizeZonesFromServer(cfg?.zones, config.threshold);
                renderZonesUI();
            } catch (e) {
                console.log('Error cargando config');
            }
        }

        function applyDefaultAutoConfigToUI() {
            document.getElementById('wetV').value = String(DEFAULT_AUTO_CONFIG.wet_v);
            document.getElementById('dryV').value = String(DEFAULT_AUTO_CONFIG.dry_v);
            document.getElementById('alertHumLowMin').value = String(DEFAULT_AUTO_CONFIG.alert_humidity_low_minutes);
            document.getElementById('alertValveMaxMin').value = String(DEFAULT_AUTO_CONFIG.alert_valve_on_max_minutes);
            document.getElementById('alertDeadMin').value = String(DEFAULT_AUTO_CONFIG.alert_sensor_dead_minutes);
            document.getElementById('alertVmin').value = '';
            document.getElementById('alertVmax').value = '';
        }

        async function resetearDefaults() {
            const ok = confirm('¿Restablecer los valores por defecto de CONFIGURACIÓN AUTOMÁTICA?\n\nSe aplicarán estos valores:\n- WET_V: 1.10\n- DRY_V: 2.60\n- Alertas (min): 0\n- Voltaje mín/máx: vacío (desactivado)');
            if (!ok) return;
            applyDefaultAutoConfigToUI();

            const okSave = confirm('¿Quieres guardarlos ahora en el dispositivo?');
            if (okSave) {
                await guardar();
            }
        }

        {
            const thr = document.getElementById('threshold');
            if (thr) {
                thr.addEventListener('input', (e) => {
                    config.threshold = parseInt(e.target.value);
                    const tv = document.getElementById('thresholdValue');
                    if (tv) tv.textContent = config.threshold + '%';
                });
            }
        }

        document.getElementById('colorBuena').addEventListener('change', (e) => {
            config.colorB = e.target.value;
        });

        document.getElementById('colorBaja').addEventListener('change', (e) => {
            config.colorG = e.target.value;
        });

        async function guardar() {
            const btn = document.getElementById('btnSaveConfig');
            return withBusy(btn, 'Guardando...', async () => {
            try {
                const headersBase = { 'Content-Type': 'application/json' };
                setStatusText(' Guardando configuración...');

                const wetV = document.getElementById('wetV').value;
                const dryV = document.getElementById('dryV').value;
                const alertHumLowMin = document.getElementById('alertHumLowMin').value;
                const alertValveMaxMin = document.getElementById('alertValveMaxMin').value;
                const alertDeadMin = document.getElementById('alertDeadMin').value;
                const alertVmin = document.getElementById('alertVmin').value;
                const alertVmax = document.getElementById('alertVmax').value;
                const notifyWebhook = document.getElementById('notifyWebhook').value;
                const notifyTelegram = document.getElementById('notifyTelegram').value;

                const body = {
                    // Compat: mantener el umbral global sincronizado con PLANTA 1
                    humidity_low_threshold: (zonesState && zonesState[0] && zonesState[0].humidity_low_threshold != null)
                        ? Number(zonesState[0].humidity_low_threshold)
                        : config.threshold,
                    humidity_low_color: config.colorB,
                    humidity_good_color: config.colorG,
                    wet_v: wetV === '' ? undefined : Number(wetV),
                    dry_v: dryV === '' ? undefined : Number(dryV),
                    alert_humidity_low_minutes: Number(alertHumLowMin || 0),
                    alert_valve_on_max_minutes: Number(alertValveMaxMin || 0),
                    alert_sensor_dead_minutes: Number(alertDeadMin || 0),
                    alert_voltage_min: alertVmin === '' ? null : Number(alertVmin),
                    alert_voltage_max: alertVmax === '' ? null : Number(alertVmax),
                    notify_webhook_url: notifyWebhook === '' ? null : String(notifyWebhook),
                    notify_telegram_chat_id: notifyTelegram === '' ? null : String(notifyTelegram),
                    zones: (zonesState || []).slice(0, 8).map((z, i) => ({
                        zone: i + 1,
                        soil_channel_index: z?.soil_channel_index == null ? null : Number(z.soil_channel_index),
                        valve_channel_index: z?.valve_channel_index == null ? null : Number(z.valve_channel_index),
                        temperature_air_channel_index: z?.temperature_air_channel_index == null ? null : Number(z.temperature_air_channel_index),
                        humidity_air_channel_index: z?.humidity_air_channel_index == null ? null : Number(z.humidity_air_channel_index),
                        temperature_soil_channel_index: z?.temperature_soil_channel_index == null ? null : Number(z.temperature_soil_channel_index),
                        ph_soil_channel_index: z?.ph_soil_channel_index == null ? null : Number(z.ph_soil_channel_index),
                        ec_soil_channel_index: z?.ec_soil_channel_index == null ? null : Number(z.ec_soil_channel_index),
                        humidity_low_threshold: z?.humidity_low_threshold == null ? null : Number(z.humidity_low_threshold)
                    }))
                };

                async function doSave(headers) {
                    return fetch(`/api/config/${encodeURIComponent(deviceCode)}`, {
                        method: 'POST',
                        headers,
                        credentials: 'include',
                        body: JSON.stringify(body)
                    });
                }

                const saved = (getSavedToken(deviceCode) || '').trim();
                const headers1 = { ...headersBase };
                if (saved) headers1['X-Device-Token'] = saved;

                let res = await doSave(headers1);

                if (res.status === 401 || res.status === 403) {
                    const msg = saved
                        ? 'Token guardado inválido o caducado. Pega el token correcto:'
                        : 'Este dispositivo requiere token para guardar. Pégalo aquí:';
                    const t = (prompt(msg) || '').trim();
                    if (t) {
                        saveToken(deviceCode, t);
                        const headers2 = { ...headersBase, 'X-Device-Token': t };
                        res = await doSave(headers2);
                    }
                }

                if (res.ok) {
                    setStatusText(' Configuración guardada');
                    alert(' Configuracion guardada!\nEl ESP32 aplicara los cambios en 10 segundos.');
                } else {
                    setStatusText(' Error al guardar');
                    alert(' Error al guardar');
                }
            } catch (e) {
                setStatusText(' Error de conexión');
                alert(' Error de conexion');
            }
            });
        }

        // Hook UI: reset defaults
        document.getElementById('btnResetDefaults')?.addEventListener('click', () => {
            resetearDefaults();
        });

        async function actualizarSensores() {
            try {
                const res = await fetch(`/api/sensor/latest/${encodeURIComponent(deviceCode)}`);
                const data = await res.json();

                // Ajuste de reloj (si el backend lo manda)
                if (data && data.server_now) {
                    const serverMs = Date.parse(data.server_now);
                    if (Number.isFinite(serverMs)) {
                        serverClockOffsetMs = serverMs - Date.now();
                    }
                }
                
                updateConnectedDeviceCards(data);

                const v = (data.voltage == null ? null : Number(data.voltage));
                document.getElementById('voltage').textContent = (v == null || Number.isNaN(v) ? '--' : v.toFixed(2));
                {
                    const el = document.getElementById('voltageMeta');
                    const vOk = !(v == null || Number.isNaN(v));
                    const variant = !vOk ? 'neutral' : (v >= 1.8 ? 'ok' : (v >= 1.0 ? 'warn' : 'bad'));
                    setChips(el, [
                        { k: 'Unidad', v: 'V', variant: 'neutral' },
                        { k: 'Estado', v: !vOk ? '--' : (variant === 'ok' ? 'ok' : (variant === 'warn' ? 'bajo' : 'crítico')), variant },
                    ]);
                }

                const rssi = (data.wifi_rssi == null ? null : Number(data.wifi_rssi));
                const rssiOk = !(rssi == null || Number.isNaN(rssi) || rssi === 0);

                const rbRaw = (data.reboot_count_display != null ? data.reboot_count_display : data.reboot_count);
                const rb = (rbRaw == null ? null : Number(rbRaw));
                lastRebootsBase = (rb == null || Number.isNaN(rb)) ? null : Math.trunc(rb);
                const localOffset = getLocalRebootsOffset(deviceCode);
                const rbShown = (lastRebootsBase == null) ? null : Math.max(0, lastRebootsBase - localOffset);
                document.getElementById('reboots').textContent = (rbShown == null ? '--' : String(Math.trunc(rbShown)));
                {
                    const el = document.getElementById('rebootsMeta');
                    setChips(el, [
                        { k: 'Total', v: (rbShown == null ? '--' : String(Math.trunc(rbShown))), variant: (rbShown != null && rbShown === 0) ? 'ok' : 'neutral' },
                        { k: 'Reset', v: 'manual', variant: 'neutral', title: 'Reset a 0 (UI)' },
                    ]);
                }

                // Colores por umbral (valores típicos; además se respetan min/max de alertas si están configurados)
                const alertVminRaw = document.getElementById('alertVmin')?.value;
                const alertVmaxRaw = document.getElementById('alertVmax')?.value;
                const alertVmin = Number(alertVminRaw);
                const alertVmax = Number(alertVmaxRaw);
                const hasVmin = !!(alertVminRaw != null && alertVminRaw.trim() !== '' && Number.isFinite(alertVmin));
                const hasVmax = !!(alertVmaxRaw != null && alertVmaxRaw.trim() !== '' && Number.isFinite(alertVmax));
                if (v == null || Number.isNaN(v)) {
                    setMetricStateById('voltage', 'metric-neutral');
                } else if ((hasVmin && v < alertVmin) || (hasVmax && v > alertVmax)) {
                    setMetricStateById('voltage', 'metric-bad', `Fuera de rango (${hasVmin ? alertVmin : '-'} – ${hasVmax ? alertVmax : '-' } V)`);
                } else {
                    // fallback si no hay min/max
                    const st = v < 1.0 ? 'metric-bad' : (v < 1.8 ? 'metric-warn' : 'metric-good');
                    setMetricStateById('voltage', st);
                }

                if (!rssiOk) {
                    setMetricStateById('rssi', 'metric-neutral');
                } else {
                    const st = rssi >= -60 ? 'metric-good' : (rssi >= -75 ? 'metric-warn' : 'metric-bad');
                    setMetricStateById('rssi', st);
                }

                // Ya no mostramos el umbral en la sección "DISPOSITIVO CONECTADO"

                if (rbShown == null) {
                    setMetricStateById('reboots', 'metric-neutral');
                } else {
                    const st = rbShown === 0 ? 'metric-good' : (rbShown <= 2 ? 'metric-warn' : 'metric-bad');
                    setMetricStateById('reboots', st);
                }

                const rawValve = (data.valve_state || '').toString().toUpperCase();
                const isOn = rawValve === 'ON' || rawValve === '1' || rawValve === 'TRUE';
                const isOff = rawValve === 'OFF' || rawValve === '0' || rawValve === 'FALSE';

                const valveDotChart = document.getElementById('valveDotChart');
                const valveTextChart = document.getElementById('valveTextChart');
                if (isOn) {
                    valveDotChart.className = 'valve-dot on';
                    valveTextChart.textContent = 'ENCENDIDA';
                } else if (isOff) {
                    valveDotChart.className = 'valve-dot off';
                    valveTextChart.textContent = 'APAGADA';
                } else {
                    valveDotChart.className = 'valve-dot';
                    valveTextChart.textContent = 'SIN DATOS';
                }

                // --- Mantener el histórico local como fallback y refrescar gráficas del servidor ---
                try {
                    const sampleDate = parseTsToDate(data.created_at) || nowAdjusted();
                    const nowMs = sampleDate.getTime();
                    const hum = Number.parseFloat(data.humidity);
                    const valveVal = isOn ? 1 : (isOff ? 0 : null);
                    const store = loadStore();
                    ingestSample(store, nowMs, hum, valveVal === 1);
                    // Importante: si SSE está caído, esto mantiene las gráficas vivas.
                    scheduleChartsRebuild();
                } catch {}

                // Estado online/offline del dispositivo basado en “último dato”
                let deviceOnline = null;
                try {
                    const sampleDate = parseTsToDate(data.created_at);
                    const deadRaw = document.getElementById('alertDeadMin')?.value;
                    const deadMin = Number(deadRaw);
                    const maxAgeMs = (deadRaw != null && deadRaw.trim() !== '' && Number.isFinite(deadMin) && deadMin > 0)
                        ? deadMin * 60000
                        : 3 * 60000;
                    const ageMs = sampleDate ? (nowAdjusted().getTime() - sampleDate.getTime()) : Infinity;
                    const lastSampleLabel = (data && data.created_at_madrid)
                        ? String(data.created_at_madrid)
                        : (sampleDate ? sampleDate.toLocaleString('es-ES', { timeZone: TZ, hour12: false }) : '--');
                    deviceOnline = ageMs <= maxAgeMs;
                    setConnectionUI(deviceOnline ? 'online' : 'offline');
                } catch {
                    setConnectionUI('unknown');
                }

                // Rendimiento: no forzar rebuild de gráficas en cada tick
                // (se reconstruyen con throttle por SSE/intervalos)
                
                // Mostrar también la hora del último dato para detectar desfases/datos viejos
                const sampleDateForUi = parseTsToDate(data?.created_at);
                const lastSampleUi = (data && data.created_at_madrid)
                    ? String(data.created_at_madrid)
                    : (sampleDateForUi ? sampleDateForUi.toLocaleString('es-ES', { timeZone: TZ, hour12: false }) : '--');

                if (deviceOnline === false) {
                    setStatusText(` Offline (datos antiguos) · Último: ${lastSampleUi} · Ahora: ${fmtNowEs.format(nowAdjusted())}`);
                    setStatusClass(false);
                } else {
                    setStatusText(` Online · Último: ${lastSampleUi} · Ahora: ${fmtNowEs.format(nowAdjusted())}`);
                    setStatusClass(true);
                }
            } catch(e) {
                setConnectionUI('offline');
                setStatusText(' Sin conexion');
                setStatusClass(false);
            }

            // Zonas: últimos valores por canal
            try {
                const r2 = await fetch(`/api/channels/${encodeURIComponent(deviceCode)}/latest`, { credentials: 'include' });
                if (r2.ok) {
                    const p = await r2.json();
                    updateZonesFromLatestPayload(p);
                }
            } catch {
                // ignore
            }
        }

        async function cargarAlertas() {
            const st = document.getElementById('alertsStatus');
            const listEl = document.getElementById('alertsList');
            try {
                const r = await fetch(`/api/alerts/${encodeURIComponent(deviceCode)}?limit=10`);
                const j = await r.json();
                const rows = Array.isArray(j.rows) ? j.rows : [];
                st.textContent = rows.length ? `Últimas ${rows.length} alertas` : 'Sin alertas';
                listEl.innerHTML = '';
                for (const a of rows) {
                    const item = document.createElement('div');
                    item.className = 'sensor-card';
                    item.style.textAlign = 'left';
                    const when = a.created_at_madrid || (a.created_at ? new Date(a.created_at).toLocaleString('es-ES', { timeZone: TZ, hour12: false }) : '--');
                    item.innerHTML = `
                        <div class="sensor-label">${a.kind} · ${when}</div>
                        <div style="color:#ddd; font-weight:bold;">${a.message}</div>
                    `;
                    listEl.appendChild(item);
                }
            } catch {
                st.textContent = 'No se pudieron cargar alertas';
            }
        }

        function startSSE() {
            try {
                const es = new EventSource(`/api/sse/${encodeURIComponent(deviceCode)}`);
                es.addEventListener('sensor', () => {
                    actualizarSensores();
                    scheduleChartsRebuild();
                });
                es.addEventListener('alert', () => {
                    cargarAlertas();
                });
                es.onerror = () => {
                    try { es.close(); } catch {}
                };
            } catch {
                // ignore
            }
        }

        async function boot() {
            initCollapsibles();
            const ok = await loadDevices();
            if (!ok) return;
            if (!hasDevices) return;

            await cargarConfig();
            await loadChannels();
            renderZonesUI();
            scheduleChartsRebuild();
            rebuildCharts();
            cargarAlertas();
            actualizarSensores();
            startSSE();
            setInterval(actualizarSensores, 15000);
            setInterval(scheduleChartsRebuild, 60000);
            setInterval(cargarAlertas, 60000);
        }

        boot();

        // --- UI acciones rápidas ---
        document.getElementById('btnAddDevice')?.addEventListener('click', async () => {
            const btn = document.getElementById('btnAddDevice');
            await withBusy(btn, 'Añadiendo...', async () => {
            const deviceRaw = prompt('Código del dispositivo (ej: RIEGO_002):');
            if (deviceRaw === null) return; // Cancel
            const device_code = String(deviceRaw || '').trim();
            if (!device_code) return;

            const tokenRaw = prompt('claim_token (código de emparejamiento):');
            if (tokenRaw === null) return; // Cancel
            const claim_token = String(tokenRaw || '').trim();
            if (!claim_token) {
                alert('Debes pegar el claim_token (token del ESP32) para emparejar.');
                return;
            }
            try {
                // Preferido (multi-tenant): claim
                let r = await fetch('/api/device/claim', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({ device_code, claim_token })
                });

                if (r.status === 401) {
                    const next = encodeURIComponent(location.pathname + location.search + location.hash);
                    window.location.href = `/login?next=${next}`;
                    return;
                }

                // Fallback legacy: register (sin cuentas)
                if (r.status === 404 || r.status === 405) {
                    const name = (prompt('Nombre (opcional):') || 'ESP32 Riego').trim();
                    const locationTxt = (prompt('Ubicación (opcional):') || '').trim();
                    r = await fetch('/api/device/register', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include',
                        body: JSON.stringify({ device_code, name, location: locationTxt || null })
                    });
                }

                const j = await r.json().catch(() => ({}));
                if (!r.ok) throw new Error(j.error || 'No se pudo añadir');

                window.location.href = `/panel/${encodeURIComponent(device_code)}`;
            } catch {
                alert('No se pudo añadir el dispositivo (verifica el claim_token)');
            }
            });
        });

        document.getElementById('btnAddValve')?.addEventListener('click', () => {
            (async () => {
                const btn = document.getElementById('btnAddValve');
                await withBusy(btn, 'Añadiendo...', async () => {
                const current = (channels || []).filter(c => c && c.kind === 'valve').length;
                if (current >= 8) {
                    alert('Máximo 8 válvulas por dispositivo (modelo de 8 zonas).');
                    return;
                }
                const nameRaw = prompt('Nombre de la nueva válvula (ej: Válvula 2):');
                if (nameRaw === null) return; // Cancel
                const name = String(nameRaw || '').trim();
                const headers = { 'Content-Type': 'application/json' };
                const saved = (getSavedToken(deviceCode) || '').trim();
                if (saved) headers['X-Device-Token'] = saved;
                let r = await fetch(`/api/channels/${encodeURIComponent(deviceCode)}`, {
                    method: 'POST',
                    headers,
                    credentials: 'include',
                    body: JSON.stringify({ kind: 'valve', name: name || undefined })
                });
                if ((r.status === 401 || r.status === 403) && !saved) {
                    const tRaw = prompt('Este dispositivo requiere token para añadir válvulas. Pégalo aquí:');
                    if (tRaw === null) return; // Cancel
                    const t = String(tRaw || '').trim();
                    if (t) {
                        saveToken(deviceCode, t);
                        r = await fetch(`/api/channels/${encodeURIComponent(deviceCode)}`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json', 'X-Device-Token': t },
                            credentials: 'include',
                            body: JSON.stringify({ kind: 'valve', name: name || undefined })
                        });
                    }
                }
                if (!r.ok) return alert('No se pudo añadir la válvula');
                await loadChannels();
                scheduleChartsRebuild();
                alert('Válvula añadida. La gráfica aparecerá cuando el ESP32 envíe datos de esa válvula.');
                });
            })();
        });

        function pickSensorTypeModal() {
            const options = [
                { kind: 'temperature_air', label: 'Temperatura aire' },
                { kind: 'temperature_soil', label: 'Temperatura tierra' },
                { kind: 'ph_soil', label: 'pH tierra' },
                { kind: 'ec_soil', label: 'EC tierra' },
                { kind: 'soil_sensor', label: 'Humedad tierra' },
                { kind: 'humidity_air', label: 'Humedad aire' }
            ];

            return new Promise((resolve) => {
                const overlay = document.createElement('div');
                overlay.className = 'modal-overlay';
                overlay.innerHTML = `
                    <div class="modal" role="dialog" aria-modal="true" aria-label="Seleccionar tipo de sensor">
                        <div class="modal-title">¿Qué sensor quieres añadir?</div>
                        <div class="choice-grid">
                            ${options.map(o => `<button class="mini-btn" type="button" data-kind="${escapeHtml(o.kind)}">${escapeHtml(o.label)}</button>`).join('')}
                        </div>
                        <div class="modal-actions">
                            <button class="mini-btn" type="button" data-cancel="1">Cancelar</button>
                        </div>
                    </div>
                `;

                const cleanup = () => {
                    try { document.removeEventListener('keydown', onKeyDown); } catch {}
                    overlay.remove();
                };

                const onKeyDown = (e) => {
                    if (e.key === 'Escape') {
                        cleanup();
                        resolve(null);
                    }
                };

                overlay.addEventListener('click', (e) => {
                    if (e.target === overlay) {
                        cleanup();
                        resolve(null);
                    }
                });

                overlay.querySelectorAll('button[data-kind]').forEach((b) => {
                    b.addEventListener('click', () => {
                        const kind = b.getAttribute('data-kind');
                        const opt = options.find(o => o.kind === kind) || null;
                        cleanup();
                        resolve(opt);
                    });
                });
                overlay.querySelector('button[data-cancel]')?.addEventListener('click', () => {
                    cleanup();
                    resolve(null);
                });

                document.addEventListener('keydown', onKeyDown);
                document.body.appendChild(overlay);
            });
        }

        function pickZoneModal({ title = '¿Para qué planta?' } = {}) {
            return new Promise((resolve) => {
                const overlay = document.createElement('div');
                overlay.className = 'modal-overlay';
                overlay.innerHTML = `
                    <div class="modal" role="dialog" aria-modal="true" aria-label="Seleccionar planta">
                        <div class="modal-title">${escapeHtml(title)}</div>
                        <div class="choice-grid">
                            ${Array.from({ length: 8 }).map((_, i) => {
                                const z = i + 1;
                                return `<button class="mini-btn" type="button" data-zone="${z}">Planta ${z}</button>`;
                            }).join('')}
                            <button class="mini-btn" type="button" data-zone="0">(sin asignar)</button>
                        </div>
                        <div class="modal-actions">
                            <button class="mini-btn" type="button" data-cancel="1">Cancelar</button>
                        </div>
                    </div>
                `;

                const cleanup = () => {
                    try { document.removeEventListener('keydown', onKeyDown); } catch {}
                    overlay.remove();
                };
                const onKeyDown = (e) => {
                    if (e.key === 'Escape') {
                        cleanup();
                        resolve(null);
                    }
                };

                overlay.addEventListener('click', (e) => {
                    if (e.target === overlay) {
                        cleanup();
                        resolve(null);
                    }
                });

                overlay.querySelectorAll('button[data-zone]').forEach((b) => {
                    b.addEventListener('click', () => {
                        const z = Number(b.getAttribute('data-zone'));
                        cleanup();
                        resolve(Number.isFinite(z) ? z : null);
                    });
                });
                overlay.querySelector('button[data-cancel]')?.addEventListener('click', () => {
                    cleanup();
                    resolve(null);
                });

                document.addEventListener('keydown', onKeyDown);
                document.body.appendChild(overlay);
            });
        }

        document.getElementById('btnAddSensor')?.addEventListener('click', () => {
            (async () => {
                const btn = document.getElementById('btnAddSensor');
                await withBusy(btn, 'Añadiendo...', async () => {
                const picked = await pickSensorTypeModal();
                if (!picked) return;
                const kind = picked.kind;

                const zonePicked = await pickZoneModal({ title: `¿En qué planta va este sensor? (${picked.label})` });
                if (zonePicked === null) return; // cancel

                const current = (channels || []).filter(c => c && c.kind === kind).length;
                if (current >= 8) {
                    alert('Máximo 8 sensores de este tipo por dispositivo.');
                    return;
                }

                const suggested = (zonePicked && zonePicked >= 1)
                    ? `P${zonePicked} · ${picked.label}`
                    : `${picked.label} ${current + 1}`;
                const nameRaw = prompt(`Nombre del nuevo sensor (${picked.label}):`, suggested);
                if (nameRaw === null) return; // Cancel
                const name = String(nameRaw || '').trim();
                const headers = { 'Content-Type': 'application/json' };
                const saved = (getSavedToken(deviceCode) || '').trim();
                if (saved) headers['X-Device-Token'] = saved;
                let r = await fetch(`/api/channels/${encodeURIComponent(deviceCode)}`, {
                    method: 'POST',
                    headers,
                    credentials: 'include',
                    body: JSON.stringify({ kind, name: name || undefined })
                });
                if ((r.status === 401 || r.status === 403) && !saved) {
                    const tRaw = prompt('Este dispositivo requiere token para añadir sensores. Pégalo aquí:');
                    if (tRaw === null) return; // Cancel
                    const t = String(tRaw || '').trim();
                    if (t) {
                        saveToken(deviceCode, t);
                        r = await fetch(`/api/channels/${encodeURIComponent(deviceCode)}`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json', 'X-Device-Token': t },
                            credentials: 'include',
                            body: JSON.stringify({ kind, name: name || undefined })
                        });
                    }
                }
                if (!r.ok) return alert('No se pudo añadir el sensor');

                const created = await r.json().catch(() => null);
                const createdChannel = created && created.channel ? created.channel : null;
                if (createdChannel && zonePicked && zonePicked >= 1) {
                    try {
                        const map = {
                            soil_sensor: 'soil_channel_index',
                            temperature_air: 'temperature_air_channel_index',
                            humidity_air: 'humidity_air_channel_index',
                            temperature_soil: 'temperature_soil_channel_index',
                            ph_soil: 'ph_soil_channel_index',
                            ec_soil: 'ec_soil_channel_index'
                        };
                        const prop = map[kind];
                        if (prop && zonesState && zonesState[zonePicked - 1]) {
                            zonesState[zonePicked - 1][prop] = Number(createdChannel.channel_index);
                        }
                    } catch {}
                }

                await loadChannels();
                scheduleChartsRebuild();
                alert('Sensor añadido. Aparecerá cuando el ESP32 envíe datos de ese sensor.');
                });
            })();
        });

        async function renameChannel(channelId, kindLabel) {
            if (!channelId) return;
            const newName = (prompt(`Nuevo nombre para ${kindLabel}:`) || '').trim();
            if (!newName) return;
            const headers = { 'Content-Type': 'application/json' };
            const saved = (getSavedToken(deviceCode) || '').trim();
            if (saved) headers['X-Device-Token'] = saved;

            let r = await fetch(`/api/channels/${encodeURIComponent(deviceCode)}/${encodeURIComponent(channelId)}`,
                { method: 'PATCH', headers, credentials: 'include', body: JSON.stringify({ name: newName }) });

            if ((r.status === 401 || r.status === 403) && !saved) {
                const t = (prompt('Este dispositivo requiere token para renombrar. Pégalo aquí:') || '').trim();
                if (t) {
                    saveToken(deviceCode, t);
                    r = await fetch(`/api/channels/${encodeURIComponent(deviceCode)}/${encodeURIComponent(channelId)}`,
                        { method: 'PATCH', headers: { ...headers, 'X-Device-Token': t }, credentials: 'include', body: JSON.stringify({ name: newName }) });
                }
            }
            if (!r.ok) return alert('No se pudo renombrar');
            await loadChannels();
            scheduleChartsRebuild();
        }

        document.getElementById('btnRenameHum')?.addEventListener('click', () => renameChannel(humChannelId, 'el sensor'));
        document.getElementById('btnRenameValve')?.addEventListener('click', () => renameChannel(valveChannelId, 'la válvula'));

        async function deleteChannelByIndex(kind, kindLabel) {
            const candidates = (channels || [])
                .filter(c => c && c.kind === kind)
                .filter(c => Number(c.channel_index) !== 1);

            if (!candidates.length) {
                alert(`No hay ${kindLabel}s añadidos para eliminar.`);
                return;
            }

            const indices = candidates.map(c => Number(c.channel_index)).filter(n => Number.isFinite(n)).sort((a,b) => a-b);
            const raw = prompt(`Índice de ${kindLabel} a eliminar (disponibles: ${indices.join(', ')}):`);
            if (raw === null) return; // Cancel
            const idx = Number(String(raw).trim());
            if (!Number.isInteger(idx)) return;

            const target = candidates.find(c => Number(c.channel_index) === idx);
            if (!target) {
                alert('Índice no encontrado.');
                return;
            }

            if (!confirm(`¿Eliminar ${kindLabel} ${idx}? Se borrará también su histórico.`)) return;

            const doDelete = async (headers) => {
                return fetch(`/api/channels/${encodeURIComponent(deviceCode)}/${encodeURIComponent(target.id)}`,
                    { method: 'DELETE', headers, credentials: 'include' });
            };

            const baseHeaders = { 'Content-Type': 'application/json' };
            const saved = (getSavedToken(deviceCode) || '').trim();
            const headers1 = { ...baseHeaders };
            if (saved) headers1['X-Device-Token'] = saved;

            let r = await doDelete(headers1);

            if ((r.status === 401 || r.status === 403) && !saved) {
                const tRaw = prompt('Este dispositivo requiere token para eliminar. Pégalo aquí:');
                if (tRaw === null) return; // Cancel
                const t = String(tRaw || '').trim();
                if (t) {
                    saveToken(deviceCode, t);
                    r = await doDelete({ ...baseHeaders, 'X-Device-Token': t });
                }
            }

            const j = await r.json().catch(() => ({}));
            if (!r.ok) {
                alert(j.error || `No se pudo eliminar ${kindLabel}`);
                return;
            }

            await loadChannels();
            scheduleChartsRebuild();
            alert(`${kindLabel} eliminado.`);
        }

        document.getElementById('btnDeleteHum')?.addEventListener('click', () => deleteChannelByIndex('soil_sensor', 'sensor'));
        document.getElementById('btnDeleteValve')?.addEventListener('click', () => deleteChannelByIndex('valve', 'válvula'));

        document.getElementById('btnDeleteDevice')?.addEventListener('click', async () => {
            if (!confirm(`¿Quitar el dispositivo ${deviceCode} de tu cuenta?`)) return;
            const r = await fetch(`/api/devices/${encodeURIComponent(deviceCode)}`, { method: 'DELETE', credentials: 'include' });
            const j = await r.json().catch(() => ({}));
            if (!r.ok) {
                alert(j.error || 'No se pudo eliminar el dispositivo');
                return;
            }
            location.href = '/app';
        });

        document.getElementById('resetRebootsBtn')?.addEventListener('click', async () => {
            if (!confirm('¿Poner el contador de reinicios a 0 (solo en el panel web)?')) return;
            if (lastRebootsBase == null) {
                alert('Aún no hay datos de reinicios para este dispositivo');
                return;
            }

            // Reset local (sin token): guardamos un offset por dispositivo
            setLocalRebootsOffset(deviceCode, lastRebootsBase);
            actualizarSensores();

            // Best-effort: si el backend admite reset sin auth, lo intentamos, pero nunca pedimos token.
            try {
                await fetch(`/api/device/reboots/reset/${encodeURIComponent(deviceCode)}`, { method: 'POST' });
            } catch {}
        });
    </script>
</body>
</html>
