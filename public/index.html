<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AgroSense · Panel</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: Arial, sans-serif; background: #0b1220; color: #e9eef7; padding: 16px; min-height: 100vh; }
        .container { width: 100%; max-width: none; margin: 0; }
        h1 { color: #dff7e3; margin-bottom: 6px; text-align: center; font-size: 18px; }
        :root {
            --logo-w: clamp(260px, 52vw, 560px);
            --c-primary: #4CAF50;
            --c-danger: #ff3333;
            --btn-radius: 12px;
            --btn-border: rgba(255,255,255,0.14);
            --btn-bg: rgba(255,255,255,0.08);
            --btn-bg-hover: rgba(255,255,255,0.12);
            --btn-shadow: 0 14px 30px rgba(0,0,0,0.28);
            --btn-shadow-hover: 0 18px 38px rgba(0,0,0,0.34);
        }
        .brand-header { display:flex; align-items:center; justify-content:center; margin: 6px 0 10px; }
        .brand-header img { width: var(--logo-w); max-width: 100%; height: auto; object-fit: contain; display:block; filter: drop-shadow(0 14px 30px rgba(0,0,0,0.55)); }
        .brand-title { display:none; }
        .section { background: #16213e; padding: 20px; border-radius: 12px; margin-bottom: 20px; }
        /* DISPOSITIVO: no sticky (molesta al hacer scroll) */
        #deviceSection { position: relative; z-index: 1; backdrop-filter: blur(8px); background: rgba(22,33,62,0.92); border: 1px solid rgba(255,255,255,0.08); box-shadow: 0 18px 40px rgba(0,0,0,0.30); }
        #deviceSection h2 { margin-bottom: 10px; }
        #deviceSection select { width: 100%; max-width: 100%; min-width: 0; }
        #deviceSection .control-row { flex-wrap: wrap; }
        #deviceSection .control-row label { flex: 0 0 100%; }
        #deviceSection .control-row select { flex: 1 1 100%; }
        .topbar-mini { display:flex; justify-content:space-between; gap: 10px; flex-wrap: wrap; align-items:center; margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.08); }
        .topbar-mini .mini-k { font-size: 11px; color:#8fa3bf; text-transform: uppercase; letter-spacing: .02em; margin-right: 6px; }
        .topbar-mini .mini-v { font-weight: 700; color:#e9eef7; }
        .topbar-mini .right { display:flex; gap: 10px; align-items:center; flex-wrap: wrap; justify-content:flex-end; }
        .pill { display:inline-flex; gap: 8px; align-items:center; padding: 6px 10px; border-radius: 999px; border: 1px solid rgba(255,255,255,0.10); background: rgba(0,0,0,0.10); font-size: 12px; color:#c9d1d9; }
        .section h2 { color: #4CAF50; font-size: 16px; margin-bottom: 15px; border-bottom: 1px solid #333; padding-bottom: 10px; }
        /* Rejilla responsive: evita que en móvil se “salgan” las tarjetas */
        .sensor-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 15px; }
        .sensor-card { --accent: #4CAF50; --accent-soft: rgba(76,175,80,0.18); background: #0f3460; padding: 15px; border-radius: 8px; text-align: center; min-width: 0; border: 1px solid rgba(255,255,255,0.06); box-shadow: 0 10px 26px rgba(0,0,0,0.25); transition: transform 0.12s ease, border-color 0.12s ease, box-shadow 0.12s ease; }
        .sensor-card:hover { transform: translateY(-1px); border-color: rgba(255,255,255,0.12); box-shadow: 0 14px 32px rgba(0,0,0,0.30); }
        .sensor-label { font-size: 11px; color: #ffffff; text-transform: uppercase; margin-bottom: 5px; margin-top: 5px; }
        .sensor-value { font-size: clamp(22px, 6vw, 32px); font-weight: bold; color: var(--accent); }
        .sensor-unit { font-size: 14px; color: var(--accent); opacity: 0.88; }

        /* Estado visual para métricas (voltaje/RSSI/uptime/reinicios) */
        .metric-good .sensor-value { color: #33cc33; }
        .metric-warn .sensor-value { color: #ffcc00; }
        .metric-bad  .sensor-value { color: #ff4d4d; }
        .metric-neutral .sensor-value { color: var(--accent); opacity: 0.92; }

        .metric-good { border-color: rgba(51,204,51,0.25); box-shadow: 0 12px 28px rgba(51,204,51,0.08), 0 10px 26px rgba(0,0,0,0.25); }
        .metric-warn { border-color: rgba(255,204,0,0.25); box-shadow: 0 12px 28px rgba(255,204,0,0.08), 0 10px 26px rgba(0,0,0,0.25); }
        .metric-bad  { border-color: rgba(255,77,77,0.30); box-shadow: 0 12px 28px rgba(255,77,77,0.10), 0 10px 26px rgba(0,0,0,0.25); }
        .metric-neutral { border-color: rgba(255,255,255,0.08); }

        /* Colores por tarjeta (accent): aplica a tarjetas sin “color” propio */
        .sensor-card.accent { position: relative; overflow: hidden; border-color: rgba(255,255,255,0.10); box-shadow: 0 12px 28px rgba(0,0,0,0.25), inset 0 0 0 1px var(--accent-soft); }
        .sensor-card.accent::before {
            content: "";
            position: absolute;
            inset: -140px -180px auto auto;
            width: 280px;
            height: 280px;
            background: radial-gradient(circle, var(--accent-soft), transparent 62%);
            transform: rotate(18deg);
            pointer-events: none;
        }
        .sensor-card.accent::after {
            content: "";
            position: absolute;
            left: 12px;
            right: 12px;
            top: 10px;
            height: 3px;
            border-radius: 999px;
            background: linear-gradient(90deg, transparent, var(--accent), transparent);
            opacity: 0.65;
            pointer-events: none;
        }

        .accent-green { --accent:#22c55e; --accent-soft: rgba(34,197,94,0.18); }
        .accent-cyan { --accent:#22d3ee; --accent-soft: rgba(34,211,238,0.18); }
        .accent-blue { --accent:#60a5fa; --accent-soft: rgba(96,165,250,0.18); }
        .accent-indigo { --accent:#818cf8; --accent-soft: rgba(129,140,248,0.18); }
        .accent-purple { --accent:#a78bfa; --accent-soft: rgba(167,139,250,0.18); }
        .accent-amber { --accent:#fbbf24; --accent-soft: rgba(251,191,36,0.18); }
        .accent-yellow { --accent:#fbbf24; --accent-soft: rgba(251,191,36,0.18); }
        .accent-orange { --accent:#fb923c; --accent-soft: rgba(251,146,60,0.18); }
        .accent-pink { --accent:#f472b6; --accent-soft: rgba(244,114,182,0.18); }
        .accent-red { --accent:#fb7185; --accent-soft: rgba(251,113,133,0.18); }

        /* Mini “pantalla OLED” dentro de tarjeta */
        .oled-panel {
            margin-top: 10px;
            padding: 10px 12px;
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.12);
            background: radial-gradient(120% 140% at 10% 0%, var(--accent-soft), rgba(0,0,0,0.18));
            box-shadow: 0 14px 30px rgba(0,0,0,0.20), inset 0 0 0 1px rgba(255,255,255,0.04);
            color: rgba(233,238,247,0.92);
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 12px;
            line-height: 1.35;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .oled-panel .oled-k { color: rgba(255, 255, 255, 0.98); font-weight: 900; }
        .oled-panel .oled-v { color: rgba(233,238,247,0.92); font-weight: 900; }
        .oled-panel .oled-v-hum { color: #22c55e; text-shadow: 0 0 12px rgba(34,197,94,0.18); }
        .oled-panel .oled-v-thr { color: #fbbf24; text-shadow: 0 0 12px rgba(251,191,36,0.18); }
        .oled-panel .oled-v-valve { color: #fb7185; text-shadow: 0 0 12px rgba(251,113,133,0.18); }
        .oled-panel .oled-v-v { color: #a78bfa; text-shadow: 0 0 12px rgba(167,139,250,0.18); }
        .oled-panel .oled-v-wifi { color: #22d3ee; text-shadow: 0 0 12px rgba(34,211,238,0.18); }
        .oled-panel .oled-v-ip { color: #60a5fa; text-shadow: 0 0 12px rgba(96,165,250,0.18); }

        /* Chips (para que las tarjetas se vean más “llenas”) */
        .chips { display:flex; flex-wrap:wrap; gap: 8px; margin-top: 10px; justify-content:center; }
        .chip { display:inline-flex; align-items:center; gap: 6px; padding: 6px 10px; border-radius: 999px; border: 1px solid rgba(255,255,255,0.12); background: rgba(255,255,255,0.08); color:#d7deea; font-size: 11px; font-weight: 900; letter-spacing: .01em; }
        .chip .k { opacity: .72; font-weight: 900; }
        .chip .v { color:#ffffff; }
        .chip-ok { border-color: rgba(34,197,94,0.30); background: rgba(34,197,94,0.10); color: rgba(187,247,208,0.95); }
        .chip-warn { border-color: rgba(250,204,21,0.35); background: rgba(250,204,21,0.10); color: rgba(254,249,195,0.98); }
        .chip-bad { border-color: rgba(239,68,68,0.35); background: rgba(239,68,68,0.10); color: rgba(254,202,202,0.98); }
        .chip-neutral { border-color: rgba(148,163,184,0.22); background: rgba(148,163,184,0.08); }

        /* Tarjetas del bloque DISPOSITIVO CONECTADO: más modernas y menos vacías */
        #connectedSection .sensor-grid { grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); }
        #connectedSection .sensor-card { position: relative; overflow: hidden; padding: 54px 16px 16px; }
        #connectedSection .sensor-card::before {
            content: "";
            position: absolute;
            inset: -120px -160px auto auto;
            width: 260px;
            height: 260px;
            background: radial-gradient(circle, var(--accent-soft), transparent 62%);
            transform: rotate(18deg);
            pointer-events: none;
        }
        #connectedSection .sensor-card.accent::after { top: 40px; }
        #connectedSection .sensor-label { font-size: 12px; letter-spacing: .03em; opacity: .96; }
        #connectedSection .sensor-value { font-size: clamp(22px, 5vw, 34px); }
        #connectedSection .sensor-value.small { font-size: 16px; }
        #connectedSection #uptime { white-space: pre-line; line-height: 1.25; }

        /* Neon más marcado en valores pequeños del bloque conectado (IP / sensores-válvulas) */
        #connectedSection .sensor-card.accent .sensor-value.small { color: var(--accent); text-shadow: 0 0 16px var(--accent-soft); }

        /* Zonas / Plantas */
        .zone-off { opacity: 0.62; }
        .sensor-card.card-off { opacity: 0.55; filter: saturate(0.7); }
        .zone-subtitle { color:#8fa3bf; font-size: 12px; margin-top: -6px; margin-bottom: 8px; overflow-wrap: anywhere; word-break: break-word; }
        .zones-global-row { display:flex; justify-content:flex-end; align-items:center; gap: 10px; flex-wrap: wrap; margin: 4px 0 10px; }
        .zones-global-btn { background: linear-gradient(180deg, rgba(163,255,18,0.22), rgba(15,23,42,0.70)); border-color: rgba(163,255,18,0.28); color: rgba(232,255,200,0.95); box-shadow: 0 14px 30px rgba(0,0,0,0.22); }
        .zones-global-btn:hover { filter: brightness(1.06); }
        .zones-global-btn:focus-visible { outline: 2px solid rgba(163,255,18,0.35); outline-offset: 2px; }

        .zone-topbar { display:flex; align-items:center; justify-content: space-between; gap: 10px; flex-wrap: wrap; margin: 6px 0 10px; }
        .zone-controls-btn { background: linear-gradient(180deg, rgba(163,255,18,0.18), rgba(255,255,255,0.06)); border-color: rgba(163,255,18,0.22); color: rgba(232,255,200,0.95); }
        .zone-controls-btn.active { filter: brightness(1.10); }
        .zone-controls { display:none; margin: 0 0 12px; }
        .zone-controls.open { display:block; }

        .zone-mode-row { display:flex; justify-content:flex-end; gap: 10px; flex-wrap: wrap; margin: 6px 0 10px; }
        .zone-mode-row .mini-btn { padding: 8px 10px; font-size: 11px; border-radius: 10px; }
        .zone-mode-btn { border-color: rgba(255,255,255,0.12); background: rgba(255,255,255,0.06); color: rgba(233,238,247,0.92); box-shadow: 0 12px 22px rgba(0,0,0,0.20); }
        .zone-mode-btn:hover { filter: brightness(1.04); }
        .zone-mode-btn.active { filter: brightness(1.08); border-color: rgba(255,255,255,0.18); }
        .zone-mode-btn.zone-mode-day { background: linear-gradient(180deg, rgba(34,197,94,0.26), rgba(15,23,42,0.70)); border-color: rgba(34,197,94,0.25); }
        .zone-mode-btn.zone-mode-month { background: linear-gradient(180deg, rgba(59,130,246,0.26), rgba(15,23,42,0.70)); border-color: rgba(59,130,246,0.25); }
        .zone-mode-btn.zone-mode-year { background: linear-gradient(180deg, rgba(167,139,250,0.26), rgba(15,23,42,0.70)); border-color: rgba(167,139,250,0.25); }

        .sensor-meta { margin-top: 6px; margin-bottom: 8px; display:flex; flex-direction: column; gap: 4px; }
        .sensor-meta-top { display:flex; align-items: center; justify-content: space-between; gap: 8px; }
        .sensor-meta-name { font-size: 11px; color: #33cc33; font-weight: 900; overflow:hidden; text-overflow: ellipsis; white-space: nowrap; text-shadow: 0 0 14px rgba(51,204,51,0.18); }
        .sensor-meta-avg, .sensor-meta-last { font-size: 11px; color: rgba(255,255,255,0.92); font-weight: 900; overflow:hidden; text-overflow: ellipsis; white-space: nowrap; }
        .meta-label { color: rgba(255,255,255,0.92); font-weight: 900; }
        .meta-value { color: #33cc33; font-weight: 900; text-shadow: 0 0 16px rgba(51,204,51,0.20); }
        .meta-muted { color: rgba(233,238,247,0.60); text-shadow: none; }
        .sensor-card.card-off .meta-value { color: rgba(233,238,247,0.55); text-shadow: none; }

        .sensor-card .chart-wrap { position: relative; }
        .sensor-card.card-off .chart-wrap::after {
            content: "APAGADA";
            position: absolute;
            inset: 0;
            display: grid;
            place-items: center;
            color: rgba(233,238,247,0.50);
            font-weight: 900;
            letter-spacing: .14em;
            font-size: 11px;
            text-transform: uppercase;
            pointer-events: none;
        }
        .zone-row { display:flex; gap: 10px; flex-wrap: wrap; align-items: center; margin-bottom: 12px; }
        .zone-row .control-row { margin-bottom: 0; flex: 1 1 320px; }
        .zone-mini { font-size: 11px; color:#8fa3bf; }
        .mini-btn.tiny { padding: 6px 10px; font-size: 11px; border-radius: 10px; box-shadow: 0 10px 22px rgba(0,0,0,0.18); }
        .sensor-value.small { font-size: 16px; color: #e9eef7; font-weight: 800; word-break: break-word; }
        .valve-indicator { display: flex; align-items: center; justify-content: center; gap: 10px; margin-top: 8px; flex-wrap: wrap; }
        .valve-dot { width: 14px; height: 14px; border-radius: 999px; background: radial-gradient(circle at 30% 30%, rgba(148,163,184,1), rgba(71,85,105,1)); box-shadow: 0 10px 18px rgba(0,0,0,0.35), inset 0 0 0 2px rgba(255,255,255,0.10); position: relative; }
        .valve-dot::after { content:""; position:absolute; inset:-8px; border-radius:999px; opacity:0; transition: opacity .18s ease; }
        .valve-dot.on { background: radial-gradient(circle at 30% 30%, rgba(34,197,94,1), rgba(22,163,74,1)); }
        .valve-dot.on::after { opacity:1; background: radial-gradient(circle, rgba(34,197,94,0.28), transparent 58%); }
        .valve-dot.off { background: radial-gradient(circle at 30% 30%, rgba(239,68,68,1), rgba(185,28,28,1)); }
        .valve-dot.off::after { opacity:1; background: radial-gradient(circle, rgba(239,68,68,0.26), transparent 58%); }
        .valve-text { font-size: 14px; font-weight: bold; color: #ddd; max-width: 100%; overflow: hidden; text-overflow: ellipsis; }
        .leds-container { display: flex; justify-content: center; gap: 15px; margin: 20px 0; }
        .led { width: 40px; height: 40px; border-radius: 50%; border: 3px solid #333; transition: all 0.3s; }
        .control-row { display: flex; gap: 10px; margin-bottom: 15px; align-items: center; }
        .control-row label { flex: 1; color: #ffffff; }
        .control-row input, .control-row select { flex: 2; padding: 10px; border: none; border-radius: 6px; background: #0f3460; color: #fff; font-size: 14px; min-width: 0; }
        .control-row textarea { flex: 2; width: 100%; min-width: 0; padding: 12px; border: 1px solid rgba(255,255,255,0.12); border-radius: 14px; background: rgba(15,52,96,0.55); color: #fff; font-size: 14px; line-height: 1.4; min-height: 140px; resize: vertical; box-shadow: 0 12px 28px rgba(0,0,0,0.18); }
        .control-row input:focus, .control-row select:focus, .control-row textarea:focus { outline: 2px solid rgba(76,175,80,0.35); outline-offset: 2px; }
        .control-row.textarea-row { align-items: flex-start; }
        .control-row.textarea-row label { padding-top: 10px; }

        .cmp-controls {
            margin: 10px 0 8px;
            padding: 10px 12px;
            border-radius: 14px;
            border: 1px solid rgba(255,255,255,0.12);
            background: linear-gradient(180deg, rgba(15,52,96,0.72), rgba(12,35,70,0.55));
            box-shadow: 0 14px 30px rgba(0,0,0,0.20), inset 0 0 0 1px rgba(255,255,255,0.04);
        }
        .cmp-controls .control-row { margin-bottom: 0; }
        .cmp-controls label { color: rgba(233,238,247,0.95); font-weight: 900; letter-spacing: .02em; }
        .cmp-controls .cmp-select {
            flex: 1;
            width: 100%;
            padding: 12px 44px 12px 12px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.14);
            background: linear-gradient(180deg, rgba(2,12,27,0.25), rgba(15,52,96,0.65));
            color: rgba(255,255,255,0.96);
            font-weight: 800;
            letter-spacing: .01em;
            box-shadow: 0 12px 26px rgba(0,0,0,0.22);
            -webkit-appearance: none;
            appearance: none;
            background-image:
                linear-gradient(45deg, transparent 50%, rgba(255,255,255,0.80) 50%),
                linear-gradient(135deg, rgba(255,255,255,0.80) 50%, transparent 50%),
                linear-gradient(to right, rgba(255,255,255,0.10), rgba(255,255,255,0.10));
            background-position:
                calc(100% - 18px) calc(50% - 4px),
                calc(100% - 12px) calc(50% - 4px),
                calc(100% - 36px) 50%;
            background-size: 6px 6px, 6px 6px, 1px 18px;
            background-repeat: no-repeat;
        }
        .cmp-controls .cmp-select:hover { filter: brightness(1.05); }
        .cmp-controls .cmp-select:focus { outline: 2px solid rgba(56,189,248,0.40); outline-offset: 2px; }

        .cmp-add-row .mini-btn.tiny {
            background: linear-gradient(180deg, rgba(255,255,255,0.10), rgba(15,23,42,0.55));
            border-color: rgba(255,255,255,0.14);
            color: rgba(233,238,247,0.92);
        }
        .cmp-add-row .mini-btn.tiny:hover { filter: brightness(1.06); }
        .control-row input[type="range"] { -webkit-appearance: none; appearance: none; height: 8px; width: 100%; background: transparent; }
        .control-row input[type="range"]:focus { outline: none; }
        .control-row input[type="range"]::-webkit-slider-runnable-track { height: 8px; border-radius: 999px; background: linear-gradient(90deg, rgba(51,204,51,0.65), rgba(51,204,51,0.20)); box-shadow: inset 0 0 0 1px rgba(255,255,255,0.10); }
        .control-row input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 20px; height: 20px; background: radial-gradient(circle at 30% 30%, rgba(51,204,51,1), rgba(22,163,74,1)); border-radius: 50%; cursor: pointer; margin-top: -6px; box-shadow: 0 10px 18px rgba(0,0,0,0.35), 0 0 0 2px rgba(255,255,255,0.12); }
        .control-row input[type="range"]::-moz-range-track { height: 8px; border-radius: 999px; background: linear-gradient(90deg, rgba(51,204,51,0.65), rgba(51,204,51,0.20)); box-shadow: inset 0 0 0 1px rgba(255,255,255,0.10); }
        .control-row input[type="range"]::-moz-range-thumb { width: 20px; height: 20px; border: 0; background: radial-gradient(circle at 30% 30%, rgba(51,204,51,1), rgba(22,163,74,1)); border-radius: 50%; cursor: pointer; box-shadow: 0 10px 18px rgba(0,0,0,0.35), 0 0 0 2px rgba(255,255,255,0.12); }
        .control-row input[type="range"]::-moz-focus-outer { border: 0; }
        .btn-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin: 15px 0; }
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 12px 10px;
            border: 1px solid var(--btn-border);
            border-radius: var(--btn-radius);
            cursor: pointer;
            font-weight: 800;
            font-size: 12px;
            letter-spacing: .02em;
            box-shadow: var(--btn-shadow);
            transition: transform 0.12s ease, box-shadow 0.18s ease, filter 0.18s ease, background 0.18s ease, border-color 0.18s ease;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        .btn:hover { transform: translateY(-1px); box-shadow: var(--btn-shadow-hover); filter: brightness(1.03); }
        .btn:active { transform: translateY(0); filter: brightness(0.98); }
        .btn:focus-visible { outline: 2px solid rgba(76,175,80,0.45); outline-offset: 2px; }
        .btn-rojo { background: linear-gradient(180deg, rgba(255,77,77,1), rgba(255,51,51,1)); color: white; border-color: rgba(255,77,77,0.35); }
        .btn-verde { background: linear-gradient(180deg, rgba(76,175,80,1), rgba(51,204,51,1)); color: white; border-color: rgba(76,175,80,0.35); }
        .btn-azul { background: linear-gradient(180deg, rgba(59,130,246,1), rgba(51,102,255,1)); color: white; border-color: rgba(59,130,246,0.35); }
        .btn-amarillo { background: linear-gradient(180deg, rgba(255,224,102,1), rgba(255,204,0,1)); color: #0b1220; border-color: rgba(255,204,0,0.35); }
        .btn-cian { background: linear-gradient(180deg, rgba(34,211,238,1), rgba(0,204,204,1)); color: #0b1220; border-color: rgba(34,211,238,0.35); }
        .btn-magenta { background: linear-gradient(180deg, rgba(217,70,239,1), rgba(204,51,204,1)); color: white; border-color: rgba(217,70,239,0.35); }
        .btn-blanco { background: linear-gradient(180deg, rgba(255,255,255,1), rgba(226,232,240,1)); color: #0b1220; border-color: rgba(255,255,255,0.35); }
        /* Botón neutro/off: estilo más moderno (glass + azul) */
        .btn-off {
            background: linear-gradient(180deg, rgba(59,130,246,0.22), rgba(15,23,42,0.70));
            color: rgba(226,232,240,0.92);
            border-color: rgba(56,189,248,0.22);
            box-shadow: 0 14px 30px rgba(0,0,0,0.22);
        }
        .btn-save { background: linear-gradient(180deg, rgba(76,175,80,1), rgba(45,183,95,1)); color: white; width: 100%; padding: 14px; font-size: 15px; margin-top: 10px; border-color: rgba(76,175,80,0.35); }
        .status { text-align: center; font-size: 12px; color: #33cc33; margin-top: 15px; }
        .status.online { color: #4CAF50; }
        .status.offline { color: #ff3333; }
        .current-color { text-align: center; padding: 10px; background: #0f3460; border-radius: 8px; margin: 10px 0; }
        .current-color span { font-weight: bold; color: #4CAF50; }
        /* Gráficas: en escritorio sin scroll; en móvil/tablet habilitamos scroll horizontal en modo DÍA */
        .charts-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
        @media (max-width: 900px) {
            .charts-grid { grid-template-columns: 1fr; }
        }
        .chart-box { text-align: left; min-width: 0; }
        .chart-wrap { position: relative; width: 100%; height: clamp(160px, 24vh, 260px); overflow: hidden; }
        .chart-inner { width: 100%; height: 100%; }
        .chart-wrap canvas { width: 100% !important; height: 100% !important; display: block; }
        .chart-inner canvas { width: 100% !important; height: 100% !important; display: block; }
        .chart-wrap.scroll-x { overflow-x: auto; overflow-y: hidden; -webkit-overflow-scrolling: touch; overscroll-behavior-x: contain; }
        .chart-wrap.scroll-x { scrollbar-color: rgba(255,255,255,0.35) rgba(255,255,255,0.08); }
        /* Las gráficas de tarjetas usan el mismo tamaño que las principales */
        .mini-chart-wrap { height: clamp(160px, 24vh, 260px); margin-top: 10px; }

        /* Mini-gráficas por planta: en móvil/tablet modo DÍA pueden hacer scroll horizontal. */
        .sensor-card.card-off .chart-wrap { opacity: 0.25; }
        .sensor-card.card-off .sensor-value { opacity: 0.75; }
        .btn.active { outline: 2px solid rgba(255,255,255,0.35); opacity: 0.95; }
        .summary { display:flex; justify-content:space-between; gap: 12px; flex-wrap: wrap; margin: 8px 0 0; }
        .summary .k { color: #33cc33; font-size: 11px; text-transform: uppercase; }
        .summary .v { color: #ddd; font-weight: bold; }

        /* En tarjetas con acento, que los KPIs hereden el color */
        .sensor-card.accent .summary .k { color: var(--accent); }
        .sensor-card.accent .summary .v { color: #e9eef7; }

        .hidden { display: none; }

        /* Navegación Cuenta/Dispositivos */
        .top-nav { display:flex; gap: 10px; align-items:center; flex-wrap: wrap; margin: 6px 0 12px; }
        .top-nav .spacer { flex: 1 1 auto; }
        .mini-btn.active { outline: 2px solid rgba(255,255,255,0.30); }

        body.mode-account .container > .section { display: none; }
        body.mode-account #accountSection { display: block; }
        body.mode-account #status { display:none; }

        body.mode-support .container > .section { display: none; }
        body.mode-support #supportSection { display: block; }
        body.mode-support #status { display:none; }

        .tickets-list { display:flex; flex-direction:column; gap: 8px; margin-top: 10px; }
        .ticket-item { padding: 10px; border-radius: 12px; background: rgba(15,52,96,0.35); border: 1px solid rgba(255,255,255,0.08); cursor: pointer; }
        .ticket-item:hover { background: rgba(15,52,96,0.45); }
        .ticket-title { font-weight: 800; }
        .ticket-meta { color: #8fa3bf; font-size: 12px; margin-top: 4px; }
        .messages { border: 1px solid rgba(255,255,255,0.10); border-radius: 12px; background: rgba(0,0,0,0.10); padding: 10px; max-height: 320px; overflow:auto; }
        .msg { padding: 10px; border-radius: 12px; background: rgba(15,52,96,0.22); border: 1px solid rgba(255,255,255,0.06); margin-bottom: 8px; }
        .msg-meta { color:#8fa3bf; font-size: 12px; margin-bottom: 6px; }
        .msg-body { white-space: pre-wrap; }

        /* Selector de canales (más moderno) */
        .channel-cards { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin: 10px 0 6px; }
        @media (max-width: 900px) { .channel-cards { grid-template-columns: 1fr; } }
        .channel-card { --accent: #60a5fa; --accent-soft: rgba(96,165,250,0.18); background: rgba(15,52,96,0.35); border: 1px solid rgba(255,255,255,0.08); border-radius: 12px; padding: 12px; min-width: 0; }
        .channel-card.accent { position: relative; overflow: hidden; border-color: rgba(255,255,255,0.10); box-shadow: 0 12px 28px rgba(0,0,0,0.22), inset 0 0 0 1px var(--accent-soft); }
        .channel-card.accent::before {
            content: "";
            position: absolute;
            inset: -120px -160px auto auto;
            width: 260px;
            height: 260px;
            background: radial-gradient(circle, var(--accent-soft), transparent 62%);
            transform: rotate(18deg);
            pointer-events: none;
        }
        .channel-card.accent::after {
            content: "";
            position: absolute;
            left: 12px;
            right: 12px;
            top: 10px;
            height: 3px;
            border-radius: 999px;
            background: linear-gradient(90deg, transparent, var(--accent), transparent);
            opacity: 0.60;
            pointer-events: none;
        }
        .channel-card.accent .sensor-label { opacity: 0.96; }
        .channel-title { display:flex; align-items:center; justify-content:space-between; gap: 10px; margin-bottom: 8px; }
        .channel-title .sensor-label { margin-bottom: 0; }
        .channel-actions { display:flex; gap: 8px; margin-top: 8px; flex-wrap: wrap; }
        .channel-card select { width: 100%; }

        .mini-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            background: linear-gradient(180deg, rgba(59,130,246,0.22), rgba(34,211,238,0.10));
            border: 1px solid rgba(56,189,248,0.20);
            color: #e9eef7;
            padding: 8px 12px;
            border-radius: var(--btn-radius);
            cursor: pointer;
            font-size: 12px;
            font-weight: 800;
            letter-spacing: .02em;
            box-shadow: 0 12px 26px rgba(0,0,0,0.20);
            transition: transform 0.12s ease, box-shadow 0.18s ease, filter 0.18s ease, background 0.18s ease, border-color 0.18s ease;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        .mini-btn:hover { transform: translateY(-1px); box-shadow: 0 16px 34px rgba(0,0,0,0.28); filter: brightness(1.04); }
        .mini-btn:active { transform: translateY(0); filter: brightness(0.98); }
        .mini-btn:focus-visible { outline: 2px solid rgba(76,175,80,0.45); outline-offset: 2px; }
        .mini-btn.danger { border-color: rgba(255,77,77,0.35); color: #ffd1d1; background: linear-gradient(180deg, rgba(255,77,77,0.18), rgba(255,255,255,0.06)); }
        .mini-btn.primary { border-color: rgba(76,175,80,0.40); color: #d7ffe0; background: linear-gradient(180deg, rgba(76,175,80,0.22), rgba(255,255,255,0.06)); }
        .mini-btn:disabled {
            cursor: not-allowed;
            opacity: 0.72;
            filter: grayscale(0.15);
            background: linear-gradient(180deg, rgba(148,163,184,0.14), rgba(15,23,42,0.55));
            border-color: rgba(148,163,184,0.18);
            box-shadow: 0 10px 22px rgba(0,0,0,0.16);
        }
        .badge { display:inline-flex; align-items:center; justify-content:center; min-width: 18px; height: 18px; padding: 0 6px; border-radius: 999px; font-size: 11px; font-weight: 900; background: rgba(239,68,68,0.95); color: #fff; margin-left: 8px; border: 1px solid rgba(255,255,255,0.20); }
        .badge.hidden { display:none; }

        .conn { display: inline-flex; align-items: center; gap: 8px; margin-top: 6px; font-size: 12px; color: #c9d1d9; opacity: 0.95; }
        .dot { width: 10px; height: 10px; border-radius: 999px; background: #6b7280; position: relative; box-shadow: 0 0 0 2px rgba(255,255,255,0.10) inset, 0 6px 14px rgba(0,0,0,0.35); }
        .dot::after { content:""; position:absolute; inset:-6px; border-radius:999px; opacity:0; background: radial-gradient(circle, rgba(34,197,94,0.22), transparent 55%); transition: opacity .18s ease; }
        .dot.online { background: radial-gradient(circle at 30% 30%, rgba(34,197,94,1), rgba(22,163,74,1)); }
        .dot.offline { background: radial-gradient(circle at 30% 30%, rgba(239,68,68,1), rgba(185,28,28,1)); }
        .dot.unknown { background: radial-gradient(circle at 30% 30%, rgba(148,163,184,1), rgba(71,85,105,1)); }
        .dot.online::after { opacity: 1; }

        /* Secciones plegables */
        .section-head { display:flex; align-items:center; justify-content:space-between; gap: 10px; }
        .collapse-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            background: linear-gradient(180deg, rgba(255,255,255,0.10), rgba(255,255,255,0.06));
            border: 1px solid var(--btn-border);
            color: #e9eef7;
            padding: 7px 10px;
            border-radius: var(--btn-radius);
            cursor: pointer;
            font-size: 12px;
            font-weight: 800;
            letter-spacing: .02em;
            box-shadow: 0 12px 26px rgba(0,0,0,0.20);
            transition: transform 0.12s ease, box-shadow 0.18s ease, filter 0.18s ease, background 0.18s ease, border-color 0.18s ease;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        .collapse-btn:hover { transform: translateY(-1px); box-shadow: 0 16px 34px rgba(0,0,0,0.28); filter: brightness(1.04); }
        .collapse-btn:active { transform: translateY(0); filter: brightness(0.98); }
        .collapse-btn:focus-visible { outline: 2px solid rgba(76,175,80,0.45); outline-offset: 2px; }
        .section.collapsed .section-body { display:none; }

        /* Compacto en móvil */
        @media (max-width: 640px) {
            body { padding: 10px; }
            .section { padding: 14px; margin-bottom: 14px; }
            #deviceSection { top: auto; }
            .sensor-grid { grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 10px; }
            .sensor-card { padding: 12px; }
            .btn-grid { grid-template-columns: repeat(2, 1fr); }
            .device-actions { grid-template-columns: repeat(2, minmax(0, 1fr)); }
            /* Zonas: evitar overflow horizontal en móvil */
            .zone-row { gap: 8px; }
            .zone-row .control-row { flex: 1 1 100%; }
            .zone-subtitle { font-size: 11px; line-height: 1.35; }

            /* Controles: label arriba, control abajo */
            .zone-row .control-row { flex-wrap: wrap; }
            .zone-row .control-row label { flex: 0 0 100%; }
            .zone-row .control-row input,
            .zone-row .control-row select { flex: 1 1 100%; width: 100%; }
        }

        /* Zonas: en escritorio, 1 tarjeta por fila (full width) */
        @media (min-width: 900px) {
            #zonesContainer .sensor-grid { grid-template-columns: 1fr; }
        }

        /* Acciones del bloque DISPOSITIVO: 2 por fila en móvil, 4 en desktop */
        .device-actions { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 10px; margin-top: 10px; }
        @media (min-width: 900px) { .device-actions { grid-template-columns: repeat(4, minmax(0, 1fr)); } }
        .device-actions .mini-btn { width: 100%; justify-content: center; }

        /* Iconos en tarjetas (DISPOSITIVO CONECTADO): centrados arriba, sobre la línea de acento */
        #connectedSection .sensor-card .card-ico { position: absolute; left: 50%; right: auto; top: 10px; transform: translateX(-50%); width: 22px; height: 22px; color: var(--accent); opacity: 0.92; filter: drop-shadow(0 0 14px var(--accent-soft)); pointer-events: none; }
        .sensor-card .card-ico svg { width: 100%; height: 100%; display: block; }

        /* Botón renombrar en selects de plantas */
        .zone-rename-btn { flex: 0 0 auto; }
        @media (max-width: 640px) { .zone-rename-btn { width: 100%; } }

        /* Modal ligero (selector de tipo de sensor) */
        .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.55); display:flex; align-items:center; justify-content:center; padding: 16px; z-index: 2200; }
        .modal { width: min(520px, 100%); background: rgba(22,33,62,0.98); border: 1px solid rgba(255,255,255,0.10); border-radius: 14px; padding: 14px; box-shadow: 0 24px 70px rgba(0,0,0,0.55); }
        .modal-title { font-weight: 900; letter-spacing: .02em; margin-bottom: 10px; color:#e9eef7; }
        .choice-grid { display:grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 10px; }
        @media (max-width: 360px) { .choice-grid { grid-template-columns: 1fr; } }
        .modal-actions { display:flex; justify-content:flex-end; gap: 10px; margin-top: 12px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="brand-header">
            <img
                            src="/logo-wide.png?v=20260128r2"
                            srcset="/logo-wide.png?v=20260128r2 1x, /logo-wide@2x.png?v=20260128r2 2x"
              alt="AgroSense"
              onerror="this.style.display='none'"
            />
        </div>
        <div class="status" style="margin-bottom: 12px;">UI vRt1548F</div>

        <div class="top-nav">
            <button class="mini-btn active" id="navDevices" type="button">Dispositivos</button>
            <button class="mini-btn" id="navAccount" type="button">Cuenta</button>
                <button class="mini-btn" id="navSupport" type="button">Soporte <span class="badge hidden" id="supportBadge">0</span></button>
            <span class="spacer"></span>
            <button class="mini-btn danger" id="navLogout" type="button">Salir</button>
        </div>

        <div class="section hidden" id="accountSection">
            <h2> CUENTA</h2>
            <div class="status" id="accountStatus">—</div>
            <div class="control-row"><label>Email:</label><input id="accEmail" type="email" disabled /></div>
            <div class="control-row"><label>Nombre:</label><input id="accFullName" type="text" placeholder="Nombre y apellidos" /></div>
            <div class="control-row"><label>Teléfono:</label><input id="accPhone" type="tel" placeholder="Teléfono" /></div>
            <div class="control-row"><label>Dirección:</label><input id="accAddress" type="text" placeholder="Calle, número, etc." /></div>
            <div class="control-row"><label>Provincia:</label><input id="accProvince" type="text" placeholder="Provincia" /></div>
            <div class="control-row"><label>Ciudad:</label><input id="accCity" type="text" placeholder="Ciudad" /></div>
            <div class="control-row"><label>País:</label><input id="accCountry" type="text" placeholder="País" /></div>
            <div style="display:flex; gap: 10px; flex-wrap: wrap; margin-top: 10px;">
                <button class="mini-btn primary" id="btnSaveProfile" type="button">Guardar</button>
                <button class="mini-btn danger" id="btnDeleteAccount" type="button">Eliminar cuenta</button>
            </div>
            <div class="muted" style="margin-top:10px; font-size:12px; color:#8fa3bf; line-height:1.35;">
                Eliminar cuenta borra tu usuario y desvincula tus dispositivos.
            </div>
        </div>

        <div class="section hidden" id="supportSection">
            <h2> SOPORTE (TICKETS)</h2>
            <div class="status" id="supportStatus">—</div>

            <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.08);"></div>
            <h2 style="margin-top: 10px;"> ABRIR TICKET</h2>
            <div class="control-row"><label>Asunto:</label><input id="tSubject" type="text" placeholder="Ej: No riega / sensor falla" /></div>
            <div class="control-row"><label>Dispositivo (opcional):</label>
                <select id="tDevice" title="Dispositivo (opcional)">
                    <option value="">(sin dispositivo)</option>
                </select>
            </div>
            <div class="control-row textarea-row"><label>Mensaje:</label><textarea id="tMessage" placeholder="Describe el problema..."></textarea></div>
            <button class="btn btn-save" id="btnCreateTicket" type="button">ENVIAR TICKET</button>

            <div style="margin-top: 16px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.08);"></div>
            <h2 style="margin-top: 10px;"> MIS TICKETS</h2>
            <div class="tickets-list" id="ticketsList"></div>

            <div style="margin-top: 16px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.08);"></div>
            <h2 style="margin-top: 10px;"> DETALLE</h2>
            <div class="control-row"><label>ID:</label><input id="tId" type="text" disabled /></div>
            <div class="control-row"><label>Estado:</label><input id="tStatus" type="text" disabled /></div>
            <div class="control-row"><label>Mensajes:</label><div id="tMessages" class="messages" style="flex:2;"></div></div>
            <div class="control-row textarea-row"><label>Responder:</label><textarea id="tReply" placeholder="Añade más información..."></textarea></div>
            <div style="display:flex; gap: 10px; flex-wrap: wrap; margin-top: 10px;">
                <button class="mini-btn primary" id="btnReplyTicket" type="button">Enviar respuesta</button>
                <button class="mini-btn danger" id="btnCloseTicket" type="button">Cerrar ticket</button>
            </div>
        </div>

        <div class="section" id="deviceSection" style="padding: 14px 20px;">
            <h2> DISPOSITIVO</h2>
            <div class="control-row" style="margin-bottom: 0;">
                <label>Seleccionar:</label>
                <select id="deviceSelect" title="Seleccionar dispositivo"></select>
            </div>
            <div class="device-actions">
                <button class="mini-btn primary" id="btnAddDevice" type="button">+ Añadir dispositivo</button>
                <button class="mini-btn danger" id="btnDeleteDevice" type="button" title="Quitar este dispositivo de tu cuenta">Eliminar dispositivo</button>
                <button class="mini-btn" id="btnAddValve" type="button">+ Añadir válvula</button>
                <button class="mini-btn" id="btnAddSensor" type="button">AÑADIR SENSOR</button>
            </div>
            <div class="status" style="margin-top: 10px;" id="deviceMeta">--</div>

            <div class="topbar-mini">
                <div class="right">
                    <span class="pill" title="Conexión del dispositivo">
                        <span class="dot unknown" id="topConnDot"></span>
                        <span id="topConnText">--</span>
                    </span>
                    <span class="pill" id="topStatusText">Conectando...</span>
                </div>
            </div>
            <!-- Mantener el ID para compatibilidad (JS lo actualiza si existe), pero oculto -->
            <span class="hidden" id="topNowEs">--</span>
        </div>
        <div class="section" id="connectedSection">
            <h2> DISPOSITIVO CONECTADO</h2>
            <div class="sensor-grid">
                <div class="sensor-card metric-neutral accent accent-green">
                    <div class="card-ico" aria-hidden="true">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <rect x="4" y="5" width="16" height="11" rx="2" />
                            <path d="M9 19h6" />
                            <path d="M12 16v3" />
                        </svg>
                    </div>
                    <div class="sensor-label">Pantalla (tiempo real)</div>
                    <div class="chips" id="oledMeta"></div>
                    <div class="oled-panel" id="oledPanel">--</div>
                </div>
                <div class="sensor-card metric-neutral accent accent-cyan">
                    <div class="card-ico" aria-hidden="true">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M7 7h10" />
                            <path d="M7 12h10" />
                            <path d="M7 17h10" />
                            <circle cx="5" cy="7" r="1" />
                            <circle cx="5" cy="12" r="1" />
                            <circle cx="5" cy="17" r="1" />
                        </svg>
                    </div>
                    <div class="sensor-label">Sensores / Válvulas (activos)</div>
                    <div class="sensor-value small" id="uptime">--</div>
                    <div class="chips" id="uptimeMeta"></div>
                </div>
                <div class="sensor-card metric-neutral accent accent-blue">
                    <div class="card-ico" aria-hidden="true">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M4 12a8 8 0 0 1 16 0" />
                            <path d="M6 12a6 6 0 0 1 12 0" />
                            <path d="M8 12a4 4 0 0 1 8 0" />
                            <circle cx="12" cy="16" r="1" />
                        </svg>
                    </div>
                    <div class="sensor-label">IP</div>
                    <div class="sensor-value small" id="ip">--</div>
                    <div class="chips" id="ipMeta"></div>
                </div>
                <div class="sensor-card metric-neutral accent accent-purple">
                    <div class="card-ico" aria-hidden="true">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <rect x="7" y="7" width="10" height="10" rx="2" />
                            <path d="M9 3v3M15 3v3M9 18v3M15 18v3" />
                            <path d="M3 9h3M3 15h3M18 9h3M18 15h3" />
                        </svg>
                    </div>
                    <div class="sensor-label">Memoria </div>
                    <div class="sensor-value" id="heap">--</div>
                    <div class="chips" id="heapMeta"></div>
                </div>
                <div class="sensor-card accent accent-amber">
                    <div class="card-ico" aria-hidden="true">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M13 2L4 14h7l-1 8 10-14h-7z" />
                        </svg>
                    </div>
                    <div class="sensor-label">Voltaje</div>
                    <div class="sensor-value" id="voltage">--</div>
                    <div class="chips" id="voltageMeta"></div>
                </div>
                <div class="sensor-card accent accent-indigo">
                    <div class="card-ico" aria-hidden="true">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M5 12.5a10 10 0 0 1 14 0" />
                            <path d="M8 15.5a6 6 0 0 1 8 0" />
                            <path d="M11 18.5a2 2 0 0 1 2 0" />
                        </svg>
                    </div>
                    <div class="sensor-label">WiFi</div>
                    <div class="sensor-value" id="rssi">--</div>
                    <div class="chips" id="wifiMeta"></div>
                </div>
                <div class="sensor-card accent accent-red">
                    <div class="card-ico" aria-hidden="true">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21 12a9 9 0 1 1-3-6.7" />
                            <path d="M21 3v6h-6" />
                        </svg>
                    </div>
                    <div class="sensor-label">Reinicios</div>
                    <div class="sensor-value" id="reboots">--</div>
                    <div class="chips" id="rebootsMeta"></div>
                    <div style="margin-top: 10px;">
                        <button class="mini-btn danger" id="resetRebootsBtn" type="button">Reset a 0</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="section" id="zonesSection">
            <h2> PLANTAS (1–8)</h2>
            <div class="muted" style="margin-top: -6px; margin-bottom: 10px; font-size:12px; color:#8fa3bf; line-height:1.35;">
                Configura cada planta con su sensor de humedad, su válvula y su umbral.
                Si un sensor/válvula no está enviando datos, la zona se verá “apagada”.
            </div>
            <div id="zonesContainer"></div>
        </div>

        <div class="section">
            <h2> COMPARADOR DE GRÁFICAS</h2>
            <div style="display:flex; align-items:center; justify-content:space-between; gap: 12px; flex-wrap: wrap; margin: 4px 0 8px;">
                <div>
                    <div class="sensor-label">FECHA / HORA </div>
                    <div style="font-size: 18px; font-weight: bold; color: #ddd;" id="nowEs">--</div>
                    <div class="conn" title="Conexión del dispositivo">
                        <span class="dot unknown" id="connDot"></span>
                        <span id="connText">--</span>
                    </div>
                </div>
                <div style="display:flex; gap: 10px; align-items:center; flex-wrap: wrap; justify-content:flex-end;">
                    <button class="btn btn-azul" id="btnDia" type="button">DÍA</button>
                    <button class="btn btn-azul" id="btnMes" type="button">MES</button>
                    <button class="btn btn-azul" id="btnAno" type="button">AÑO</button>
                </div>
            </div>

            <div class="channel-cards">
                <div class="channel-card accent accent-green">
                    <div class="channel-title">
                        <div class="sensor-label">Sensor de humedad (gráfica)</div>
                    </div>
                    <select id="humChannelSelect" title="Seleccionar sensor de humedad"></select>
                    <div class="channel-actions">
                        <button class="mini-btn" id="btnRenameHum" type="button">Renombrar</button>
                        <button class="mini-btn danger" id="btnDeleteHum" type="button" title="Eliminar sensores añadidos">Eliminar</button>
                    </div>
                </div>
                <div class="channel-card accent accent-red">
                    <div class="channel-title">
                        <div class="sensor-label">Válvula (gráfica)</div>
                    </div>
                    <select id="valveChannelSelect" title="Seleccionar válvula"></select>
                    <div class="channel-actions">
                        <button class="mini-btn" id="btnRenameValve" type="button">Renombrar</button>
                        <button class="mini-btn danger" id="btnDeleteValve" type="button" title="Eliminar válvulas añadidas">Eliminar</button>
                    </div>
                </div>
            </div>
            <!-- Mantener estos IDs para que el JS pueda actualizar el periodo, pero sin mostrarlo en la UI -->
            <div class="hidden">
                <div class="k" id="periodLabel">Periodo</div>
                <div class="v" id="periodValue">--</div>
            </div>
            <div class="charts-grid">
                <div class="sensor-card chart-box accent accent-green">
                    <div class="sensor-label">Humedad del suelo (%)</div>
                    <div class="sensor-meta">
                        <div class="sensor-meta-top">
                            <div class="sensor-meta-avg" id="avgHumidity"><span class="meta-label">Media:</span> <span class="meta-value" data-role="value">--</span></div>
                            <div class="sensor-meta-last" id="lastPoint"><span class="meta-label">Actualizado:</span> <span class="meta-value" data-role="value">--</span></div>
                        </div>
                    </div>
                    <div class="chart-wrap">
                        <canvas id="humChart"></canvas>
                    </div>
                </div>
                <div class="sensor-card chart-box accent accent-red">
                    <div class="sensor-label">Válvula (ON/OFF) + tiempo activa</div>
                    <div class="sensor-meta" style="margin-top: 6px;">
                        <div class="sensor-meta-top">
                            <div class="valve-indicator" style="margin-top: 0; justify-content:flex-start;">
                                <div class="valve-dot" id="valveDotChart"></div>
                                <div class="valve-text" id="valveTextChart">--</div>
                            </div>
                            <div class="sensor-meta-avg" id="valveOnTime"><span class="meta-label">Tiempo ON:</span> <span class="meta-value" data-role="value">--</span></div>
                        </div>
                    </div>
                    <div class="chart-wrap">
                        <canvas id="valveChart"></canvas>
                    </div>
                </div>

                <div class="sensor-card chart-box accent accent-indigo" id="cmpBox3" style="display:none;">
                    <div style="display:flex; justify-content:space-between; align-items:center; gap: 10px;">
                        <div class="sensor-label" id="cmpTitle3">Comparación 3</div>
                        <button class="mini-btn tiny danger" id="cmpRemove3" type="button">Quitar</button>
                    </div>
                    <div class="cmp-controls">
                        <div class="control-row" style="margin: 0 0 8px;">
                            <label style="flex: 0 0 auto; min-width: 64px;">Planta:</label>
                            <select class="cmp-select" id="cmpZoneSelect3" title="Filtrar por planta"></select>
                        </div>
                        <div class="control-row" style="margin: 0;">
                            <label style="flex: 0 0 auto; min-width: 64px;">Sensor:</label>
                            <select class="cmp-select" id="cmpChannelSelect3" title="Seleccionar canal para comparar"></select>
                        </div>
                    </div>
                    <div class="chart-wrap">
                        <canvas id="cmpChart3"></canvas>
                    </div>
                </div>

                <div class="sensor-card chart-box accent accent-purple" id="cmpBox4" style="display:none;">
                    <div style="display:flex; justify-content:space-between; align-items:center; gap: 10px;">
                        <div class="sensor-label" id="cmpTitle4">Comparación 4</div>
                        <button class="mini-btn tiny danger" id="cmpRemove4" type="button">Quitar</button>
                    </div>
                    <div class="cmp-controls">
                        <div class="control-row" style="margin: 0 0 8px;">
                            <label style="flex: 0 0 auto; min-width: 64px;">Planta:</label>
                            <select class="cmp-select" id="cmpZoneSelect4" title="Filtrar por planta"></select>
                        </div>
                        <div class="control-row" style="margin: 0;">
                            <label style="flex: 0 0 auto; min-width: 64px;">Sensor:</label>
                            <select class="cmp-select" id="cmpChannelSelect4" title="Seleccionar canal para comparar"></select>
                        </div>
                    </div>
                    <div class="chart-wrap">
                        <canvas id="cmpChart4"></canvas>
                    </div>
                </div>

                <div class="sensor-card chart-box accent accent-cyan" id="cmpBox5" style="display:none;">
                    <div style="display:flex; justify-content:space-between; align-items:center; gap: 10px;">
                        <div class="sensor-label" id="cmpTitle5">Comparación 5</div>
                        <button class="mini-btn tiny danger" id="cmpRemove5" type="button">Quitar</button>
                    </div>
                    <div class="cmp-controls">
                        <div class="control-row" style="margin: 0 0 8px;">
                            <label style="flex: 0 0 auto; min-width: 64px;">Planta:</label>
                            <select class="cmp-select" id="cmpZoneSelect5" title="Filtrar por planta"></select>
                        </div>
                        <div class="control-row" style="margin: 0;">
                            <label style="flex: 0 0 auto; min-width: 64px;">Sensor:</label>
                            <select class="cmp-select" id="cmpChannelSelect5" title="Seleccionar canal para comparar"></select>
                        </div>
                    </div>
                    <div class="chart-wrap">
                        <canvas id="cmpChart5"></canvas>
                    </div>
                </div>

                <div class="sensor-card chart-box accent accent-yellow" id="cmpBox6" style="display:none;">
                    <div style="display:flex; justify-content:space-between; align-items:center; gap: 10px;">
                        <div class="sensor-label" id="cmpTitle6">Comparación 6</div>
                        <button class="mini-btn tiny danger" id="cmpRemove6" type="button">Quitar</button>
                    </div>
                    <div class="cmp-controls">
                        <div class="control-row" style="margin: 0 0 8px;">
                            <label style="flex: 0 0 auto; min-width: 64px;">Planta:</label>
                            <select class="cmp-select" id="cmpZoneSelect6" title="Filtrar por planta"></select>
                        </div>
                        <div class="control-row" style="margin: 0;">
                            <label style="flex: 0 0 auto; min-width: 64px;">Sensor:</label>
                            <select class="cmp-select" id="cmpChannelSelect6" title="Seleccionar canal para comparar"></select>
                        </div>
                    </div>
                    <div class="chart-wrap">
                        <canvas id="cmpChart6"></canvas>
                    </div>
                </div>

                <div class="sensor-card chart-box accent accent-pink" id="cmpBox7" style="display:none;">
                    <div style="display:flex; justify-content:space-between; align-items:center; gap: 10px;">
                        <div class="sensor-label" id="cmpTitle7">Comparación 7</div>
                        <button class="mini-btn tiny danger" id="cmpRemove7" type="button">Quitar</button>
                    </div>
                    <div class="cmp-controls">
                        <div class="control-row" style="margin: 0 0 8px;">
                            <label style="flex: 0 0 auto; min-width: 64px;">Planta:</label>
                            <select class="cmp-select" id="cmpZoneSelect7" title="Filtrar por planta"></select>
                        </div>
                        <div class="control-row" style="margin: 0;">
                            <label style="flex: 0 0 auto; min-width: 64px;">Sensor:</label>
                            <select class="cmp-select" id="cmpChannelSelect7" title="Seleccionar canal para comparar"></select>
                        </div>
                    </div>
                    <div class="chart-wrap">
                        <canvas id="cmpChart7"></canvas>
                    </div>
                </div>

                <div class="sensor-card chart-box accent accent-orange" id="cmpBox8" style="display:none;">
                    <div style="display:flex; justify-content:space-between; align-items:center; gap: 10px;">
                        <div class="sensor-label" id="cmpTitle8">Comparación 8</div>
                        <button class="mini-btn tiny danger" id="cmpRemove8" type="button">Quitar</button>
                    </div>
                    <div class="cmp-controls">
                        <div class="control-row" style="margin: 0 0 8px;">
                            <label style="flex: 0 0 auto; min-width: 64px;">Planta:</label>
                            <select class="cmp-select" id="cmpZoneSelect8" title="Filtrar por planta"></select>
                        </div>
                        <div class="control-row" style="margin: 0;">
                            <label style="flex: 0 0 auto; min-width: 64px;">Sensor:</label>
                            <select class="cmp-select" id="cmpChannelSelect8" title="Seleccionar canal para comparar"></select>
                        </div>
                    </div>
                    <div class="chart-wrap">
                        <canvas id="cmpChart8"></canvas>
                    </div>
                </div>
            </div>

            <div class="cmp-add-row" style="display:flex; justify-content:flex-end; margin-top: 10px; gap: 10px; flex-wrap: wrap;">
                <button class="mini-btn zones-global-btn" id="cmpAddBtn" type="button">Añadir gráfica (máx 8)</button>
            </div>
        </div>

        <div class="section">
            <h2> CONFIGURACIÓN AUTOMÁTICA</h2>
            <div class="control-row">
                <label>Color si Humedad BAJA:</label>
                <select id="colorBuena" title="Color si humedad baja">
                    <option value="Rojo">Rojo</option>
                    <option value="Verde">Verde</option>
                    <option value="Azul">Azul</option>
                    <option value="Amarillo">Amarillo</option>
                    <option value="Cian">Cian</option>
                    <option value="Magenta">Magenta</option>
                    <option value="Blanco">Blanco</option>
                </select>
            </div>
            <div class="control-row">
                <label>Color si Humedad BUENA:</label>
                <select id="colorBaja" title="Color si humedad buena">
                    <option value="Rojo">Rojo</option>
                    <option value="Verde" selected>Verde</option>
                    <option value="Azul">Azul</option>
                    <option value="Amarillo">Amarillo</option>
                    <option value="Cian">Cian</option>
                    <option value="Magenta">Magenta</option>
                    <option value="Blanco">Blanco</option>
                </select>
            </div>
            <div class="control-row">
                <label>Calibración WET_V (V):</label>
                <input id="wetV" type="number" step="0.001" placeholder="ej: 1.10" />
            </div>
            <div class="control-row">
                <label>Calibración DRY_V (V):</label>
                <input id="dryV" type="number" step="0.001" placeholder="ej: 2.60" />
            </div>
            <div class="control-row">
                <label>Alerta: Humedad baja (min):</label>
                <input id="alertHumLowMin" type="number" min="0" step="1" placeholder="0 = desactivado" />
            </div>
            <div class="control-row">
                <label>Alerta: Válvula ON máx (min):</label>
                <input id="alertValveMaxMin" type="number" min="0" step="1" placeholder="0 = desactivado" />
            </div>
            <div class="control-row">
                <label>Alerta: Sensor muerto (min):</label>
                <input id="alertDeadMin" type="number" min="0" step="1" placeholder="0 = desactivado" />
            </div>
            <div class="control-row">
                <label>Alerta: Voltaje mín (V):</label>
                <input id="alertVmin" type="number" step="0.01" placeholder="vacío = desactivado" />
            </div>
            <div class="control-row">
                <label>Alerta: Voltaje máx (V):</label>
                <input id="alertVmax" type="number" step="0.01" placeholder="vacío = desactivado" />
            </div>
            <div class="control-row">
                <label>Webhook (URL):</label>
                <input id="notifyWebhook" type="url" placeholder="https://..." />
            </div>
            <div class="control-row">
                <label>Telegram Chat ID:</label>
                <input id="notifyTelegram" type="text" placeholder="123456789" />
            </div>
            <div style="display:flex; gap: 10px; flex-wrap: wrap; margin-top: 10px;">
                <button class="mini-btn" id="btnResetDefaults" type="button">Reset a valores por defecto</button>
                <button class="btn btn-save" id="btnSaveConfig" onclick="guardar()" type="button"> GUARDAR CONFIGURACION</button>
            </div>
        </div>

        <div class="section">
            <h2> ALERTAS</h2>
            <div class="status" id="alertsStatus">--</div>
            <div id="alertsList" style="margin-top: 10px; display:flex; flex-direction:column; gap: 8px;"></div>
        </div>

        <div class="status" id="status">Conectando...</div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script>
        let config = { threshold: 25, colorB: 'Rojo', colorG: 'Verde' };

        const DEFAULT_AUTO_CONFIG = {
            wet_v: 1.10,
            dry_v: 2.60,
            alert_humidity_low_minutes: 0,
            alert_valve_on_max_minutes: 0,
            alert_sensor_dead_minutes: 0,
            alert_voltage_min: null,
            alert_voltage_max: null
        };

        function makeDefaultZones(baseThreshold) {
            const thr = Number(baseThreshold);
            const t = Number.isFinite(thr) ? Math.max(0, Math.min(100, thr)) : 25;
            // Por defecto solo dejamos asignada PLANTA 1 (si existe), el resto SIN ASIGNAR.
            // Así plantas 2..8 aparecen apagadas hasta que haya sensores/válvulas reales.
            return Array.from({ length: 8 }, (_, i) => ({
                zone: i + 1,
                soil_channel_index: i === 0 ? 1 : null,
                valve_channel_index: i === 0 ? 1 : null,
                temperature_air_channel_index: null,
                humidity_air_channel_index: null,
                temperature_soil_channel_index: null,
                ph_soil_channel_index: null,
                ec_soil_channel_index: null,
                humidity_low_threshold: t
            }));
        }

        let zonesState = makeDefaultZones(25);

        function normalizeZonesFromServer(raw, baseThreshold) {
            const out = makeDefaultZones(baseThreshold);
            const arr = Array.isArray(raw) ? raw : [];
            for (const z of arr) {
                const zone = Number(z?.zone);
                if (!Number.isInteger(zone) || zone < 1 || zone > 8) continue;
                const idx = zone - 1;

                const soilIdx = z?.soil_channel_index == null ? null : Number(z.soil_channel_index);
                const valveIdx = z?.valve_channel_index == null ? null : Number(z.valve_channel_index);
                const tAirIdx = z?.temperature_air_channel_index == null ? null : Number(z.temperature_air_channel_index);
                const hAirIdx = z?.humidity_air_channel_index == null ? null : Number(z.humidity_air_channel_index);
                const tSoilIdx = z?.temperature_soil_channel_index == null ? null : Number(z.temperature_soil_channel_index);
                const phIdx = z?.ph_soil_channel_index == null ? null : Number(z.ph_soil_channel_index);
                const ecIdx = z?.ec_soil_channel_index == null ? null : Number(z.ec_soil_channel_index);
                const thr = z?.humidity_low_threshold == null ? null : Number(z.humidity_low_threshold);

                out[idx] = {
                    zone,
                    soil_channel_index: Number.isFinite(soilIdx) ? soilIdx : null,
                    valve_channel_index: Number.isFinite(valveIdx) ? valveIdx : null,
                    temperature_air_channel_index: Number.isFinite(tAirIdx) ? tAirIdx : null,
                    humidity_air_channel_index: Number.isFinite(hAirIdx) ? hAirIdx : null,
                    temperature_soil_channel_index: Number.isFinite(tSoilIdx) ? tSoilIdx : null,
                    ph_soil_channel_index: Number.isFinite(phIdx) ? phIdx : null,
                    ec_soil_channel_index: Number.isFinite(ecIdx) ? ecIdx : null,
                    humidity_low_threshold: Number.isFinite(thr)
                        ? Math.max(0, Math.min(100, thr))
                        : out[idx].humidity_low_threshold
                };
            }
            return out;
        }

        function updateZoneSubtitles() {
            const soil = (channels || []).filter(c => c && c.kind === 'soil_sensor');
            const valves = (channels || []).filter(c => c && c.kind === 'valve');
            const tAir = (channels || []).filter(c => c && c.kind === 'temperature_air');
            const hAir = (channels || []).filter(c => c && c.kind === 'humidity_air');
            const tSoil = (channels || []).filter(c => c && c.kind === 'temperature_soil');
            const phSoil = (channels || []).filter(c => c && c.kind === 'ph_soil');
            const ecSoil = (channels || []).filter(c => c && c.kind === 'ec_soil');
            const findName = (arr, idx) => {
                const n = Number(idx);
                const c = arr.find(x => Number(x.channel_index) === n);
                return c ? c.name : null;
            };

            for (let i = 0; i < 8; i++) {
                const zoneNum = i + 1;
                const el = document.getElementById(`zoneSubtitle${zoneNum}`);
                if (!el) continue;
                const z = zonesState[i];
                const sName = z.soil_channel_index == null ? null : findName(soil, z.soil_channel_index);
                const vName = z.valve_channel_index == null ? null : findName(valves, z.valve_channel_index);
                const sTxt = z.soil_channel_index == null ? 'Sensor: (sin asignar)' : `Sensor: ${sName || '—'} (${z.soil_channel_index})`;
                const vTxt = z.valve_channel_index == null ? 'Válvula: (sin asignar)' : `Válvula: ${vName || '—'} (${z.valve_channel_index})`;

                const extraParts = [];
                if (z.temperature_air_channel_index != null) {
                    const nm = findName(tAir, z.temperature_air_channel_index);
                    extraParts.push(`TA: ${nm || '—'} (${z.temperature_air_channel_index})`);
                }
                if (z.humidity_air_channel_index != null) {
                    const nm = findName(hAir, z.humidity_air_channel_index);
                    extraParts.push(`HA: ${nm || '—'} (${z.humidity_air_channel_index})`);
                }
                if (z.temperature_soil_channel_index != null) {
                    const nm = findName(tSoil, z.temperature_soil_channel_index);
                    extraParts.push(`TS: ${nm || '—'} (${z.temperature_soil_channel_index})`);
                }
                if (z.ph_soil_channel_index != null) {
                    const nm = findName(phSoil, z.ph_soil_channel_index);
                    extraParts.push(`pH: ${nm || '—'} (${z.ph_soil_channel_index})`);
                }
                if (z.ec_soil_channel_index != null) {
                    const nm = findName(ecSoil, z.ec_soil_channel_index);
                    extraParts.push(`EC: ${nm || '—'} (${z.ec_soil_channel_index})`);
                }

                const thrTxt = `Umbral: ${Math.round(Number(z.humidity_low_threshold ?? 25))}%`;
                el.textContent = [sTxt, vTxt, ...extraParts, thrTxt].join(' · ');
            }
        }

        function renderZonesUI() {
            const container = document.getElementById('zonesContainer');
            if (!container) return;

            const soil = (channels || [])
                .filter(c => c && c.kind === 'soil_sensor')
                .slice()
                .sort((a, b) => Number(a.channel_index) - Number(b.channel_index));
            const valves = (channels || [])
                .filter(c => c && c.kind === 'valve')
                .slice()
                .sort((a, b) => Number(a.channel_index) - Number(b.channel_index));
            const tAir = (channels || [])
                .filter(c => c && c.kind === 'temperature_air')
                .slice()
                .sort((a, b) => Number(a.channel_index) - Number(b.channel_index));
            const hAir = (channels || [])
                .filter(c => c && c.kind === 'humidity_air')
                .slice()
                .sort((a, b) => Number(a.channel_index) - Number(b.channel_index));
            const tSoil = (channels || [])
                .filter(c => c && c.kind === 'temperature_soil')
                .slice()
                .sort((a, b) => Number(a.channel_index) - Number(b.channel_index));
            const phSoil = (channels || [])
                .filter(c => c && c.kind === 'ph_soil')
                .slice()
                .sort((a, b) => Number(a.channel_index) - Number(b.channel_index));
            const ecSoil = (channels || [])
                .filter(c => c && c.kind === 'ec_soil')
                .slice()
                .sort((a, b) => Number(a.channel_index) - Number(b.channel_index));

            // Importante: NO auto-asignar plantas 2..8.
            // Solo intentamos auto-asignar PLANTA 1 si está sin asignar.
            try {
                const z0 = zonesState?.[0];
                if (z0) {
                    if (z0.soil_channel_index == null && soil.some(x => Number(x.channel_index) === 1)) z0.soil_channel_index = 1;
                    if (z0.valve_channel_index == null && valves.some(x => Number(x.channel_index) === 1)) z0.valve_channel_index = 1;
                }
            } catch {}

            function usedSetFor(kind, excludeIdx) {
                const ZONE_PROP_BY_KIND = {
                    soil: 'soil_channel_index',
                    valve: 'valve_channel_index',
                    temperature_air: 'temperature_air_channel_index',
                    humidity_air: 'humidity_air_channel_index',
                    temperature_soil: 'temperature_soil_channel_index',
                    ph_soil: 'ph_soil_channel_index',
                    ec_soil: 'ec_soil_channel_index'
                };

                const prop = ZONE_PROP_BY_KIND[kind];
                if (!prop) return new Set();
                const s = new Set();
                for (let i = 0; i < 8; i++) {
                    if (i === excludeIdx) continue;
                    const z = zonesState[i];
                    if (!z) continue;
                    const v = z[prop];
                    if (v == null) continue;
                    const n = Number(v);
                    if (Number.isFinite(n)) s.add(n);
                }
                return s;
            }

            const isAnyAssigned = (z) => {
                if (!z) return false;
                return (
                    z.soil_channel_index != null ||
                    z.valve_channel_index != null ||
                    z.temperature_air_channel_index != null ||
                    z.humidity_air_channel_index != null ||
                    z.temperature_soil_channel_index != null ||
                    z.ph_soil_channel_index != null ||
                    z.ec_soil_channel_index != null
                );
            };

            function setCardOffByValueId(valueId, isOff) {
                const el = document.getElementById(valueId);
                const card = el ? el.closest('.sensor-card') : null;
                if (!card) return;
                card.classList.toggle('card-off', !!isOff);
            }

            function updateZoneCardsOff(zoneNum) {
                const zi = zoneNum - 1;
                const z = zonesState?.[zi];
                if (!z) return;
                setCardOffByValueId(`zoneHum${zoneNum}`, z.soil_channel_index == null);
                setCardOffByValueId(`zoneTSoil${zoneNum}`, z.temperature_soil_channel_index == null);
                setCardOffByValueId(`zoneTAir${zoneNum}`, z.temperature_air_channel_index == null);
                setCardOffByValueId(`zoneHAir${zoneNum}`, z.humidity_air_channel_index == null);
                setCardOffByValueId(`zonePH${zoneNum}`, z.ph_soil_channel_index == null);
                setCardOffByValueId(`zoneEC${zoneNum}`, z.ec_soil_channel_index == null);
                setCardOffByValueId(`zoneValve${zoneNum}`, z.valve_channel_index == null);
                try { updateZoneCardMeta(zoneNum); } catch {}
            }

            function populateSelect(sel, list, currentValue, usedSet, kindLabel) {
                if (!sel) return;
                sel.innerHTML = '';

                const optNone = document.createElement('option');
                optNone.value = '';
                optNone.textContent = '(sin asignar)';
                sel.appendChild(optNone);

                for (const c of list) {
                    const idx = Number(c.channel_index);
                    if (!Number.isFinite(idx)) continue;
                    const opt = document.createElement('option');
                    opt.value = String(idx);
                    const nm = String(c.name || `${kindLabel} ${idx}`);
                    opt.textContent = `${nm} (${idx})`;
                    // No permitir reutilizar el mismo canal en varias plantas
                    if (usedSet.has(idx) && Number(currentValue) !== idx) {
                        opt.disabled = true;
                        opt.textContent = `${nm} (${idx}) — usado en otra planta`;
                    }
                    sel.appendChild(opt);
                }

                sel.value = currentValue == null ? '' : String(currentValue);
            }

            function refreshSelectsForKind({ selectIdPrefix, list, zoneProp, usedKindKey, kindLabel }) {
                for (let zi = 0; zi < 8; zi++) {
                    const zNum = zi + 1;
                    const el = document.getElementById(`${selectIdPrefix}${zNum}`);
                    populateSelect(el, list, zonesState[zi]?.[zoneProp] ?? null, usedSetFor(usedKindKey, zi), kindLabel);
                }
            }

            function addKindSelector({ zoneNum, zoneIndex, zoneRow, labelText, selectIdPrefix, list, zoneProp, usedKindKey, kind, kindLabel }) {
                const row = document.createElement('div');
                row.className = 'control-row';
                const label = document.createElement('label');
                label.textContent = labelText;
                const sel = document.createElement('select');
                sel.id = `${selectIdPrefix}${zoneNum}`;
                sel.title = `Seleccionar ${kindLabel.toLowerCase()} (canal)`;
                populateSelect(sel, list, zonesState[zoneIndex]?.[zoneProp] ?? null, usedSetFor(usedKindKey, zoneIndex), kindLabel);

                const renameBtn = document.createElement('button');
                renameBtn.type = 'button';
                renameBtn.className = 'mini-btn tiny zone-rename-btn';
                renameBtn.textContent = 'Renombrar';
                renameBtn.title = `Renombrar ${kindLabel.toLowerCase()} seleccionado`;

                row.appendChild(label);
                row.appendChild(sel);
                row.appendChild(renameBtn);
                zoneRow.appendChild(row);

                renameBtn.addEventListener('click', async () => {
                    const idx = sel.value === '' ? null : Number(sel.value);
                    if (!Number.isFinite(idx)) return alert('Selecciona un canal para renombrar.');
                    const ch = (channels || []).find(c => c && c.kind === kind && Number(c.channel_index) === idx);
                    if (!ch || !ch.id) return alert('No se encontró el canal.');
                    await renameChannel(ch.id, `${kindLabel.toLowerCase()} (planta ${zoneNum})`);
                    await loadChannels();
                });

                sel.addEventListener('change', () => {
                    const v = sel.value === '' ? null : Number(sel.value);
                    zonesState[zoneIndex][zoneProp] = Number.isFinite(v) ? v : null;
                    refreshSelectsForKind({ selectIdPrefix, list, zoneProp, usedKindKey, kindLabel });
                    updateZoneSubtitles();
                    updateZoneCardsOff(zoneNum);
                    scheduleZoneChartsRebuild();
                    const sec = document.getElementById(`zoneSec${zoneNum}`);
                    const anyAssigned = isAnyAssigned(zonesState[zoneIndex]);
                    if (sec) sec.classList.toggle('zone-off', !anyAssigned);
                });
            }

            async function saveZoneConfig(zoneNum, btnEl) {
                const i = zoneNum - 1;
                const z = zonesState[i];
                if (!z) return;
                const headersBase = { 'Content-Type': 'application/json' };

                async function doSave(headers, body) {
                    return fetch(`/api/config/${encodeURIComponent(deviceCode)}`, {
                        method: 'POST',
                        headers,
                        credentials: 'include',
                        body: JSON.stringify(body)
                    });
                }

                const saved = (getSavedToken(deviceCode) || '').trim();
                const headers1 = { ...headersBase };
                if (saved) headers1['X-Device-Token'] = saved;

                // Traemos config actual y solo tocamos zones
                const rCfg = await fetch(`/api/config/${encodeURIComponent(deviceCode)}`, { credentials: 'include' });
                if (rCfg.status === 401) return doLogout();
                const cfg = await rCfg.json().catch(() => ({}));
                const baseThr = Number(cfg?.humidity_low_threshold ?? config.threshold ?? 25);
                const zones = normalizeZonesFromServer(cfg?.zones, baseThr);
                zones[i] = {
                    zone: zoneNum,
                    soil_channel_index: z.soil_channel_index == null ? null : Number(z.soil_channel_index),
                    valve_channel_index: z.valve_channel_index == null ? null : Number(z.valve_channel_index),
                    temperature_air_channel_index: z.temperature_air_channel_index == null ? null : Number(z.temperature_air_channel_index),
                    humidity_air_channel_index: z.humidity_air_channel_index == null ? null : Number(z.humidity_air_channel_index),
                    temperature_soil_channel_index: z.temperature_soil_channel_index == null ? null : Number(z.temperature_soil_channel_index),
                    ph_soil_channel_index: z.ph_soil_channel_index == null ? null : Number(z.ph_soil_channel_index),
                    ec_soil_channel_index: z.ec_soil_channel_index == null ? null : Number(z.ec_soil_channel_index),
                    humidity_low_threshold: z.humidity_low_threshold == null ? null : Number(z.humidity_low_threshold)
                };

                const body = {
                    // Compat: muchos firmwares/ OLED solo leen el umbral global.
                    // Si hay umbral por planta, usamos PLANTA 1 como umbral global.
                    humidity_low_threshold: (zones && zones[0] && zones[0].humidity_low_threshold != null)
                        ? Number(zones[0].humidity_low_threshold)
                        : (cfg?.humidity_low_threshold ?? config.threshold),
                    humidity_low_color: cfg?.humidity_low_color ?? config.colorB,
                    humidity_good_color: cfg?.humidity_good_color ?? config.colorG,
                    wet_v: cfg?.wet_v,
                    dry_v: cfg?.dry_v,
                    alert_humidity_low_minutes: cfg?.alert_humidity_low_minutes ?? 0,
                    alert_valve_on_max_minutes: cfg?.alert_valve_on_max_minutes ?? 0,
                    alert_sensor_dead_minutes: cfg?.alert_sensor_dead_minutes ?? 0,
                    alert_voltage_min: (cfg?.alert_voltage_min == null ? null : cfg.alert_voltage_min),
                    alert_voltage_max: (cfg?.alert_voltage_max == null ? null : cfg.alert_voltage_max),
                    notify_webhook_url: (cfg?.notify_webhook_url == null ? null : cfg.notify_webhook_url),
                    notify_telegram_chat_id: (cfg?.notify_telegram_chat_id == null ? null : cfg.notify_telegram_chat_id),
                    zones
                };

                if (btnEl) btnEl.disabled = true;
                const oldText = btnEl ? btnEl.textContent : '';
                if (btnEl) btnEl.textContent = 'Guardando…';

                try {
                    let res = await doSave(headers1, body);
                    if (res.status === 401 || res.status === 403) {
                        const msg = saved
                            ? 'Token guardado inválido o caducado. Pega el token correcto:'
                            : 'Este dispositivo requiere token para guardar. Pégalo aquí:';
                        const t = (prompt(msg) || '').trim();
                        if (t) {
                            saveToken(deviceCode, t);
                            const headers2 = { ...headersBase, 'X-Device-Token': t };
                            res = await doSave(headers2, body);
                        }
                    }
                    if (!res.ok) throw new Error('Error guardando');
                    if (btnEl) btnEl.textContent = 'Guardado';
                    setTimeout(() => {
                        if (btnEl) btnEl.textContent = oldText || 'Guardar';
                    }, 1200);
                } finally {
                    if (btnEl) btnEl.disabled = false;
                }
            }

            try { destroyZoneMiniCharts(); } catch {}
            container.innerHTML = '';

            // Botón global: mostrar/ocultar todas las plantas
            {
                const row = document.createElement('div');
                row.className = 'zones-global-row';
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = 'mini-btn zones-global-btn';
                btn.id = 'zonesToggleAllBtn';
                btn.textContent = 'Ocultar todas las plantas';
                btn.addEventListener('click', () => {
                    const allCollapsed = areAllZoneSectionsCollapsed();
                    setAllZoneSectionsCollapsed(!allCollapsed);
                    updateZonesToggleAllBtn();
                });
                row.appendChild(btn);
                container.appendChild(row);
            }

            for (let i = 0; i < 8; i++) {
                const zoneNum = i + 1;

                const sec = document.createElement('div');
                sec.className = 'section';
                sec.id = `zoneSec${zoneNum}`;

                const h2 = document.createElement('h2');
                h2.textContent = `PLANTA ${zoneNum}`;
                sec.appendChild(h2);

                const subtitle = document.createElement('div');
                subtitle.className = 'zone-subtitle';
                subtitle.id = `zoneSubtitle${zoneNum}`;
                subtitle.textContent = '—';
                sec.appendChild(subtitle);

                // Botones de modo por planta (independientes)
                {
                    const topBar = document.createElement('div');
                    topBar.className = 'zone-topbar';

                    const controlsBtn = document.createElement('button');
                    controlsBtn.type = 'button';
                    controlsBtn.className = 'mini-btn zone-controls-btn tiny';
                    controlsBtn.id = `zoneControlsBtn${zoneNum}`;
                    controlsBtn.textContent = 'Mostrar controles';

                    const modeRow = document.createElement('div');
                    modeRow.className = 'zone-mode-row';

                    const bDay = document.createElement('button');
                    bDay.type = 'button';
                    bDay.className = 'mini-btn zone-mode-btn zone-mode-day';
                    bDay.id = `zoneBtnDia${zoneNum}`;
                    bDay.textContent = 'DÍA';

                    const bMonth = document.createElement('button');
                    bMonth.type = 'button';
                    bMonth.className = 'mini-btn zone-mode-btn zone-mode-month';
                    bMonth.id = `zoneBtnMes${zoneNum}`;
                    bMonth.textContent = 'MES';

                    const bYear = document.createElement('button');
                    bYear.type = 'button';
                    bYear.className = 'mini-btn zone-mode-btn zone-mode-year';
                    bYear.id = `zoneBtnAno${zoneNum}`;
                    bYear.textContent = 'AÑO';

                    bDay.addEventListener('click', () => setZoneViewMode(zoneNum, 'day'));
                    bMonth.addEventListener('click', () => setZoneViewMode(zoneNum, 'month'));
                    bYear.addEventListener('click', () => setZoneViewMode(zoneNum, 'year'));

                    modeRow.appendChild(bDay);
                    modeRow.appendChild(bMonth);
                    modeRow.appendChild(bYear);

                    topBar.appendChild(controlsBtn);
                    topBar.appendChild(modeRow);
                    sec.appendChild(topBar);

                    setActiveZoneModeButtons(zoneNum, getZoneViewMode(zoneNum));

                    // Controles ocultos por defecto
                    const open = getZoneControlsOpen(zoneNum);
                    setZoneControlsOpen(zoneNum, open);
                    controlsBtn.addEventListener('click', () => {
                        const next = !getZoneControlsOpen(zoneNum);
                        setZoneControlsOpen(zoneNum, next);
                    });
                }

                const controlsWrap = document.createElement('div');
                controlsWrap.className = 'zone-controls';
                controlsWrap.id = `zoneControls${zoneNum}`;

                const zoneRow = document.createElement('div');
                zoneRow.className = 'zone-row';

                // Selector sensor
                {
                    const row = document.createElement('div');
                    row.className = 'control-row';
                    const label = document.createElement('label');
                    label.textContent = 'Sensor de humedad:';
                    const sel = document.createElement('select');
                    sel.id = `zoneSoilSel${zoneNum}`;
                    sel.title = 'Seleccionar sensor de humedad (canal)';
                    populateSelect(sel, soil, zonesState[i]?.soil_channel_index ?? null, usedSetFor('soil', i), 'Sensor');
                    const renameBtn = document.createElement('button');
                    renameBtn.type = 'button';
                    renameBtn.className = 'mini-btn tiny zone-rename-btn';
                    renameBtn.textContent = 'Renombrar';
                    renameBtn.title = 'Renombrar el sensor seleccionado';
                    row.appendChild(label);
                    row.appendChild(sel);
                    row.appendChild(renameBtn);
                    zoneRow.appendChild(row);

                    renameBtn.addEventListener('click', async () => {
                        const idx = sel.value === '' ? null : Number(sel.value);
                        if (!Number.isFinite(idx)) return alert('Selecciona un sensor para renombrar.');
                        const ch = (channels || []).find(c => c && c.kind === 'soil_sensor' && Number(c.channel_index) === idx);
                        if (!ch || !ch.id) return alert('No se encontró el canal.');
                        await renameChannel(ch.id, `el sensor (planta ${zoneNum})`);
                        await loadChannels();
                    });

                    sel.addEventListener('change', () => {
                        const v = sel.value === '' ? null : Number(sel.value);
                        zonesState[i].soil_channel_index = Number.isFinite(v) ? v : null;
                        // Refrescar disables para no reutilizar canales
                        for (let zi = 0; zi < 8; zi++) {
                            const zNum = zi + 1;
                            const sSel = document.getElementById(`zoneSoilSel${zNum}`);
                            populateSelect(sSel, soil, zonesState[zi]?.soil_channel_index ?? null, usedSetFor('soil', zi), 'Sensor');
                        }
                        updateZoneSubtitles();
                        updateZoneCardsOff(zoneNum);
                        scheduleZoneChartsRebuild();
                        // Apagar visualmente si queda sin asignar
                        const sec = document.getElementById(`zoneSec${zoneNum}`);
                        const anyAssigned = isAnyAssigned(zonesState[i]);
                        if (sec) sec.classList.toggle('zone-off', !anyAssigned);
                    });
                }

                // Sensores extra
                addKindSelector({
                    zoneNum,
                    zoneIndex: i,
                    zoneRow,
                    labelText: 'Temperatura aire:',
                    selectIdPrefix: 'zoneTAirSel',
                    list: tAir,
                    zoneProp: 'temperature_air_channel_index',
                    usedKindKey: 'temperature_air',
                    kind: 'temperature_air',
                    kindLabel: 'Temperatura aire'
                });
                addKindSelector({
                    zoneNum,
                    zoneIndex: i,
                    zoneRow,
                    labelText: 'Humedad aire:',
                    selectIdPrefix: 'zoneHAirSel',
                    list: hAir,
                    zoneProp: 'humidity_air_channel_index',
                    usedKindKey: 'humidity_air',
                    kind: 'humidity_air',
                    kindLabel: 'Humedad aire'
                });
                addKindSelector({
                    zoneNum,
                    zoneIndex: i,
                    zoneRow,
                    labelText: 'Temperatura tierra:',
                    selectIdPrefix: 'zoneTSoilSel',
                    list: tSoil,
                    zoneProp: 'temperature_soil_channel_index',
                    usedKindKey: 'temperature_soil',
                    kind: 'temperature_soil',
                    kindLabel: 'Temperatura tierra'
                });
                addKindSelector({
                    zoneNum,
                    zoneIndex: i,
                    zoneRow,
                    labelText: 'pH tierra:',
                    selectIdPrefix: 'zonePHSoilSel',
                    list: phSoil,
                    zoneProp: 'ph_soil_channel_index',
                    usedKindKey: 'ph_soil',
                    kind: 'ph_soil',
                    kindLabel: 'pH tierra'
                });
                addKindSelector({
                    zoneNum,
                    zoneIndex: i,
                    zoneRow,
                    labelText: 'EC tierra:',
                    selectIdPrefix: 'zoneECSoilSel',
                    list: ecSoil,
                    zoneProp: 'ec_soil_channel_index',
                    usedKindKey: 'ec_soil',
                    kind: 'ec_soil',
                    kindLabel: 'EC tierra'
                });

                // Selector válvula
                {
                    const row = document.createElement('div');
                    row.className = 'control-row';
                    const label = document.createElement('label');
                    label.textContent = 'Válvula:';
                    const sel = document.createElement('select');
                    sel.id = `zoneValveSel${zoneNum}`;
                    sel.title = 'Seleccionar válvula (canal)';
                    populateSelect(sel, valves, zonesState[i]?.valve_channel_index ?? null, usedSetFor('valve', i), 'Válvula');
                    const renameBtn = document.createElement('button');
                    renameBtn.type = 'button';
                    renameBtn.className = 'mini-btn tiny zone-rename-btn';
                    renameBtn.textContent = 'Renombrar';
                    renameBtn.title = 'Renombrar la válvula seleccionada';
                    row.appendChild(label);
                    row.appendChild(sel);
                    row.appendChild(renameBtn);
                    zoneRow.appendChild(row);

                    renameBtn.addEventListener('click', async () => {
                        const idx = sel.value === '' ? null : Number(sel.value);
                        if (!Number.isFinite(idx)) return alert('Selecciona una válvula para renombrar.');
                        const ch = (channels || []).find(c => c && c.kind === 'valve' && Number(c.channel_index) === idx);
                        if (!ch || !ch.id) return alert('No se encontró el canal.');
                        await renameChannel(ch.id, `la válvula (planta ${zoneNum})`);
                        await loadChannels();
                    });

                    sel.addEventListener('change', () => {
                        const v = sel.value === '' ? null : Number(sel.value);
                        zonesState[i].valve_channel_index = Number.isFinite(v) ? v : null;
                        // Refrescar disables para no reutilizar canales
                        for (let zi = 0; zi < 8; zi++) {
                            const zNum = zi + 1;
                            const vSel = document.getElementById(`zoneValveSel${zNum}`);
                            populateSelect(vSel, valves, zonesState[zi]?.valve_channel_index ?? null, usedSetFor('valve', zi), 'Válvula');
                        }
                        updateZoneSubtitles();
                        updateZoneCardsOff(zoneNum);
                        scheduleZoneChartsRebuild();
                        const sec = document.getElementById(`zoneSec${zoneNum}`);
                        const anyAssigned = isAnyAssigned(zonesState[i]);
                        if (sec) sec.classList.toggle('zone-off', !anyAssigned);
                    });
                }

                controlsWrap.appendChild(zoneRow);
                sec.appendChild(controlsWrap);
                // Aplicar estado real (ahora que existe el contenedor)
                try { setZoneControlsOpen(zoneNum, getZoneControlsOpen(zoneNum)); } catch {}

                // Tarjeta Umbral (siempre visible; arriba antes de las tarjetas)
                {
                    const thrCard = document.createElement('div');
                    thrCard.className = 'sensor-card metric-neutral accent accent-green';

                    const label = document.createElement('div');
                    label.className = 'sensor-label';
                    label.textContent = 'Umbral riego automático';

                    const meta = document.createElement('div');
                    meta.className = 'sensor-meta';
                    const metaLine = document.createElement('div');
                    metaLine.className = 'sensor-meta-last';
                    metaLine.textContent = 'Se guarda solo en esta planta';
                    meta.appendChild(metaLine);

                    const row = document.createElement('div');
                    row.className = 'control-row';
                    row.style.marginBottom = '0';

                    const rng = document.createElement('input');
                    rng.type = 'range';
                    rng.min = '1';
                    rng.max = '100';
                    rng.id = `zoneThr${zoneNum}`;
                    rng.title = 'Umbral de humedad baja (zona)';
                    rng.style.flex = '1';

                    const val = document.createElement('div');
                    val.id = `zoneThrVal${zoneNum}`;
                    val.className = 'sensor-value small';
                    val.style.flex = '0 0 auto';
                    val.style.minWidth = '70px';
                    val.style.textAlign = 'right';
                    val.textContent = '--%';

                    const btn = document.createElement('button');
                    btn.type = 'button';
                    btn.className = 'mini-btn zone-controls-btn tiny';
                    btn.textContent = 'Guardar';
                    btn.title = 'Guardar umbral (y asignación) solo de esta planta';

                    row.appendChild(rng);
                    row.appendChild(val);
                    row.appendChild(btn);

                    thrCard.appendChild(label);
                    thrCard.appendChild(meta);
                    thrCard.appendChild(row);
                    sec.appendChild(thrCard);

                    rng.addEventListener('input', () => {
                        const n = Number(rng.value);
                        zonesState[i].humidity_low_threshold = Number.isFinite(n) ? Math.max(0, Math.min(100, n)) : zonesState[i].humidity_low_threshold;
                        val.textContent = `${Math.round(Number(zonesState[i].humidity_low_threshold ?? 25))}%`;
                        updateZoneSubtitles();
                    });

                    btn.addEventListener('click', async () => {
                        await saveZoneConfig(zoneNum, btn);
                    });
                }

                const grid = document.createElement('div');
                grid.className = 'sensor-grid';

                const humCard = document.createElement('div');
                humCard.className = 'sensor-card metric-neutral accent accent-green';
                humCard.innerHTML = `<div class="sensor-label">Humedad (zona)</div><div class="sensor-meta"><div class="sensor-meta-top"><div class="sensor-meta-name" id="zoneHumName${zoneNum}">—</div><div class="sensor-meta-avg" id="zoneHumAvg${zoneNum}"><span class="meta-label">Media:</span> <span class="meta-value" data-role="value">--</span></div></div><div class="sensor-meta-last" id="zoneHumLast${zoneNum}"><span class="meta-label">Actualizado:</span> <span class="meta-value" data-role="value">--</span></div></div><div class="sensor-value" id="zoneHum${zoneNum}">--</div><div class="sensor-unit">%</div><div class="chart-wrap mini-chart-wrap"><canvas id="zoneHumChart${zoneNum}"></canvas></div>`;

                const tSoilCard = document.createElement('div');
                tSoilCard.className = 'sensor-card metric-neutral accent accent-purple';
                tSoilCard.innerHTML = `<div class="sensor-label">Temp. tierra</div><div class="sensor-meta"><div class="sensor-meta-top"><div class="sensor-meta-name" id="zoneTSoilName${zoneNum}">—</div><div class="sensor-meta-avg" id="zoneTSoilAvg${zoneNum}"><span class="meta-label">Media:</span> <span class="meta-value" data-role="value">--</span></div></div><div class="sensor-meta-last" id="zoneTSoilLast${zoneNum}"><span class="meta-label">Actualizado:</span> <span class="meta-value" data-role="value">--</span></div></div><div class="sensor-value" id="zoneTSoil${zoneNum}">--</div><div class="sensor-unit">°C</div><div class="chart-wrap mini-chart-wrap"><canvas id="zoneTSoilChart${zoneNum}"></canvas></div>`;

                const tAirCard = document.createElement('div');
                tAirCard.className = 'sensor-card metric-neutral accent accent-blue';
                tAirCard.innerHTML = `<div class="sensor-label">Temp. aire</div><div class="sensor-meta"><div class="sensor-meta-top"><div class="sensor-meta-name" id="zoneTAirName${zoneNum}">—</div><div class="sensor-meta-avg" id="zoneTAirAvg${zoneNum}"><span class="meta-label">Media:</span> <span class="meta-value" data-role="value">--</span></div></div><div class="sensor-meta-last" id="zoneTAirLast${zoneNum}"><span class="meta-label">Actualizado:</span> <span class="meta-value" data-role="value">--</span></div></div><div class="sensor-value" id="zoneTAir${zoneNum}">--</div><div class="sensor-unit">°C</div><div class="chart-wrap mini-chart-wrap"><canvas id="zoneTAirChart${zoneNum}"></canvas></div>`;

                const hAirCard = document.createElement('div');
                hAirCard.className = 'sensor-card metric-neutral accent accent-indigo';
                hAirCard.innerHTML = `<div class="sensor-label">Humedad aire</div><div class="sensor-meta"><div class="sensor-meta-top"><div class="sensor-meta-name" id="zoneHAirName${zoneNum}">—</div><div class="sensor-meta-avg" id="zoneHAirAvg${zoneNum}"><span class="meta-label">Media:</span> <span class="meta-value" data-role="value">--</span></div></div><div class="sensor-meta-last" id="zoneHAirLast${zoneNum}"><span class="meta-label">Actualizado:</span> <span class="meta-value" data-role="value">--</span></div></div><div class="sensor-value" id="zoneHAir${zoneNum}">--</div><div class="sensor-unit">%</div><div class="chart-wrap mini-chart-wrap"><canvas id="zoneHAirChart${zoneNum}"></canvas></div>`;

                const phCard = document.createElement('div');
                phCard.className = 'sensor-card metric-neutral accent accent-amber';
                phCard.innerHTML = `<div class="sensor-label">pH tierra</div><div class="sensor-meta"><div class="sensor-meta-top"><div class="sensor-meta-name" id="zonePHName${zoneNum}">—</div><div class="sensor-meta-avg" id="zonePHAvg${zoneNum}"><span class="meta-label">Media:</span> <span class="meta-value" data-role="value">--</span></div></div><div class="sensor-meta-last" id="zonePHLast${zoneNum}"><span class="meta-label">Actualizado:</span> <span class="meta-value" data-role="value">--</span></div></div><div class="sensor-value" id="zonePH${zoneNum}">--</div><div class="sensor-unit">pH</div><div class="chart-wrap mini-chart-wrap"><canvas id="zonePHChart${zoneNum}"></canvas></div>`;

                const ecCard = document.createElement('div');
                ecCard.className = 'sensor-card metric-neutral accent accent-cyan';
                ecCard.innerHTML = `<div class="sensor-label">EC tierra</div><div class="sensor-meta"><div class="sensor-meta-top"><div class="sensor-meta-name" id="zoneECName${zoneNum}">—</div><div class="sensor-meta-avg" id="zoneECAvg${zoneNum}"><span class="meta-label">Media:</span> <span class="meta-value" data-role="value">--</span></div></div><div class="sensor-meta-last" id="zoneECLast${zoneNum}"><span class="meta-label">Actualizado:</span> <span class="meta-value" data-role="value">--</span></div></div><div class="sensor-value" id="zoneEC${zoneNum}">--</div><div class="sensor-unit">mS/cm</div><div class="chart-wrap mini-chart-wrap"><canvas id="zoneECChart${zoneNum}"></canvas></div>`;

                const valveCard = document.createElement('div');
                valveCard.className = 'sensor-card metric-neutral accent accent-red';
                valveCard.innerHTML = `<div class="sensor-label">Válvula (zona)</div><div class="sensor-meta"><div class="sensor-meta-top"><div class="sensor-meta-name" id="zoneValveName${zoneNum}">—</div><div class="sensor-meta-avg" id="zoneValveAvg${zoneNum}"><span class="meta-label">ON:</span> <span class="meta-value" data-role="value">--</span></div></div><div class="sensor-meta-last" id="zoneValveLast${zoneNum}"><span class="meta-label">Actualizado:</span> <span class="meta-value" data-role="value">--</span></div></div><div class="sensor-value" id="zoneValve${zoneNum}">--</div><div class="valve-indicator"><div class="valve-dot" id="zoneValveDot${zoneNum}"></div><div class="valve-text" id="zoneValveText${zoneNum}">--</div></div><div class="chart-wrap mini-chart-wrap"><canvas id="zoneValveChart${zoneNum}"></canvas></div>`;

                const statusCard = document.createElement('div');
                statusCard.className = 'sensor-card metric-neutral accent accent-cyan';
                statusCard.innerHTML = `<div class="sensor-label">Estado</div><div class="sensor-value" id="zoneState${zoneNum}">--</div><div class="sensor-unit zone-mini" id="zoneAge${zoneNum}"></div>`;

                const zoneSummary = document.createElement('div');
                zoneSummary.className = 'summary';
                zoneSummary.style.marginTop = '10px';
                zoneSummary.innerHTML = `
                    <div>
                        <div class="k">Humedad Media</div>
                        <div class="v" id="zoneAvgHumidity${zoneNum}">--</div>
                    </div>
                    <div>
                        <div class="k">Último punto</div>
                        <div class="v" id="zoneLastPoint${zoneNum}">--</div>
                    </div>
                    <div>
                        <div class="k">Tiempo Válvula ON</div>
                        <div class="v" id="zoneTotalValveOn${zoneNum}">--</div>
                    </div>`;

                // Pedido: la válvula justo debajo de la humedad
                grid.appendChild(humCard);
                grid.appendChild(valveCard);
                grid.appendChild(tSoilCard);
                grid.appendChild(tAirCard);
                grid.appendChild(hAirCard);
                grid.appendChild(phCard);
                grid.appendChild(ecCard);
                grid.appendChild(statusCard);

                sec.appendChild(zoneSummary);
                sec.appendChild(grid);
                container.appendChild(sec);

                // Tarjetas visibles siempre, pero apagadas si su canal no está asignado
                updateZoneCardsOff(zoneNum);
                try { updateZoneCardMeta(zoneNum); } catch {}
            }

            applyZonesStateToUI();
            initCollapsibles();
            updateZoneSubtitles();
            scheduleZoneChartsRebuild();

            try { updateZonesToggleAllBtn(); } catch {}

            // Marcar OFF las zonas sin asignar desde el primer render
            for (let i = 0; i < 8; i++) {
                const zoneNum = i + 1;
                const sec = document.getElementById(`zoneSec${zoneNum}`);
                const z = zonesState[i];
                const anyAssigned = isAnyAssigned(z);
                if (sec) sec.classList.toggle('zone-off', !anyAssigned);
            }
        }

        function applyZonesStateToUI() {
            for (let i = 0; i < 8; i++) {
                const zoneNum = i + 1;
                const z = zonesState[i];
                const soilSel = document.getElementById(`zoneSoilSel${zoneNum}`);
                const valveSel = document.getElementById(`zoneValveSel${zoneNum}`);
                const tAirSel = document.getElementById(`zoneTAirSel${zoneNum}`);
                const hAirSel = document.getElementById(`zoneHAirSel${zoneNum}`);
                const tSoilSel = document.getElementById(`zoneTSoilSel${zoneNum}`);
                const phSel = document.getElementById(`zonePHSoilSel${zoneNum}`);
                const ecSel = document.getElementById(`zoneECSoilSel${zoneNum}`);
                const thr = document.getElementById(`zoneThr${zoneNum}`);
                const thrVal = document.getElementById(`zoneThrVal${zoneNum}`);

                if (soilSel) soilSel.value = z.soil_channel_index == null ? '' : String(z.soil_channel_index);
                if (valveSel) valveSel.value = z.valve_channel_index == null ? '' : String(z.valve_channel_index);
                if (tAirSel) tAirSel.value = z.temperature_air_channel_index == null ? '' : String(z.temperature_air_channel_index);
                if (hAirSel) hAirSel.value = z.humidity_air_channel_index == null ? '' : String(z.humidity_air_channel_index);
                if (tSoilSel) tSoilSel.value = z.temperature_soil_channel_index == null ? '' : String(z.temperature_soil_channel_index);
                if (phSel) phSel.value = z.ph_soil_channel_index == null ? '' : String(z.ph_soil_channel_index);
                if (ecSel) ecSel.value = z.ec_soil_channel_index == null ? '' : String(z.ec_soil_channel_index);
                if (thr) thr.value = String(Math.round(Number(z.humidity_low_threshold ?? 25)));
                if (thrVal) thrVal.textContent = `${Math.round(Number(z.humidity_low_threshold ?? 25))}%`;
            }
        }

        function updateZonesFromLatestPayload(payload) {
            lastChannelsLatestPayload = payload || null;
            const ch = Array.isArray(payload?.channels) ? payload.channels : [];
            const byKey = new Map();
            for (const c of ch) {
                const kind = String(c?.kind || '');
                const idx = Number(c?.channel_index);
                if (!kind || !Number.isFinite(idx)) continue;
                byKey.set(`${kind}:${idx}`, c.latest || null);
            }

            const STALE_MIN = 10;

            // Heurística anti-datos-falsos:
            // Si solo hay 1 sensor y 1 válvula con datos recientes, mantenemos solo PLANTA 1 asignada.
            // Esto es local (no guarda nada en servidor).
            try {
                const presentSoil = new Set();
                const presentValve = new Set();
                for (const c of ch) {
                    const kind = String(c?.kind || '');
                    const idx = Number(c?.channel_index);
                    if (!Number.isFinite(idx)) continue;
                    const age = c?.latest?.age_minutes;
                    const okAge = (age == null) || (Number(age) <= STALE_MIN);
                    if (!okAge) continue;
                    if (kind === 'soil_sensor' && c?.latest?.value != null) presentSoil.add(idx);
                    if (kind === 'valve' && c?.latest?.state != null) presentValve.add(idx);
                }
                if (presentSoil.size <= 1 && presentValve.size <= 1) {
                    for (let i = 1; i < 8; i++) {
                        const z = zonesState[i];
                        if (!z) continue;
                        z.soil_channel_index = null;
                        z.valve_channel_index = null;
                    }
                }
            } catch {}

            for (let i = 0; i < 8; i++) {
                const zoneNum = i + 1;
                const z = zonesState[i];
                const sec = document.getElementById(`zoneSec${zoneNum}`);

                const soilIdx = z.soil_channel_index;
                const valveIdx = z.valve_channel_index;
                const tAirIdx = z.temperature_air_channel_index;
                const hAirIdx = z.humidity_air_channel_index;
                const tSoilIdx = z.temperature_soil_channel_index;
                const phIdx = z.ph_soil_channel_index;
                const ecIdx = z.ec_soil_channel_index;
                const soilLatest = soilIdx == null ? null : byKey.get(`soil_sensor:${soilIdx}`);
                const valveLatest = valveIdx == null ? null : byKey.get(`valve:${valveIdx}`);
                const tAirLatest = tAirIdx == null ? null : byKey.get(`temperature_air:${tAirIdx}`);
                const hAirLatest = hAirIdx == null ? null : byKey.get(`humidity_air:${hAirIdx}`);
                const tSoilLatest = tSoilIdx == null ? null : byKey.get(`temperature_soil:${tSoilIdx}`);
                const phLatest = phIdx == null ? null : byKey.get(`ph_soil:${phIdx}`);
                const ecLatest = ecIdx == null ? null : byKey.get(`ec_soil:${ecIdx}`);

                // Mini gráficas: tiempo real solo en DÍA (en MES/AÑO se muestran agregados)
                if (getZoneViewMode(zoneNum) === 'day') {
                    if (soilIdx != null && soilLatest) ingestMiniChartPoint(`zoneHumChart${zoneNum}`, soilLatest, { kind: 'value' });
                    if (tSoilIdx != null && tSoilLatest) ingestMiniChartPoint(`zoneTSoilChart${zoneNum}`, tSoilLatest, { kind: 'value' });
                    if (tAirIdx != null && tAirLatest) ingestMiniChartPoint(`zoneTAirChart${zoneNum}`, tAirLatest, { kind: 'value' });
                    if (hAirIdx != null && hAirLatest) ingestMiniChartPoint(`zoneHAirChart${zoneNum}`, hAirLatest, { kind: 'value' });
                    if (phIdx != null && phLatest) ingestMiniChartPoint(`zonePHChart${zoneNum}`, phLatest, { kind: 'value' });
                    if (ecIdx != null && ecLatest) ingestMiniChartPoint(`zoneECChart${zoneNum}`, ecLatest, { kind: 'value' });
                    if (valveIdx != null && valveLatest) ingestMiniChartPoint(`zoneValveChart${zoneNum}`, valveLatest, { kind: 'valve' });
                }

                const humEl = document.getElementById(`zoneHum${zoneNum}`);
                const tAirEl = document.getElementById(`zoneTAir${zoneNum}`);
                const hAirEl = document.getElementById(`zoneHAir${zoneNum}`);
                const tSoilEl = document.getElementById(`zoneTSoil${zoneNum}`);
                const phEl = document.getElementById(`zonePH${zoneNum}`);
                const ecEl = document.getElementById(`zoneEC${zoneNum}`);
                const valveEl = document.getElementById(`zoneValve${zoneNum}`);
                const dotEl = document.getElementById(`zoneValveDot${zoneNum}`);
                const txtEl = document.getElementById(`zoneValveText${zoneNum}`);
                const stateEl = document.getElementById(`zoneState${zoneNum}`);
                const ageEl = document.getElementById(`zoneAge${zoneNum}`);

                const soilAge = soilLatest?.age_minutes;
                const valveAge = valveLatest?.age_minutes;
                const tAirAge = tAirLatest?.age_minutes;
                const hAirAge = hAirLatest?.age_minutes;
                const tSoilAge = tSoilLatest?.age_minutes;
                const phAge = phLatest?.age_minutes;
                const ecAge = ecLatest?.age_minutes;
                const soilOk = soilLatest && soilLatest.value != null && (soilAge == null || Number(soilAge) <= STALE_MIN);
                const valveOk = valveLatest && valveLatest.state != null && (valveAge == null || Number(valveAge) <= STALE_MIN);
                const tAirOk = tAirLatest && tAirLatest.value != null && (tAirAge == null || Number(tAirAge) <= STALE_MIN);
                const hAirOk = hAirLatest && hAirLatest.value != null && (hAirAge == null || Number(hAirAge) <= STALE_MIN);
                const tSoilOk = tSoilLatest && tSoilLatest.value != null && (tSoilAge == null || Number(tSoilAge) <= STALE_MIN);
                const phOk = phLatest && phLatest.value != null && (phAge == null || Number(phAge) <= STALE_MIN);
                const ecOk = ecLatest && ecLatest.value != null && (ecAge == null || Number(ecAge) <= STALE_MIN);

                // Atenuar tarjetas si el canal está asignado pero sin datos recientes (stale)
                // Mantiene las gráficas visibles, solo cambia el estilo visual.
                try {
                    setCardOffByValueId(`zoneHum${zoneNum}`, soilIdx == null || !soilOk);
                    setCardOffByValueId(`zoneTSoil${zoneNum}`, tSoilIdx == null || !tSoilOk);
                    setCardOffByValueId(`zoneTAir${zoneNum}`, tAirIdx == null || !tAirOk);
                    setCardOffByValueId(`zoneHAir${zoneNum}`, hAirIdx == null || !hAirOk);
                    setCardOffByValueId(`zonePH${zoneNum}`, phIdx == null || !phOk);
                    setCardOffByValueId(`zoneEC${zoneNum}`, ecIdx == null || !ecOk);
                    setCardOffByValueId(`zoneValve${zoneNum}`, valveIdx == null || !valveOk);
                } catch {}

                if (humEl) {
                    const v = soilLatest?.value;
                    const num = v == null ? null : Number(v);
                    humEl.textContent = soilOk && Number.isFinite(num) ? num.toFixed(1) : '--';
                }

                if (tAirEl) {
                    const v = tAirLatest?.value;
                    const num = v == null ? null : Number(v);
                    tAirEl.textContent = tAirOk && Number.isFinite(num) ? num.toFixed(1) : '--';
                }
                if (hAirEl) {
                    const v = hAirLatest?.value;
                    const num = v == null ? null : Number(v);
                    hAirEl.textContent = hAirOk && Number.isFinite(num) ? num.toFixed(1) : '--';
                }
                if (tSoilEl) {
                    const v = tSoilLatest?.value;
                    const num = v == null ? null : Number(v);
                    tSoilEl.textContent = tSoilOk && Number.isFinite(num) ? num.toFixed(1) : '--';
                }
                if (phEl) {
                    const v = phLatest?.value;
                    const num = v == null ? null : Number(v);
                    phEl.textContent = phOk && Number.isFinite(num) ? num.toFixed(2) : '--';
                }
                if (ecEl) {
                    const v = ecLatest?.value;
                    const num = v == null ? null : Number(v);
                    ecEl.textContent = ecOk && Number.isFinite(num) ? num.toFixed(2) : '--';
                }

                if (valveEl || dotEl || txtEl) {
                    const s = valveLatest?.state;
                    const st = s == null ? null : Number(s);
                    const isOn = valveOk && Number.isFinite(st) && st >= 1;
                    if (valveEl) valveEl.textContent = valveOk ? (isOn ? 'ON' : 'OFF') : '--';
                    if (dotEl) dotEl.className = 'valve-dot' + (valveOk ? (isOn ? ' on' : ' off') : '');
                    if (txtEl) txtEl.textContent = valveOk ? (isOn ? 'ENCENDIDA' : 'APAGADA') : 'SIN DATOS';
                }

                const anyAssigned = (
                    soilIdx != null || valveIdx != null ||
                    tAirIdx != null || hAirIdx != null ||
                    tSoilIdx != null || phIdx != null || ecIdx != null
                );
                const anyOk = soilOk || valveOk || tAirOk || hAirOk || tSoilOk || phOk || ecOk;
                if (stateEl) stateEl.textContent = !anyAssigned ? 'SIN ASIGNAR' : (anyOk ? 'ACTIVA' : 'APAGADA');

                const parts = [];
                if (soilIdx != null) parts.push(`S${soilIdx}:${soilLatest?.age_minutes ?? '--'}m`);
                if (tSoilIdx != null) parts.push(`TS${tSoilIdx}:${tSoilLatest?.age_minutes ?? '--'}m`);
                if (tAirIdx != null) parts.push(`TA${tAirIdx}:${tAirLatest?.age_minutes ?? '--'}m`);
                if (hAirIdx != null) parts.push(`HA${hAirIdx}:${hAirLatest?.age_minutes ?? '--'}m`);
                if (phIdx != null) parts.push(`pH${phIdx}:${phLatest?.age_minutes ?? '--'}m`);
                if (ecIdx != null) parts.push(`EC${ecIdx}:${ecLatest?.age_minutes ?? '--'}m`);
                if (valveIdx != null) parts.push(`V${valveIdx}:${valveLatest?.age_minutes ?? '--'}m`);
                if (ageEl) ageEl.textContent = parts.join(' · ');

                if (sec) sec.classList.toggle('zone-off', !anyAssigned || (anyAssigned && !anyOk));
            }
        }

        let channels = [];
        let humChannelId = null;
        let valveChannelId = null;

        let lastRebootsBase = null;
        let lastSampleMsForInterval = null;

        // --- Cuenta / navegación ---
        const navDevicesBtn = document.getElementById('navDevices');
        const navAccountBtn = document.getElementById('navAccount');
        const navSupportBtn = document.getElementById('navSupport');
            const supportBadge = document.getElementById('supportBadge');
        const navLogoutBtn = document.getElementById('navLogout');

        const accountSection = document.getElementById('accountSection');
        const accountStatus = document.getElementById('accountStatus');
        const accEmail = document.getElementById('accEmail');
        const accFullName = document.getElementById('accFullName');
        const accPhone = document.getElementById('accPhone');
        const accAddress = document.getElementById('accAddress');
        const accProvince = document.getElementById('accProvince');
        const accCity = document.getElementById('accCity');
        const accCountry = document.getElementById('accCountry');
        const btnSaveProfile = document.getElementById('btnSaveProfile');
        const btnDeleteAccount = document.getElementById('btnDeleteAccount');

        const supportSection = document.getElementById('supportSection');
        const supportStatus = document.getElementById('supportStatus');
        const tSubject = document.getElementById('tSubject');
        const tDevice = document.getElementById('tDevice');
        const tMessage = document.getElementById('tMessage');
        const btnCreateTicket = document.getElementById('btnCreateTicket');
        const ticketsList = document.getElementById('ticketsList');
        const tId = document.getElementById('tId');
        const tStatus = document.getElementById('tStatus');
        const tMessages = document.getElementById('tMessages');
        const tReply = document.getElementById('tReply');
        const btnReplyTicket = document.getElementById('btnReplyTicket');
        const btnCloseTicket = document.getElementById('btnCloseTicket');

        let selectedTicketId = null;

        function setAccountStatus(text, isErr = false) {
            if (!accountStatus) return;
            accountStatus.textContent = text || '—';
            accountStatus.className = 'status' + (isErr ? ' offline' : ' online');
        }

        function setView(view) {
            const isAccount = view === 'account';
            const isSupport = view === 'support';
            document.body.classList.toggle('mode-account', isAccount);
            document.body.classList.toggle('mode-support', isSupport);
            accountSection?.classList.toggle('hidden', !isAccount);
            supportSection?.classList.toggle('hidden', !isSupport);
            navDevicesBtn?.classList.toggle('active', !isAccount && !isSupport);
            navAccountBtn?.classList.toggle('active', isAccount);
            navSupportBtn?.classList.toggle('active', isSupport);
        }

        function setSupportStatus(text, isErr = false) {
            if (!supportStatus) return;
            supportStatus.textContent = text || '—';
            supportStatus.className = 'status' + (isErr ? ' offline' : ' online');
        }

        async function supportApi(path, opts = {}) {
            const r = await fetch(path, Object.assign({}, opts, { credentials: 'include' }));
            if (r.status === 401) return doLogout();
            const text = await r.text();
            let j = null;
            try { j = text ? JSON.parse(text) : null; } catch { j = { raw: text }; }
            if (!r.ok) throw new Error((j && j.error) ? j.error : `HTTP ${r.status}`);
            return j;
        }

            function setSupportBadge(n) {
                if (!supportBadge) return;
                const count = Math.max(0, Number(n) || 0);
                supportBadge.textContent = String(count);
                supportBadge.classList.toggle('hidden', count <= 0);
                // Si hay no leídos, resaltamos el botón
                navSupportBtn?.classList.toggle('primary', count > 0);
            }

            async function refreshSupportBadge() {
                try {
                    const j = await supportApi('/api/tickets/unread-count');
                    setSupportBadge(j.unread_count || 0);
                } catch {
                    // silencioso
                }
            }

        function safeText(el, text) {
            if (!el) return;
            el.textContent = text == null ? '' : String(text);
        }

        function renderTicketMessages(messages) {
            if (!tMessages) return;
            const rows = Array.isArray(messages) ? messages : [];
            if (!rows.length) {
                tMessages.innerHTML = '<div class="muted">Sin mensajes</div>';
                return;
            }
            tMessages.innerHTML = '';
            for (const m of rows) {
                const wrap = document.createElement('div');
                wrap.className = 'msg';
                const meta = document.createElement('div');
                meta.className = 'msg-meta';
                meta.textContent = `${m.author_type === 'admin' ? 'Soporte' : 'Tú'} · ${m.created_at_madrid || m.created_at || ''}`;
                const body = document.createElement('div');
                body.className = 'msg-body';
                body.textContent = String(m.body || '');
                wrap.appendChild(meta);
                wrap.appendChild(body);
                tMessages.appendChild(wrap);
            }
            tMessages.scrollTop = tMessages.scrollHeight;
        }

        function renderTicketsList(tickets) {
            if (!ticketsList) return;
            const rows = Array.isArray(tickets) ? tickets : [];
            ticketsList.innerHTML = '';
            if (!rows.length) {
                const empty = document.createElement('div');
                empty.className = 'muted';
                empty.textContent = 'No tienes tickets todavía.';
                ticketsList.appendChild(empty);
                return;
            }
            for (const t of rows) {
                const item = document.createElement('div');
                item.className = 'ticket-item';
                    if (t.has_unread) item.style.borderColor = 'rgba(239,68,68,0.55)';
                const title = document.createElement('div');
                title.className = 'ticket-title';
                title.textContent = t.subject || '(sin asunto)';
                const meta = document.createElement('div');
                meta.className = 'ticket-meta';
                meta.textContent = `${t.status || ''} · ${t.priority || ''}${t.device_code ? ' · ' + t.device_code : ''}`;
                item.appendChild(title);
                item.appendChild(meta);
                item.addEventListener('click', async () => {
                    await selectTicket(t.id);
                });
                ticketsList.appendChild(item);
            }
        }

        async function loadTickets() {
            try {
                setSupportStatus('Cargando tickets...', false);
                const j = await supportApi('/api/tickets');
                renderTicketsList(j.tickets || []);
                if (selectedTicketId) await selectTicket(selectedTicketId, true);
                    await refreshSupportBadge();
                setSupportStatus('Listo.', false);
            } catch (e) {
                setSupportStatus(e.message || 'Error cargando tickets', true);
            }
        }

        async function selectTicket(id, silent = false) {
            const tid = String(id || '').trim();
            if (!tid) return;
            selectedTicketId = tid;
            try {
                if (!silent) setSupportStatus('Cargando ticket...', false);
                const j = await supportApi(`/api/tickets/${encodeURIComponent(tid)}`);
                safeText(tId, j.ticket?.id || tid);
                safeText(tStatus, j.ticket?.status || '');
                renderTicketMessages(j.messages || []);
                    try { await supportApi(`/api/tickets/${encodeURIComponent(tid)}/mark-read`, { method: 'POST' }); } catch {}
                    await refreshSupportBadge();
                if (!silent) setSupportStatus('Ticket cargado.', false);
            } catch (e) {
                if (!silent) setSupportStatus(e.message || 'Error', true);
            }
        }

        async function populateTicketDeviceSelect() {
            if (!tDevice) return;
            const select = document.getElementById('deviceSelect');
            // Mantener opción "sin dispositivo"
            const keep = [{ value: '', text: '(sin dispositivo)' }];
            const opts = select ? Array.from(select.options || []).map(o => ({ value: o.value, text: o.textContent })) : [];
            const all = keep.concat(opts.filter(o => o.value));
            tDevice.innerHTML = '';
            for (const o of all) {
                const opt = document.createElement('option');
                opt.value = o.value;
                opt.textContent = o.text;
                tDevice.appendChild(opt);
            }
        }

        async function createTicket() {
            try {
                setSupportStatus('Enviando ticket...', false);
                const payload = {
                    subject: String(tSubject.value || '').trim(),
                    device_code: String(tDevice.value || '').trim() || null,
                    message: String(tMessage.value || '').trim()
                };
                if (!payload.subject || payload.subject.length < 3) throw new Error('Asunto demasiado corto');
                if (!payload.message || payload.message.length < 3) throw new Error('Mensaje demasiado corto');

                const j = await supportApi('/api/tickets', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                tSubject.value = '';
                tMessage.value = '';
                selectedTicketId = j.ticket_id || null;
                await loadTickets();
                if (selectedTicketId) await selectTicket(selectedTicketId, true);
                setSupportStatus('Ticket creado.', false);
            } catch (e) {
                setSupportStatus(e.message || 'Error creando ticket', true);
            }
        }

        async function replyToTicket() {
            if (!selectedTicketId) return setSupportStatus('Selecciona un ticket.', true);
            const body = String(tReply.value || '').trim();
            if (!body) return setSupportStatus('Escribe un mensaje.', true);
            try {
                setSupportStatus('Enviando respuesta...', false);
                await supportApi(`/api/tickets/${encodeURIComponent(selectedTicketId)}/messages`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ body })
                });
                tReply.value = '';
                await selectTicket(selectedTicketId, true);
                await loadTickets();
                setSupportStatus('Enviado.', false);
            } catch (e) {
                setSupportStatus(e.message || 'Error', true);
            }
        }

        async function closeTicket() {
            if (!selectedTicketId) return setSupportStatus('Selecciona un ticket.', true);
            const ok = confirm('¿Seguro que quieres cerrar este ticket?');
            if (!ok) return;
            try {
                setSupportStatus('Cerrando...', false);
                await supportApi(`/api/tickets/${encodeURIComponent(selectedTicketId)}/close`, { method: 'POST' });
                await selectTicket(selectedTicketId, true);
                await loadTickets();
                setSupportStatus('Ticket cerrado.', false);
            } catch (e) {
                setSupportStatus(e.message || 'Error', true);
            }
        }

        async function doLogout() {
            try { await fetch('/api/auth/logout', { method: 'POST', credentials: 'include' }); } catch {}
            const next = encodeURIComponent(location.pathname + location.search + location.hash);
            window.location.href = `/login?next=${next}`;
        }

        async function loadProfileIntoForm() {
            try {
                setAccountStatus('Cargando...', false);
                const r = await fetch('/api/me/profile', { credentials: 'include' });
                if (r.status === 401) return doLogout();
                const p = await r.json().catch(() => ({}));
                accEmail.value = p.email || '';
                accFullName.value = p.full_name || '';
                accPhone.value = p.phone || '';
                accAddress.value = p.address || '';
                accProvince.value = p.province || '';
                accCity.value = p.city || '';
                accCountry.value = p.country || '';
                setAccountStatus('Listo.', false);
            } catch {
                setAccountStatus('No se pudo cargar tu perfil.', true);
            }
        }

        async function saveProfileFromForm() {
            try {
                setAccountStatus('Guardando...', false);
                const payload = {
                    full_name: String(accFullName.value || '').trim() || undefined,
                    phone: String(accPhone.value || '').trim() || null,
                    address: String(accAddress.value || '').trim() || null,
                    province: String(accProvince.value || '').trim() || null,
                    city: String(accCity.value || '').trim() || null,
                    country: String(accCountry.value || '').trim() || null
                };
                const r = await fetch('/api/me/profile', {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify(payload)
                });
                if (r.status === 401) return doLogout();
                const j = await r.json().catch(() => ({}));
                if (!r.ok) throw new Error(j.error || 'No se pudo guardar');
                setAccountStatus('Guardado.', false);
            } catch (e) {
                setAccountStatus(e.message || 'Error guardando.', true);
            }
        }

        async function deleteAccount() {
            const ok = confirm('¿Seguro que quieres eliminar tu cuenta? Esta acción no se puede deshacer.');
            if (!ok) return;
            try {
                setAccountStatus('Eliminando cuenta...', false);
                const r = await fetch('/api/me', { method: 'DELETE', credentials: 'include' });
                const j = await r.json().catch(() => ({}));
                if (!r.ok) throw new Error(j.error || 'No se pudo eliminar');
                window.location.href = '/login';
            } catch (e) {
                setAccountStatus(e.message || 'Error eliminando.', true);
            }
        }

        navDevicesBtn?.addEventListener('click', () => setView('devices'));
        navAccountBtn?.addEventListener('click', async () => {
            setView('account');
            await loadProfileIntoForm();
        });
        navSupportBtn?.addEventListener('click', async () => {
            setView('support');
            try {
                await loadDevices();
                await populateTicketDeviceSelect();
            } catch {}
            await loadTickets();
        });
        navLogoutBtn?.addEventListener('click', doLogout);
        btnSaveProfile?.addEventListener('click', saveProfileFromForm);
        btnDeleteAccount?.addEventListener('click', deleteAccount);
        btnCreateTicket?.addEventListener('click', createTicket);
        btnReplyTicket?.addEventListener('click', replyToTicket);
        btnCloseTicket?.addEventListener('click', closeTicket);

            // Polling ligero: badge de tickets no leídos
            setTimeout(() => { refreshSupportBadge(); }, 800);
            setInterval(() => { refreshSupportBadge(); }, 15000);

        function rebootsOffsetKey(code) { return `rebootsOffset:${code}`; }
        function getLocalRebootsOffset(code) {
            try {
                const v = localStorage.getItem(rebootsOffsetKey(code));
                if (v == null || v === '') return 0;
                const n = Number(v);
                return Number.isFinite(n) && n >= 0 ? n : 0;
            } catch { return 0; }
        }
        function setLocalRebootsOffset(code, offset) {
            try { localStorage.setItem(rebootsOffsetKey(code), String(Math.max(0, Number(offset) || 0))); } catch {}
        }

        let chartsRebuildTimer = null;
        function scheduleChartsRebuild() {
            if (chartsRebuildTimer) return;
            chartsRebuildTimer = setTimeout(() => {
                chartsRebuildTimer = null;
                rebuildCharts();
            }, 1200);
        }

        // --- Mini gráficas por planta (una por tarjeta) ---
        let zoneChartsRebuildTimer = null;
        const pendingZoneRebuilds = new Set();
        function scheduleZoneChartsRebuild(zoneNum) {
            if (Number.isFinite(Number(zoneNum))) pendingZoneRebuilds.add(Number(zoneNum));
            else pendingZoneRebuilds.add('all');

            if (zoneChartsRebuildTimer) return;
            zoneChartsRebuildTimer = setTimeout(() => {
                zoneChartsRebuildTimer = null;
                const doAll = pendingZoneRebuilds.has('all');
                const zones = doAll ? null : Array.from(pendingZoneRebuilds).filter(x => Number.isFinite(x));
                pendingZoneRebuilds.clear();
                rebuildZoneMiniCharts(zones);
            }, 700);
        }

        const DEFAULT_DEVICE = 'RIEGO_001';
        let deviceCode = (() => {
            const m = location.pathname.match(/\/panel\/([^\/?#]+)/);
            return m ? decodeURIComponent(m[1]) : DEFAULT_DEVICE;
        })();

        let hasDevices = true;

        function tokenStorageKey(code) { return `deviceToken:${code}`; }
        function getSavedToken(code) {
            try { return localStorage.getItem(tokenStorageKey(code)) || ''; } catch { return ''; }
        }
        function saveToken(code, token) {
            try { localStorage.setItem(tokenStorageKey(code), token || ''); } catch {}
        }

        function consumeTokenFromUrl() {
            try {
                const params = new URLSearchParams(location.search);
                const t = (params.get('token') || params.get('t') || '').trim();
                if (!t) return;
                saveToken(deviceCode, t);
                params.delete('token');
                params.delete('t');
                const qs = params.toString();
                const next = location.pathname + (qs ? `?${qs}` : '') + location.hash;
                history.replaceState({}, '', next);
            } catch {}
        }

        consumeTokenFromUrl();

        async function loadDevices() {
            const section = document.getElementById('deviceSection');
            const select = document.getElementById('deviceSelect');
            const meta = document.getElementById('deviceMeta');
            try {
                const r = await fetch('/api/devices', { credentials: 'include' });
                if (r.status === 401) {
                    const next = encodeURIComponent(location.pathname + location.search + location.hash);
                    window.location.href = `/login?next=${next}`;
                    return false;
                }
                const list = await r.json();

                if (!Array.isArray(list)) throw new Error('Sin lista');
                if (list.length === 0) {
                    hasDevices = false;
                    select.innerHTML = '';
                    meta.textContent = 'No hay dispositivos asignados a tu cuenta. Pulsa “+ Añadir dispositivo”.';
                    return true;
                }
                hasDevices = true;

                select.innerHTML = '';
                for (const d of list) {
                    const opt = document.createElement('option');
                    opt.value = d.device_code;
                    opt.textContent = `${d.device_code} — ${d.name || ''}`.trim();
                    select.appendChild(opt);
                }

                const exists = list.some(d => d.device_code === deviceCode);
                if (!exists) {
                    deviceCode = list[0].device_code;
                    history.replaceState({}, '', `/panel/${encodeURIComponent(deviceCode)}`);
                }
                select.value = deviceCode;

                const current = list.find(d => d.device_code === deviceCode);
                const lastSeen = current?.last_seen_madrid || (current?.last_seen ? new Date(current.last_seen).toLocaleString('es-ES', { timeZone: TZ, hour12: false }) : '--');
                const lastSeenDate = current?.last_seen ? parseTsToDate(current.last_seen) : null;
                const ageMin = lastSeenDate ? Math.max(0, Math.round((nowAdjusted().getTime() - lastSeenDate.getTime()) / 60000)) : null;
                const ageText = ageMin == null ? '' : ` (hace ${ageMin} min)`;
                meta.textContent = `${current?.name || deviceCode}${current?.location ? ' · ' + current.location : ''}`;

                select.addEventListener('change', () => {
                    const next = select.value;
                    if (next && next !== deviceCode) window.location.href = `/panel/${encodeURIComponent(next)}`;
                });

            } catch {
                if (section) section.style.display = 'none';
                return false;
            }

            return true;
        }

        async function loadChannels() {
            try {
                const r = await fetch(`/api/channels/${encodeURIComponent(deviceCode)}`);
                if (!r.ok) throw new Error('channels failed');
                const j = await r.json();
                channels = Array.isArray(j.channels) ? j.channels : [];

                const hums = channels.filter(c => c.kind === 'soil_sensor');
                const valves = channels.filter(c => c.kind === 'valve');

                const humSel = document.getElementById('humChannelSelect');
                const valveSel = document.getElementById('valveChannelSelect');
                humSel.innerHTML = '';
                valveSel.innerHTML = '';

                for (const c of hums) {
                    const opt = document.createElement('option');
                    opt.value = c.id;
                    opt.textContent = `${c.name} (${c.channel_index})`;
                    humSel.appendChild(opt);
                }
                for (const c of valves) {
                    const opt = document.createElement('option');
                    opt.value = c.id;
                    opt.textContent = `${c.name} (${c.channel_index})`;
                    valveSel.appendChild(opt);
                }

                if (!humChannelId || !hums.some(c => c.id === humChannelId)) humChannelId = hums[0]?.id || null;
                if (!valveChannelId || !valves.some(c => c.id === valveChannelId)) valveChannelId = valves[0]?.id || null;

                humSel.value = humChannelId || '';
                valveSel.value = valveChannelId || '';

                humSel.onchange = () => { humChannelId = humSel.value || null; scheduleChartsRebuild(); };
                valveSel.onchange = () => { valveChannelId = valveSel.value || null; scheduleChartsRebuild(); };

                // Comparador (máx 8 en la sección): poblar y restaurar selección + filtro por Planta
                for (const slot of CMP_SLOTS) {
                    const zoneSel = document.getElementById(`cmpZoneSelect${slot}`);
                    const chanSel = document.getElementById(`cmpChannelSelect${slot}`);

                    populateCompareZoneSelect(zoneSel);

                    const savedZone = getSavedCmpZone(slot);
                    cmpZoneBySlot[slot] = savedZone;
                    if (zoneSel) zoneSel.value = savedZone == null ? '' : String(savedZone);

                    populateCompareSelect(chanSel, savedZone);

                    let savedChan = getSavedCmpChannel(slot) || null;
                    if (chanSel && savedChan && !Array.from(chanSel.options).some(o => o.value === savedChan)) savedChan = null;
                    cmpChannelIdBySlot[slot] = savedChan;
                    if (chanSel) chanSel.value = savedChan || '';

                    if (zoneSel) zoneSel.onchange = () => {
                        const z = Number(zoneSel.value);
                        const zoneNum = Number.isFinite(z) && z >= 1 && z <= 8 ? z : null;
                        cmpZoneBySlot[slot] = zoneNum;
                        saveCmpZone(slot, zoneNum);
                        populateCompareSelect(chanSel, zoneNum);
                        cmpChannelIdBySlot[slot] = (chanSel && chanSel.value) ? chanSel.value : null;
                        saveCmpChannel(slot, cmpChannelIdBySlot[slot] || '');
                        scheduleChartsRebuild();
                    };
                    if (chanSel) chanSel.onchange = () => {
                        cmpChannelIdBySlot[slot] = chanSel.value || null;
                        saveCmpChannel(slot, cmpChannelIdBySlot[slot] || '');
                        scheduleChartsRebuild();
                    };

                    showCmpBox(slot, getCmpVisible(slot) || !!cmpChannelIdBySlot[slot]);
                }

                const renameHumBtn = document.getElementById('btnRenameHum');
                const renameValveBtn = document.getElementById('btnRenameValve');
                if (renameHumBtn) renameHumBtn.disabled = hums.length === 0;
                if (renameValveBtn) renameValveBtn.disabled = valves.length === 0;

                // Si no hay canales, ocultar gráficas (pero normalmente habrá canal 1 por defecto)
                document.getElementById('humChannelSelect').disabled = hums.length === 0;
                document.getElementById('valveChannelSelect').disabled = valves.length === 0;

                // Re-render zonas para actualizar selects/labels
                renderZonesUI();

            } catch (e) {
                // Si falla, no rompemos
            }
        }

        // --- Zona horaria España (Europe/Madrid) ---
        const TZ = 'Europe/Madrid';
        const fmtNowEs = new Intl.DateTimeFormat('es-ES', {
            timeZone: TZ,
            year: 'numeric', month: '2-digit', day: '2-digit',
            hour: '2-digit', minute: '2-digit', second: '2-digit',
            hour12: false
        });
        const fmtDateEs = new Intl.DateTimeFormat('es-ES', {
            timeZone: TZ,
            year: 'numeric', month: '2-digit', day: '2-digit'
        });

        // Si el reloj del PC está mal, ajustamos con la hora del servidor.
        let serverClockOffsetMs = null; // server_now_ms - Date.now()
        function nowAdjusted() {
            return new Date(Date.now() + (serverClockOffsetMs == null ? 0 : serverClockOffsetMs));
        }

        function setConnectionUI(status) {
            const s = (status || 'unknown').toString().toLowerCase();
            const pairs = [
                { dot: document.getElementById('connDot'), text: document.getElementById('connText') },
                { dot: document.getElementById('topConnDot'), text: document.getElementById('topConnText') }
            ].filter(p => p.dot && p.text);
            if (!pairs.length) return;

            for (const { dot, text } of pairs) {
                dot.classList.remove('online', 'offline', 'unknown');
                if (s === 'online') {
                    dot.classList.add('online');
                    text.textContent = 'Online';
                } else if (s === 'offline') {
                    dot.classList.add('offline');
                    text.textContent = 'Offline';
                } else {
                    dot.classList.add('unknown');
                    text.textContent = '--';
                }
            }

            if (s === 'online') {
            } else if (s === 'offline') {
            } else {
            }
        }

        // Cache del último payload de /api/channels/:device_code/latest
        let lastChannelsLatestPayload = null;

        function setStatusText(text) {
            const st = document.getElementById('status');
            const top = document.getElementById('topStatusText');
            if (st) st.textContent = text;
            if (top) top.textContent = text;
        }

        function setStatusClass(isOnline) {
            const st = document.getElementById('status');
            if (!st) return;
            st.className = isOnline ? 'status online' : 'status offline';
        }

        async function withBusy(btn, busyText, fn) {
            if (!btn) return fn();
            const prevText = btn.textContent;
            const prevDisabled = btn.disabled;
            btn.disabled = true;
            if (busyText) btn.textContent = busyText;
            try { return await fn(); }
            finally {
                btn.disabled = prevDisabled;
                btn.textContent = prevText;
            }
        }

        function initCollapsibles() {
            const sections = Array.from(document.querySelectorAll('.section'));
            for (const sec of sections) {
                if (sec.id === 'deviceSection') continue;
                // La sección de PLANTAS debe estar siempre visible (no colapsable)
                if (sec.id === 'zonesSection') continue;
                if (sec.dataset.collapsibleInit === '1') continue;

                const h2 = sec.querySelector('h2');
                if (!h2) continue;

                const head = document.createElement('div');
                head.className = 'section-head';

                const body = document.createElement('div');
                body.className = 'section-body';

                const title = (h2.textContent || '').trim() || 'section';
                const key = `ui:collapsed:${title}`;

                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = 'collapse-btn';
                const applyState = (collapsed) => {
                    sec.classList.toggle('collapsed', !!collapsed);
                    btn.textContent = collapsed ? 'Mostrar' : 'Ocultar';
                    try { localStorage.setItem(key, collapsed ? '1' : '0'); } catch {}
                    // Al mostrar/ocultar zonas, reconstruimos mini-gráficas de plantas visibles
                    try { scheduleZoneChartsRebuild(); } catch {}
                };

                const stored = (() => {
                    try { return localStorage.getItem(key); } catch { return null; }
                })();
                const initialCollapsed = stored === '1';
                applyState(initialCollapsed);

                btn.addEventListener('click', () => applyState(!sec.classList.contains('collapsed')));

                // Reestructurar DOM: h2 + botón en head; el resto dentro de body
                head.appendChild(h2);
                head.appendChild(btn);

                const toMove = [];
                for (const child of Array.from(sec.childNodes)) {
                    if (child === h2) continue;
                    if (child.nodeType === 3 && String(child.textContent || '').trim() === '') continue;
                    toMove.push(child);
                }
                for (const n of toMove) body.appendChild(n);

                sec.appendChild(head);
                sec.appendChild(body);
                sec.dataset.collapsibleInit = '1';
            }
        }

        function getMadridParts(date) {
            const parts = new Intl.DateTimeFormat('sv-SE', {
                timeZone: TZ,
                year: 'numeric', month: '2-digit', day: '2-digit',
                hour: '2-digit', minute: '2-digit',
                hourCycle: 'h23'
            }).formatToParts(date);
            const m = Object.fromEntries(parts.map(p => [p.type, p.value]));
            return { y: m.year, mo: m.month, d: m.day, h: m.hour, mi: m.minute };
        }

        function tzOffsetMsAt(date, timeZone) {
            // Devuelve offset (tz - UTC) en ms para el instante `date`.
            const parts = new Intl.DateTimeFormat('sv-SE', {
                timeZone,
                year: 'numeric', month: '2-digit', day: '2-digit',
                hour: '2-digit', minute: '2-digit', second: '2-digit',
                hourCycle: 'h23'
            }).formatToParts(date);
            const m = Object.fromEntries(parts.map(p => [p.type, p.value]));
            const asUTC = Date.UTC(
                Number(m.year),
                Number(m.month) - 1,
                Number(m.day),
                Number(m.hour),
                Number(m.minute),
                Number(m.second)
            );
            return asUTC - date.getTime();
        }

        function madridZonedTimeToUtcDate({ y, mo, d, h = 0, mi = 0, s = 0 }) {
            // Convierte una fecha/hora de calendario (Europe/Madrid) a Date (UTC instant).
            const utcGuess = Date.UTC(Number(y), Number(mo) - 1, Number(d), Number(h), Number(mi), Number(s));
            let offset = tzOffsetMsAt(new Date(utcGuess), TZ);
            let result = utcGuess - offset;
            const offset2 = tzOffsetMsAt(new Date(result), TZ);
            if (offset2 !== offset) result = utcGuess - offset2;
            return new Date(result);
        }

        function daysInMadridMonthFromParts({ y, mo }) {
            const yy = Number(y);
            const mm = Number(mo);
            if (!Number.isFinite(yy) || !Number.isFinite(mm)) return 31;
            return new Date(Date.UTC(yy, mm, 0)).getUTCDate();
        }

        function madridDayKeyFromParts({ y, mo, d }) {
            return `${String(y)}-${pad2(Number(mo))}-${pad2(Number(d))}`;
        }

        function getMadridPartsFull(date) {
            const parts = new Intl.DateTimeFormat('sv-SE', {
                timeZone: TZ,
                year: 'numeric', month: '2-digit', day: '2-digit',
                hour: '2-digit', minute: '2-digit', second: '2-digit',
                hourCycle: 'h23'
            }).formatToParts(date);
            const m = Object.fromEntries(parts.map(p => [p.type, p.value]));
            return { y: m.year, mo: m.month, d: m.day, h: m.hour, mi: m.minute, s: m.second };
        }

        function parseTsToDate(ts) {
            if (ts == null) return null;
            if (ts instanceof Date) return ts;
            if (typeof ts === 'number') {
                // Heurística: si viene en segundos (muy pequeño), convertir a ms
                const ms = ts < 1e12 ? ts * 1000 : ts;
                const d = new Date(ms);
                return Number.isNaN(d.getTime()) ? null : d;
            }
            const d = new Date(String(ts));
            return Number.isNaN(d.getTime()) ? null : d;
        }
        function pad2(n) { return String(n).padStart(2, '0'); }
        function formatUptimeSeconds(sec) {
            const n = Number(sec);
            if (!Number.isFinite(n) || n < 0) return '--';
            return formatDuration(n * 1000);
        }
        function formatDuration(ms) {
            const s = Math.floor(ms / 1000);
            const hh = Math.floor(s / 3600);
            const mm = Math.floor((s % 3600) / 60);
            const ss = s % 60;
            if (hh > 0) return `${hh}h ${pad2(mm)}m ${pad2(ss)}s`;
            if (mm > 0) return `${mm}m ${pad2(ss)}s`;
            return `${ss}s`;
        }

        function formatIntervalSeconds(sec) {
            const n = Number(sec);
            if (!Number.isFinite(n) || n <= 0) return '--';
            // Mostrar compacto: segundos si < 90s, si no duración
            if (n < 90) return `${Math.round(n)}s`;
            return formatDuration(n * 1000);
        }

        function escapeHtml(s) {
            return String(s ?? '').replace(/[&<>"']/g, (c) => ({
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#39;'
            }[c]));
        }

        function setChips(el, chips) {
            if (!el) return;
            const arr = Array.isArray(chips) ? chips.filter(Boolean) : [];
            if (arr.length === 0) {
                el.innerHTML = '';
                return;
            }
            el.innerHTML = arr.map(c => {
                const variant = c.variant ? ` chip-${escapeHtml(c.variant)}` : '';
                const title = c.title ? ` title="${escapeHtml(c.title)}"` : '';
                const k = c.k == null ? '' : `<span class="k">${escapeHtml(c.k)}</span>`;
                const v = c.v == null ? '' : `<span class="v">${escapeHtml(c.v)}</span>`;
                return `<span class="chip${variant}"${title}>${k}${v}</span>`;
            }).join('');
        }

        function setMetricStateById(valueId, state, title) {
            const valueEl = document.getElementById(valueId);
            const card = valueEl ? valueEl.closest('.sensor-card') : null;
            if (!card) return;
            card.classList.remove('metric-good', 'metric-warn', 'metric-bad', 'metric-neutral');
            card.classList.add(state);
            if (title) card.title = title;
        }

        function updateThresholdCard() {
            const el = document.getElementById('uptime');
            if (!el) return;
            const t = Number(config.threshold);
            el.textContent = Number.isFinite(t) ? String(Math.round(t)) : '--';
            // Colorear el valor del umbral para que destaque
            // (bajo = verde, medio = amarillo, alto = rojo)
            if (!Number.isFinite(t)) {
                setMetricStateById('uptime', 'metric-neutral', 'Umbral de humedad baja configurado');
            } else if (t <= 30) {
                setMetricStateById('uptime', 'metric-good', 'Umbral bajo');
            } else if (t <= 50) {
                setMetricStateById('uptime', 'metric-warn', 'Umbral medio');
            } else {
                setMetricStateById('uptime', 'metric-bad', 'Umbral alto');
            }
        }

        function updateConnectedDeviceCards(data) {
            const createdAt = parseTsToDate(data?.created_at);
            const createdAtLabel = (data && data.created_at_madrid)
                ? String(data.created_at_madrid)
                : (createdAt ? createdAt.toLocaleString('es-ES', { timeZone: TZ, hour12: false }) : '--');

            // OLED meta (chips compactos, sin texto repetido)
            const oledMeta = document.getElementById('oledMeta');
            const createdMs = createdAt ? createdAt.getTime() : null;
            let deltaSec = null;
            if (createdMs != null && lastSampleMsForInterval != null) {
                const d = (createdMs - lastSampleMsForInterval) / 1000;
                // Ignorar valores raros (p.ej. reloj cambiado / lecturas duplicadas)
                if (Number.isFinite(d) && d > 0.5 && d < 3600) deltaSec = d;
            }
            if (createdMs != null) lastSampleMsForInterval = createdMs;

            const pLast = createdAt ? getMadridPartsFull(createdAt) : null;
            const lastTimeTxt = pLast ? `${pLast.h}:${pLast.mi}:${pLast.s}` : '--';
            const nowTxt = fmtNowEs.format(nowAdjusted());
            setChips(oledMeta, [
                { k: 'Δ', v: (deltaSec == null ? '--' : formatIntervalSeconds(deltaSec)), variant: (deltaSec != null && deltaSec <= 90) ? 'ok' : 'neutral', title: 'Tiempo entre lecturas (aprox.)' },
                { k: 'Últ', v: lastTimeTxt, variant: (createdAtLabel === '--') ? 'neutral' : 'ok', title: createdAtLabel === '--' ? '' : createdAtLabel },
                { k: 'Now', v: String(nowTxt).slice(-8), variant: 'neutral' },
            ]);

            const uptimeEl = document.getElementById('uptime');

            // Sensores/válvulas activos (dato reciente) según /api/channels/:device_code/latest
            try {
                const ch = Array.isArray(lastChannelsLatestPayload?.channels) ? lastChannelsLatestPayload.channels : [];
                let soilTotal = 0;
                let valveTotal = 0;
                for (const c of ch) {
                    const kind = String(c?.kind || '');
                    if (kind === 'soil_sensor') {
                        soilTotal++;
                    }
                    if (kind === 'valve') {
                        valveTotal++;
                    }
                }

                if (uptimeEl) {
                    const sTxt = `${soilTotal} ${soilTotal === 1 ? 'sensor' : 'sensores'}`;
                    const vTxt = `${valveTotal} ${valveTotal === 1 ? 'válvula' : 'válvulas'}`;
                    uptimeEl.textContent = `${sTxt}\n${vTxt}`;
                }
                const uptimeMeta = document.getElementById('uptimeMeta');
                setChips(uptimeMeta, []);
            } catch {
                if (uptimeEl) uptimeEl.textContent = '--';
                const uptimeMeta = document.getElementById('uptimeMeta');
                setChips(uptimeMeta, []);
            }

            const ipEl = document.getElementById('ip');
            if (ipEl) {
                const ip = (data && data.ip != null) ? String(data.ip).trim() : '';
                ipEl.textContent = ip || '--';
            }

            const ipMeta = document.getElementById('ipMeta');
            setChips(ipMeta, [
                { k: 'Red', v: 'LAN', variant: 'neutral' },
                { k: 'OK', v: (ipEl && ipEl.textContent && ipEl.textContent !== '--') ? 'sí' : '—', variant: (ipEl && ipEl.textContent && ipEl.textContent !== '--') ? 'ok' : 'neutral' },
            ]);

            const heapEl = document.getElementById('heap');
            if (heapEl) {
                const hb = (data?.heap_free == null ? null : Number(data.heap_free));
                const kb = (hb == null || Number.isNaN(hb)) ? null : Math.max(0, Math.round(hb / 1024));
                heapEl.textContent = kb == null ? '--' : String(kb);
            }

            const heapMeta = document.getElementById('heapMeta');
            setChips(heapMeta, [
                { k: 'Unidad', v: 'KB', variant: 'neutral' },
                { k: 'Libre', v: (heapEl && heapEl.textContent) ? heapEl.textContent : '--', variant: 'neutral' },
            ]);

            // WiFi: SSID + RSSI
            {
                const ssidRaw = (data && (data.wifi_ssid != null ? data.wifi_ssid : (data.ssid != null ? data.ssid : null)));
                const ssid = ssidRaw == null ? '' : String(ssidRaw).trim();
                const rssi = (data?.wifi_rssi == null ? null : Number(data.wifi_rssi));
                const rssiOk = !(rssi == null || Number.isNaN(rssi) || rssi === 0);
                const rssiEl = document.getElementById('rssi');
                const wifiConnected = !!ssid || rssiOk;
                if (rssiEl) {
                    // Mostrar el SSID grande (lo que el usuario quiere ver)
                    rssiEl.textContent = ssid ? ssid : (rssiOk ? `${Math.trunc(rssi)} dBm` : 'SIN WIFI');
                    // Evitar que una red larga rompa layout
                    rssiEl.style.wordBreak = 'break-word';
                }
                const wifiMeta = document.getElementById('wifiMeta');
                const rssiTxt = rssiOk ? `${Math.trunc(rssi)} dBm` : '-- dBm';
                const rssiVariant = !rssiOk ? 'neutral' : (rssi >= -60 ? 'ok' : (rssi >= -75 ? 'warn' : 'bad'));
                setChips(wifiMeta, [
                    { k: 'RSSI', v: rssiTxt, variant: rssiVariant },
                    { k: 'Estado', v: wifiConnected ? 'OK' : 'NO', variant: wifiConnected ? 'ok' : 'bad' },
                ]);
            }

            // Pantalla OLED (aprox: como OLED para PLANTA 1)
            try {
                const panel = document.getElementById('oledPanel');
                if (panel) {
                    const z0 = zonesState && zonesState[0] ? zonesState[0] : null;
                    const soilIdx = (z0 && z0.soil_channel_index != null) ? Number(z0.soil_channel_index) : 1;
                    const valveIdx = (z0 && z0.valve_channel_index != null) ? Number(z0.valve_channel_index) : 1;
                    const thr = (z0 && z0.humidity_low_threshold != null) ? Number(z0.humidity_low_threshold) : null;

                    const ch = Array.isArray(lastChannelsLatestPayload?.channels) ? lastChannelsLatestPayload.channels : [];
                    const byKey = new Map();
                    for (const c of ch) {
                        const kind = String(c?.kind || '');
                        const idx = Number(c?.channel_index);
                        if (!kind || !Number.isFinite(idx)) continue;
                        byKey.set(`${kind}:${idx}`, c?.latest || null);
                    }

                    const soilLatest = byKey.get(`soil_sensor:${soilIdx}`) || null;
                    const valveLatest = byKey.get(`valve:${valveIdx}`) || null;

                    const hum = soilLatest?.value == null ? null : Number(soilLatest.value);
                    const humTxt = Number.isFinite(hum) ? `${hum.toFixed(1)}%` : '--%';
                    const thrTxt = Number.isFinite(thr) ? `${Math.round(thr)}%` : '--%';

                    const st = valveLatest?.state == null ? null : Number(valveLatest.state);
                    const valveTxt = (st == null || Number.isNaN(st)) ? '--' : (st >= 1 ? 'ON' : 'OFF');

                    const v = (data?.voltage == null ? null : Number(data.voltage));
                    const vTxt = (v == null || Number.isNaN(v)) ? '--.-V' : `${v.toFixed(2)}V`;
                    const rssi = (data?.wifi_rssi == null ? null : Number(data.wifi_rssi));
                    const rssiTxt = (rssi == null || Number.isNaN(rssi) || rssi === 0) ? '--dBm' : `${Math.trunc(rssi)}dBm`;
                    const ssidRaw = (data && (data.wifi_ssid != null ? data.wifi_ssid : (data.ssid != null ? data.ssid : null)));
                    const ssid = ssidRaw == null ? '' : String(ssidRaw).trim();

                    const now = nowAdjusted();
                    const p = getMadridPartsFull(now);
                    const timeTxt = `${p.h}:${p.mi}:${p.s}`;
                    const ip = (data && data.ip != null) ? String(data.ip).trim() : '';

                    const ssidShort = ssid ? ssid.slice(0, 10) : '';
                    const ipShort = ip ? ip : '';
                    panel.innerHTML =
                        `<span class="oled-k">OLED</span> <span class="oled-v">${escapeHtml(timeTxt)}</span><br>` +
                        `<span class="oled-k">PL1</span> <span class="oled-k">HUM</span> <span class="oled-v oled-v-hum">${escapeHtml(humTxt)}</span>  <span class="oled-k">UMBRAL</span> <span class="oled-v oled-v-thr">${escapeHtml(thrTxt)}</span><br>` +
                        `<span class="oled-k">VAL</span> <span class="oled-v oled-v-valve">${escapeHtml(valveTxt)}</span>   <span class="oled-k">V</span> <span class="oled-v oled-v-v">${escapeHtml(vTxt)}</span><br>` +
                        `<span class="oled-k">WiFi</span> <span class="oled-v oled-v-wifi">${escapeHtml(rssiTxt)}${ssidShort ? ` ${escapeHtml(ssidShort)}` : ''}</span>${ipShort ? `  <span class="oled-k">IP</span> <span class="oled-v oled-v-ip">${escapeHtml(ipShort)}</span>` : ''}`;
                }
            } catch {
                const panel = document.getElementById('oledPanel');
                if (panel) panel.textContent = '--';
            }
        }

        // --- Persistencia ("datos que va recibiendo") ---
        const STORE_KEY = 'riego_stats_v1';
        function loadStore() {
            try {
                const raw = localStorage.getItem(STORE_KEY);
                if (!raw) return { minutes: {}, days: {}, months: {}, last: null };
                const obj = JSON.parse(raw);
                return {
                    minutes: obj.minutes || {},
                    days: obj.days || {},
                    months: obj.months || {},
                    last: obj.last || null
                };
            } catch {
                return { minutes: {}, days: {}, months: {}, last: null };
            }
        }
        function saveStore(store) {
            localStorage.setItem(STORE_KEY, JSON.stringify(store));
        }
        function ensureBucket(map, key) {
            if (!map[key]) map[key] = { humSum: 0, humCount: 0, valveOnMs: 0 };
            return map[key];
        }
        function pruneStore(store) {
            const dayKeys = Object.keys(store.days).sort();
            if (dayKeys.length > 370) {
                for (let i = 0; i < dayKeys.length - 370; i++) delete store.days[dayKeys[i]];
            }
            const monthKeys = Object.keys(store.months).sort();
            if (monthKeys.length > 36) {
                for (let i = 0; i < monthKeys.length - 36; i++) delete store.months[monthKeys[i]];
            }
            // minutes: mantener últimos 2 días (según keys de days)
            const keepDays = new Set(dayKeys.slice(-2));
            const minuteKeys = Object.keys(store.minutes);
            for (const mk of minuteKeys) {
                const dayPart = mk.slice(0, 10);
                if (!keepDays.has(dayPart)) delete store.minutes[mk];
            }
        }
        function ingestSample(store, sampleMs, humidity, valveIsOn) {
            const now = new Date(sampleMs);
            const p = getMadridParts(now);
            const dayKey = `${p.y}-${p.mo}-${p.d}`;
            const monthKey = `${p.y}-${p.mo}`;
            const minuteKey = `${dayKey}T${p.h}:${p.mi}`;

            // Tiempo ON entre muestras (usamos el estado anterior)
            let dt = 0;
            if (store.last && typeof store.last.t === 'number') {
                dt = Math.max(0, sampleMs - store.last.t);
            }
            const prevOn = store.last ? !!store.last.on : false;
            const onMs = prevOn ? dt : 0;

            const bMin = ensureBucket(store.minutes, minuteKey);
            const bDay = ensureBucket(store.days, dayKey);
            const bMonth = ensureBucket(store.months, monthKey);

            bMin.valveOnMs += onMs;
            bDay.valveOnMs += onMs;
            bMonth.valveOnMs += onMs;

            if (!Number.isNaN(humidity)) {
                bMin.humSum += humidity; bMin.humCount += 1;
                bDay.humSum += humidity; bDay.humCount += 1;
                bMonth.humSum += humidity; bMonth.humCount += 1;
            }

            store.last = { t: sampleMs, on: !!valveIsOn };
            pruneStore(store);
            saveStore(store);
        }

        // --- Modo de visualización ---
        let viewMode = 'day'; // day | month | year
        function setActiveModeButtons(mode) {
            document.getElementById('btnDia').classList.toggle('active', mode === 'day');
            document.getElementById('btnMes').classList.toggle('active', mode === 'month');
            document.getElementById('btnAno').classList.toggle('active', mode === 'year');
        }
        setActiveModeButtons(viewMode);

        document.getElementById('btnDia').addEventListener('click', () => { viewMode = 'day'; setActiveModeButtons(viewMode); rebuildCharts(); });
        document.getElementById('btnMes').addEventListener('click', () => { viewMode = 'month'; setActiveModeButtons(viewMode); rebuildCharts(); });
        document.getElementById('btnAno').addEventListener('click', () => { viewMode = 'year'; setActiveModeButtons(viewMode); rebuildCharts(); });

        // --- Datos para Chart.js ---
        const humLabels = [];
        const humSeries = [];
        const valveLabels = [];
        const valveSeries = [];
        function setSeries(labels, series, newLabels, newSeries) {
            labels.length = 0;
            series.length = 0;
            for (const x of newLabels) labels.push(x);
            for (const y of newSeries) series.push(y);
        }

        // Preparar wrappers de scroll (móvil/tablet modo DÍA)
        applyTimelineScrollForCanvas(document.getElementById('humChart'), viewMode);
        applyTimelineScrollForCanvas(document.getElementById('valveChart'), viewMode);

        const humChart = new Chart(document.getElementById('humChart'), {
            type: 'line',
            data: {
                labels: humLabels,
                datasets: [{
                    label: 'Humedad (%)',
                    data: humSeries,
                    borderColor: '#22c55e',
                    backgroundColor: 'rgba(34, 197, 94, 0.15)',
                    fill: true,
                    tension: 0.25,
                    pointRadius: 0
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                plugins: { legend: { display: false } },
                scales: {
                    y: {
                        min: 0,
                        max: 100,
                        ticks: {
                            color: '#fff',
                            stepSize: 5,
                            callback: (v) => `${v}%`
                        },
                        grid: { color: 'rgba(255,255,255,0.06)' }
                    },
                    x: {
                        ticks: {
                            color: '#fff',
                            autoSkip: true,
                            callback: viewMode === 'day' ? tickEvery30Minutes : undefined,
                            maxTicksLimit: viewMode === 'day' ? 16 : 10,
                            maxRotation: 0,
                            minRotation: 0,
                            backdropColor: 'rgba(0,0,0,0)',
                            showLabelBackdrop: false
                        },
                        grid: { color: 'rgba(255,255,255,0.04)' }
                    }
                }
            }
        });

        const valveChart = new Chart(document.getElementById('valveChart'), {
            type: 'line',
            data: {
                labels: valveLabels,
                datasets: [{
                    label: 'Válvula (0/1)',
                    data: valveSeries,
                    borderColor: '#fb7185',
                    backgroundColor: 'rgba(251, 113, 133, 0.12)',
                    fill: true,
                    stepped: true,
                    tension: 0,
                    pointRadius: 0
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                plugins: { legend: { display: false } },
                scales: {
                    y: {
                        min: 0,
                        max: 1,
                        ticks: {
                            color: '#fff',
                            stepSize: 1,
                            callback: (v) => (v >= 0.5 ? 'ON' : 'OFF')
                        },
                        grid: { color: 'rgba(255,255,255,0.06)' }
                    },
                    x: {
                        ticks: {
                            color: '#fff',
                            autoSkip: true,
                            callback: viewMode === 'day' ? tickEvery30Minutes : undefined,
                            maxTicksLimit: viewMode === 'day' ? 16 : 10,
                            maxRotation: 0,
                            minRotation: 0,
                            backdropColor: 'rgba(0,0,0,0)',
                            showLabelBackdrop: false
                        },
                        grid: { color: 'rgba(255,255,255,0.04)' }
                    }
                }
            }
        });

        // --- Comparador (máx 8 gráficas en la sección: 2 base + 6 extra) ---
        const CMP_SLOTS = [3, 4, 5, 6, 7, 8];
        const cmpChannelIdBySlot = {};
        const cmpZoneBySlot = {};
        const cmpLabelsBySlot = {};
        const cmpSeriesBySlot = {};
        const cmpChartsBySlot = {};

        const CMP_PALETTE = {
            3: { border: '#60a5fa', fill: 'rgba(96,165,250,0.14)' },
            4: { border: '#a78bfa', fill: 'rgba(167,139,250,0.14)' },
            5: { border: '#22d3ee', fill: 'rgba(34,211,238,0.14)' },
            6: { border: '#fbbf24', fill: 'rgba(251,191,36,0.14)' },
            7: { border: '#f472b6', fill: 'rgba(244,114,182,0.14)' },
            8: { border: '#fb923c', fill: 'rgba(251,146,60,0.14)' }
        };

        for (const slot of CMP_SLOTS) {
            cmpChannelIdBySlot[slot] = null;
            cmpZoneBySlot[slot] = null;
            cmpLabelsBySlot[slot] = [];
            cmpSeriesBySlot[slot] = [];
        }

        function createCompareChart(canvasId, labels, series, { border, fill } = {}) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return null;
            applyTimelineScrollForCanvas(canvas, viewMode);
            return new Chart(canvas, {
                type: 'line',
                data: {
                    labels,
                    datasets: [{
                        label: '',
                        data: series,
                        borderColor: border || '#60a5fa',
                        backgroundColor: fill || 'rgba(96,165,250,0.14)',
                        fill: true,
                        tension: 0.25,
                        pointRadius: 0,
                        stepped: false
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        y: {
                            min: 0,
                            ticks: { color: '#fff' },
                            grid: { color: 'rgba(255,255,255,0.06)' }
                        },
                        x: {
                            ticks: {
                                color: '#fff',
                                autoSkip: true,
                                callback: viewMode === 'day' ? tickEvery30Minutes : undefined,
                                maxTicksLimit: viewMode === 'day' ? 16 : 10,
                                maxRotation: 0,
                                minRotation: 0,
                                backdropColor: 'rgba(0,0,0,0)',
                                showLabelBackdrop: false
                            },
                            grid: { color: 'rgba(255,255,255,0.04)' }
                        }
                    }
                }
            });
        }

        for (const slot of CMP_SLOTS) {
            const pal = CMP_PALETTE[slot] || CMP_PALETTE[3];
            cmpChartsBySlot[slot] = createCompareChart(`cmpChart${slot}`, cmpLabelsBySlot[slot], cmpSeriesBySlot[slot], pal);
        }

        // --- Mini charts por planta (por tarjeta) ---
        const zoneMiniCharts = new Map();

        // Modo de visualización por planta (independiente)
        const zoneViewMode = new Map();
        function getZoneViewMode(zoneNum) {
            const m = zoneViewMode.get(Number(zoneNum));
            return (m === 'day' || m === 'month' || m === 'year') ? m : 'day';
        }
        function setActiveZoneModeButtons(zoneNum, mode) {
            const z = Number(zoneNum);
            const bD = document.getElementById(`zoneBtnDia${z}`);
            const bM = document.getElementById(`zoneBtnMes${z}`);
            const bY = document.getElementById(`zoneBtnAno${z}`);
            if (bD) bD.classList.toggle('active', mode === 'day');
            if (bM) bM.classList.toggle('active', mode === 'month');
            if (bY) bY.classList.toggle('active', mode === 'year');
        }
        function setZoneViewMode(zoneNum, mode) {
            const z = Number(zoneNum);
            if (!Number.isFinite(z) || z < 1 || z > 8) return;
            if (mode !== 'day' && mode !== 'month' && mode !== 'year') return;
            zoneViewMode.set(z, mode);
            setActiveZoneModeButtons(z, mode);
            scheduleZoneChartsRebuild(z);
            try { updateZoneSummary(z); } catch {}
        }

        function destroyZoneMiniCharts() {
            for (const v of zoneMiniCharts.values()) {
                try { v.chart?.destroy(); } catch {}
            }
            zoneMiniCharts.clear();
        }

        function getChannelIdByKindIndex(kind, idx) {
            const n = Number(idx);
            if (!kind || !Number.isFinite(n)) return null;
            const c = (channels || []).find(x => x && x.kind === kind && Number(x.channel_index) === n);
            return c ? c.id : null;
        }

        function getChannelNameByKindIndex(kind, idx) {
            const n = Number(idx);
            if (!kind || !Number.isFinite(n)) return null;
            const c = (channels || []).find(x => x && x.kind === kind && Number(x.channel_index) === n);
            if (!c) return null;
            const nm = (c.name == null) ? '' : String(c.name).trim();
            return nm || null;
        }

        function setText(id, text) {
            const el = document.getElementById(id);
            if (!el) return;
            el.textContent = text;
        }

        function setMetaValue(id, valueText, { muted = false } = {}) {
            const el = document.getElementById(id);
            if (!el) return;
            const v = el.querySelector('span[data-role="value"]');
            if (!v) {
                el.textContent = String(valueText ?? '');
                return;
            }
            v.textContent = String(valueText ?? '');
            v.classList.toggle('meta-muted', !!muted);
        }

        function withDiaPrefixLabel(label) {
            const s = (label == null) ? '' : String(label).trim();
            if (!s) return s;
            if (/^d[ií]a\b/i.test(s)) return s;
            // Formato típico: "31 15:52" o "31 15:52:10"
            if (/^\d{1,2}\s+\d{1,2}:\d{2}/.test(s)) return `día ${s}`;
            return s;
        }

        function tickEvery30Minutes(value) {
            try {
                const label = this && typeof this.getLabelForValue === 'function'
                    ? this.getLabelForValue(value)
                    : String(value);
                const m = String(label).match(/(\d{1,2}):(\d{2})/);
                if (!m) return label;
                const min = Number(m[2]);
                if (!Number.isFinite(min)) return label;
                if (min % 30 !== 0) return '';
                const hh = String(m[1]).padStart(2, '0');
                return `${hh}:${m[2]}`;
            } catch {
                return '';
            }
        }

        // --- Scroll horizontal en móvil/tablet (modo DÍA) ---
        function isSmallViewport() {
            try { return window.matchMedia && window.matchMedia('(max-width: 900px)').matches; } catch { return false; }
        }

        function ensureChartScrollDomForCanvas(canvas) {
            if (!canvas) return null;
            const wrap = canvas.closest('.chart-wrap');
            if (!wrap) return null;

            let inner = null;
            try { inner = wrap.querySelector(':scope > .chart-inner'); } catch { inner = wrap.querySelector('.chart-inner'); }
            if (!inner) {
                inner = document.createElement('div');
                inner.className = 'chart-inner';
                wrap.appendChild(inner);
            }

            if (canvas.parentElement !== inner) inner.appendChild(canvas);

            // Auto-seguimiento: si el usuario scrollea y se queda lejos del final, dejamos de “seguir”.
            if (wrap.dataset.scrollFollowInit !== '1') {
                wrap.dataset.scrollFollowInit = '1';
                wrap.dataset.follow = '1';
                wrap.addEventListener('scroll', () => {
                    try {
                        wrap.dataset.lastUserScroll = String(Date.now());
                        const max = Math.max(0, wrap.scrollWidth - wrap.clientWidth);
                        const nearEnd = (max - wrap.scrollLeft) <= 24;
                        wrap.dataset.follow = nearEnd ? '1' : '0';
                    } catch {}
                }, { passive: true });
            }

            return { wrap, inner };
        }

        function applyTimelineScrollForCanvas(canvas, mode) {
            const s = ensureChartScrollDomForCanvas(canvas);
            if (!s) return;

            const enable = isSmallViewport() && mode === 'day';
            s.wrap.classList.toggle('scroll-x', !!enable);

            if (enable) {
                const base = 1440; // px aprox como referencia visual
                const w = Math.max(base, Math.round((s.wrap.clientWidth || 0) * 1.8));
                s.inner.style.width = `${w}px`;
            } else {
                s.inner.style.width = '100%';
                try { s.wrap.scrollLeft = 0; } catch {}
                try { s.wrap.dataset.follow = '1'; } catch {}
            }
        }

        function scrollCanvasToNowIfFollowing(canvas, mode) {
            if (!(isSmallViewport() && mode === 'day')) return;
            const s = ensureChartScrollDomForCanvas(canvas);
            if (!s) return;
            if (s.wrap.dataset.follow === '0') return;
            const lastUser = Number(s.wrap.dataset.lastUserScroll || 0);
            if (Number.isFinite(lastUser) && lastUser > 0 && (Date.now() - lastUser) < 5000) return;

            try {
                const p = getMadridParts(nowAdjusted());
                const minute = (Number(p?.h) * 60 + Number(p?.mi));
                if (!Number.isFinite(minute)) return;

                const ratio = Math.max(0, Math.min(1, minute / 1439));
                const max = Math.max(0, s.wrap.scrollWidth - s.wrap.clientWidth);
                const xNow = ratio * (s.wrap.scrollWidth || 0);
                const target = Math.max(0, Math.min(max, Math.round(xNow - s.wrap.clientWidth + 24)));
                s.wrap.scrollLeft = target;
            } catch {}
        }

        function buildMadridDayAxisLabels(pNow) {
            const d = String(pNow?.d ?? '').trim();
            const labels = new Array(1440);
            for (let i = 0; i < 1440; i++) {
                const hh = pad2(Math.floor(i / 60));
                const mm = pad2(i % 60);
                labels[i] = d ? `día ${d} ${hh}:${mm}` : `${hh}:${mm}`;
            }
            return labels;
        }

        function minuteIndexToHHMM(minuteIndex) {
            const i = Number(minuteIndex);
            if (!Number.isFinite(i)) return '';
            const clamped = Math.max(0, Math.min(1439, Math.trunc(i)));
            const hh = pad2(Math.floor(clamped / 60));
            const mm = pad2(clamped % 60);
            return `${hh}:${mm}`;
        }

        function initMiniChartDayAxis(entry, pNow) {
            if (!entry) return;

            // Para mini-gráficas en DÍA usamos X lineal (0..1439) con puntos {x,y}
            entry.labels.length = 0;
            entry.series.length = 0;
            entry.ts.length = 0;
            for (let i = 0; i < 1440; i++) entry.series.push({ x: i, y: null });
            for (let i = 0; i < 1440; i++) entry.ts.push(null);

            try {
                // Guardamos el día actual en el entry (por si hay cambio de día)
                entry.dayKey = `${pNow?.y ?? ''}-${pNow?.mo ?? ''}-${pNow?.d ?? ''}`;
            } catch {}
        }

        function madridMinuteIndexForTs(ts, pNow) {
            const d = parseTsToDate(ts);
            if (!d) return null;
            const p = getMadridParts(d);
            if (!p || !pNow) return null;
            if (String(p.y) !== String(pNow.y) || String(p.mo) !== String(pNow.mo) || String(p.d) !== String(pNow.d)) return null;
            const h = Number(p.h);
            const mi = Number(p.mi);
            if (!Number.isFinite(h) || !Number.isFinite(mi)) return null;
            const idx = h * 60 + mi;
            return (idx >= 0 && idx < 1440) ? idx : null;
        }

        function prettyKind(kind) {
            const k = String(kind || '').toLowerCase();
            if (k === 'soil_sensor') return 'Humedad suelo';
            if (k === 'humidity_air') return 'Humedad aire';
            if (k === 'temperature_air') return 'Temp. aire';
            if (k === 'temperature_soil') return 'Temp. tierra';
            if (k === 'ph_soil') return 'pH tierra';
            if (k === 'ec_soil') return 'EC tierra';
            if (k === 'valve') return 'Válvula';
            return k || 'Sensor';
        }

        function cmpStorageKey(slot) { return `ui:cmp:${deviceCode}:${slot}`; }
        function cmpZoneKey(slot) { return `ui:cmpZone:${deviceCode}:${slot}`; }
        function cmpVisibleKey(slot) { return `ui:cmpVisible:${deviceCode}:${slot}`; }
        function getCmpVisible(slot) {
            try { return localStorage.getItem(cmpVisibleKey(slot)) === '1'; } catch { return false; }
        }
        function setCmpVisible(slot, v) {
            try { localStorage.setItem(cmpVisibleKey(slot), v ? '1' : '0'); } catch {}
        }
        function getSavedCmpChannel(slot) {
            try { return localStorage.getItem(cmpStorageKey(slot)) || ''; } catch { return ''; }
        }
        function saveCmpChannel(slot, id) {
            try { localStorage.setItem(cmpStorageKey(slot), id || ''); } catch {}
        }
        function getSavedCmpZone(slot) {
            try {
                const s = localStorage.getItem(cmpZoneKey(slot)) || '';
                const z = Number(s);
                return Number.isFinite(z) && z >= 1 && z <= 8 ? z : null;
            } catch {
                return null;
            }
        }
        function saveCmpZone(slot, zoneNum) {
            try { localStorage.setItem(cmpZoneKey(slot), zoneNum == null ? '' : String(zoneNum)); } catch {}
        }

        function showCmpBox(slot, show) {
            const box = document.getElementById(`cmpBox${slot}`);
            if (box) box.style.display = show ? '' : 'none';
            setCmpVisible(slot, show);
            try {
                if (show) cmpChartsBySlot?.[slot]?.resize();
            } catch {}
        }

        function populateCompareZoneSelect(sel) {
            if (!sel) return;
            sel.innerHTML = '';
            const all = document.createElement('option');
            all.value = '';
            all.textContent = 'Todas';
            sel.appendChild(all);
            for (let z = 1; z <= 8; z++) {
                const opt = document.createElement('option');
                opt.value = String(z);
                opt.textContent = `Planta ${z}`;
                sel.appendChild(opt);
            }
        }

        function getZoneAssignedChannelIds(zoneNum) {
            const z = Number(zoneNum);
            if (!Number.isFinite(z) || z < 1 || z > 8) return null;
            if (!Array.isArray(zonesState) || !zonesState[z - 1]) return null;

            const zone = zonesState[z - 1];
            const defs = [
                { kind: 'soil_sensor', prop: 'soil_channel_index' },
                { kind: 'valve', prop: 'valve_channel_index' },
                { kind: 'humidity_air', prop: 'humidity_air_channel_index' },
                { kind: 'temperature_air', prop: 'temperature_air_channel_index' },
                { kind: 'temperature_soil', prop: 'temperature_soil_channel_index' },
                { kind: 'ph_soil', prop: 'ph_soil_channel_index' },
                { kind: 'ec_soil', prop: 'ec_soil_channel_index' }
            ];

            const ids = [];
            for (const d of defs) {
                const idx = zone?.[d.prop];
                const id = getChannelIdByKindIndex(d.kind, idx);
                if (id && !ids.includes(id)) ids.push(id);
            }
            return ids;
        }

        function populateCompareSelect(sel, zoneNum = null) {
            if (!sel) return;
            const allowed = new Set(['soil_sensor', 'valve', 'humidity_air', 'temperature_air', 'temperature_soil', 'ph_soil', 'ec_soil']);
            let list = (channels || []).filter(c => c && allowed.has(String(c.kind || '').toLowerCase()));

            const zoneIds = getZoneAssignedChannelIds(zoneNum);
            if (Array.isArray(zoneIds)) {
                if (zoneIds.length === 0) list = [];
                else list = list.filter(c => zoneIds.includes(c.id));
            }

            sel.innerHTML = '';
            const empty = document.createElement('option');
            empty.value = '';
            empty.textContent = '—';
            sel.appendChild(empty);

            if (!list.length && Array.isArray(zoneIds)) {
                const none = document.createElement('option');
                none.value = '';
                none.textContent = 'Sin sensores asignados a esta planta';
                none.disabled = true;
                sel.appendChild(none);
                return;
            }

            for (const c of list) {
                const opt = document.createElement('option');
                opt.value = c.id;
                opt.textContent = `${prettyKind(c.kind)} · ${c.name} (${c.channel_index})`;
                sel.appendChild(opt);
            }
        }

        function initCompareButtons() {
            const addBtn = document.getElementById('cmpAddBtn');

            for (const slot of CMP_SLOTS) {
                const rm = document.getElementById(`cmpRemove${slot}`);
                if (!rm) continue;
                rm.addEventListener('click', () => {
                    cmpChannelIdBySlot[slot] = null;
                    saveCmpChannel(slot, '');
                    const sel = document.getElementById(`cmpChannelSelect${slot}`);
                    if (sel) sel.value = '';
                    showCmpBox(slot, false);
                    scheduleChartsRebuild();
                });
            }

            async function addCompareChartByModal() {
                const picked = await pickCompareGraphModal().catch(() => null);
                if (!picked) return;

                let slotToUse = null;
                for (const slot of CMP_SLOTS) {
                    const box = document.getElementById(`cmpBox${slot}`);
                    const visible = !!box && box.style.display !== 'none';
                    if (!visible) { slotToUse = slot; break; }
                }
                if (!slotToUse) {
                    alert('Máximo 8 gráficas.');
                    return;
                }

                const slot = slotToUse;
                showCmpBox(slot, true);

                // Aplicar planta + sensor a este slot (y persistir)
                cmpZoneBySlot[slot] = picked.zone;
                saveCmpZone(slot, picked.zone);

                const zoneSel = document.getElementById(`cmpZoneSelect${slot}`);
                const chSel = document.getElementById(`cmpChannelSelect${slot}`);
                if (zoneSel) zoneSel.value = picked.zone == null ? '' : String(picked.zone);

                // Repoblar sensores según planta
                populateCompareSelect(chSel, picked.zone);
                if (chSel) chSel.value = String(picked.channelId);

                cmpChannelIdBySlot[slot] = String(picked.channelId);
                saveCmpChannel(slot, String(picked.channelId));

                scheduleChartsRebuild();
                try { document.getElementById(`cmpBox${slot}`)?.scrollIntoView({ behavior: 'smooth', block: 'start' }); } catch {}
            }

            if (addBtn) addBtn.addEventListener('click', () => { addCompareChartByModal(); });
        }

        function sectionStorageKey(sec) {
            try {
                const h2 = sec ? sec.querySelector('h2') : null;
                const title = (h2 && h2.textContent ? String(h2.textContent) : '').trim() || 'section';
                return `ui:collapsed:${title}`;
            } catch {
                return null;
            }
        }

        function setSectionCollapsed(sec, collapsed) {
            if (!sec) return;
            sec.classList.toggle('collapsed', !!collapsed);
            const btn = sec.querySelector('.collapse-btn');
            if (btn) btn.textContent = collapsed ? 'Mostrar' : 'Ocultar';
            const key = sectionStorageKey(sec);
            if (key) {
                try { localStorage.setItem(key, collapsed ? '1' : '0'); } catch {}
            }
        }

        function areAllZoneSectionsCollapsed() {
            for (let z = 1; z <= 8; z++) {
                const sec = document.getElementById(`zoneSec${z}`);
                if (!sec) continue;
                if (!sec.classList.contains('collapsed')) return false;
            }
            return true;
        }

        function setAllZoneSectionsCollapsed(collapsed) {
            for (let z = 1; z <= 8; z++) {
                const sec = document.getElementById(`zoneSec${z}`);
                if (!sec) continue;
                setSectionCollapsed(sec, collapsed);
            }
            try { scheduleZoneChartsRebuild(); } catch {}
        }

        function updateZonesToggleAllBtn() {
            const btn = document.getElementById('zonesToggleAllBtn');
            if (!btn) return;
            const allCollapsed = areAllZoneSectionsCollapsed();
            btn.textContent = allCollapsed ? 'Mostrar todas las plantas' : 'Ocultar todas las plantas';
        }

        function getZoneControlsOpen(zoneNum) {
            const z = Number(zoneNum);
            if (!Number.isFinite(z)) return false;
            const key = `ui:zoneControls:${z}`;
            try {
                const v = localStorage.getItem(key);
                // Por defecto: oculto
                return v === '1';
            } catch {
                return false;
            }
        }

        function setZoneControlsOpen(zoneNum, open) {
            const z = Number(zoneNum);
            if (!Number.isFinite(z)) return;
            const wrap = document.getElementById(`zoneControls${z}`);
            if (wrap) wrap.classList.toggle('open', !!open);
            const btn = document.getElementById(`zoneControlsBtn${z}`);
            if (btn) {
                btn.classList.toggle('active', !!open);
                btn.textContent = open ? 'Ocultar controles' : 'Mostrar controles';
            }
            const key = `ui:zoneControls:${z}`;
            try { localStorage.setItem(key, open ? '1' : '0'); } catch {}
        }

        function updateZoneCardMeta(zoneNum) {
            const z = Number(zoneNum);
            if (!Number.isFinite(z) || z < 1 || z > 8) return;
            const zi = z - 1;
            const st = zonesState?.[zi];
            if (!st) return;

            const defs = [
                { base: 'zoneHum', kind: 'soil_sensor', idx: st.soil_channel_index, unit: '%', decimals: 1, isValve: false },
                { base: 'zoneTSoil', kind: 'temperature_soil', idx: st.temperature_soil_channel_index, unit: '°C', decimals: 1, isValve: false },
                { base: 'zoneTAir', kind: 'temperature_air', idx: st.temperature_air_channel_index, unit: '°C', decimals: 1, isValve: false },
                { base: 'zoneHAir', kind: 'humidity_air', idx: st.humidity_air_channel_index, unit: '%', decimals: 1, isValve: false },
                { base: 'zonePH', kind: 'ph_soil', idx: st.ph_soil_channel_index, unit: 'pH', decimals: 2, isValve: false },
                { base: 'zoneEC', kind: 'ec_soil', idx: st.ec_soil_channel_index, unit: 'mS/cm', decimals: 2, isValve: false },
                { base: 'zoneValve', kind: 'valve', idx: st.valve_channel_index, unit: '', decimals: 0, isValve: true }
            ];

            for (const d of defs) {
                const nameElId = `${d.base}Name${z}`;
                const avgElId = `${d.base}Avg${z}`;
                const lastElId = `${d.base}Last${z}`;
                const canvasId = `${d.base}Chart${z}`;

                if (d.idx == null) {
                    setText(nameElId, 'Sin asignar');
                    setMetaValue(avgElId, '--', { muted: true });
                    setMetaValue(lastElId, '--', { muted: true });
                    continue;
                }

                const nm = getChannelNameByKindIndex(d.kind, d.idx);
                setText(nameElId, nm ? `${nm} (${d.idx})` : `${String(d.idx)}`);

                const entry = zoneMiniCharts.get(canvasId);
                if (!entry || !entry.meta) {
                    setMetaValue(avgElId, '--', { muted: true });
                    setMetaValue(lastElId, '--', { muted: true });
                    continue;
                }

                if (d.isValve) {
                    const ms = Number(entry.meta.valveOnMs);
                    setMetaValue(avgElId, Number.isFinite(ms) && ms > 0 ? formatDuration(ms) : '--', { muted: !(Number.isFinite(ms) && ms > 0) });
                } else {
                    const sum = Number(entry.meta.sum);
                    const cnt = Number(entry.meta.count);
                    if (Number.isFinite(sum) && Number.isFinite(cnt) && cnt > 0) {
                        const avg = sum / cnt;
                        const decimals = Number.isFinite(Number(d.decimals)) ? Number(d.decimals) : 2;
                        const unitTxt = !d.unit ? '' : ((d.unit === '%' || d.unit === '°C' || d.unit === 'pH') ? d.unit : ` ${d.unit}`);
                        setMetaValue(avgElId, `${avg.toFixed(decimals)}${unitTxt}`);
                    } else {
                        setMetaValue(avgElId, '--', { muted: true });
                    }
                }

                const lastMs = Number(entry.meta.lastDateMs);
                if (Number.isFinite(lastMs) && lastMs > 0) {
                    const base = formatLastPointText('day', new Date(lastMs), entry.meta.lastLabel || '');
                    const ageMin = Math.max(0, Math.round((nowAdjusted().getTime() - lastMs) / 60000));
                    const stale = Number.isFinite(ageMin) && ageMin > 10;
                    const txt = `${base}${Number.isFinite(ageMin) ? ` (hace ${ageMin} min)` : ''}${stale ? ' · DATOS ANTIGUOS' : ''}`;
                    setMetaValue(lastElId, txt, { muted: stale });
                } else {
                    setMetaValue(lastElId, '--', { muted: true });
                }
            }
        }

        function miniLabelForDate(d, mode) {
            const p = getMadridPartsFull(d);
            if (mode === 'day') return `${p.h}:${p.mi}`;
            return `${p.h}:${p.mi}`;
        }

        function ensureMiniChart(canvasId, { stepped = false, yMin = undefined, yMax = undefined, yTickCb = undefined, yTickStep = undefined, mode = 'day' } = {}) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return null;

            // Scroll horizontal en móvil/tablet (modo DÍA)
            applyTimelineScrollForCanvas(canvas, mode);
            scrollCanvasToNowIfFollowing(canvas, mode);

            if (zoneMiniCharts.has(canvasId)) {
                const e = zoneMiniCharts.get(canvasId);
                try {
                    if (e?.chart) {
                        const wantDay = mode === 'day';
                        const curType = e.chart?.options?.scales?.x?.type || 'category';
                        const needType = wantDay ? 'linear' : 'category';
                        if (curType !== needType) {
                            try { e.chart.destroy(); } catch {}
                            zoneMiniCharts.delete(canvasId);
                            return ensureMiniChart(canvasId, { stepped, yMin, yMax, yTickCb, yTickStep, mode });
                        }

                        e.chart.data.datasets[0].stepped = !!stepped;
                        e.chart.data.datasets[0].tension = stepped ? 0 : 0.25;
                        e.chart.options.scales.y.min = yMin;
                        e.chart.options.scales.y.max = yMax;
                        e.chart.options.scales.y.ticks.callback = yTickCb;
                        e.chart.options.scales.y.ticks.stepSize = yTickStep;
                        e.chart.options.scales.y.ticks.color = '#fff';
                        e.chart.options.scales.x.ticks.color = '#fff';

                        if (mode === 'day') {
                            e.chart.options.scales.x.type = 'linear';
                            e.chart.options.scales.x.min = 0;
                            e.chart.options.scales.x.max = 1439;
                            e.chart.options.scales.x.ticks.autoSkip = false;
                            e.chart.options.scales.x.ticks.stepSize = (isSmallViewport() ? 60 : 120);
                            e.chart.options.scales.x.ticks.maxTicksLimit = (isSmallViewport() ? 25 : 13);
                            e.chart.options.scales.x.ticks.includeBounds = true;
                            e.chart.options.scales.x.ticks.callback = (v) => minuteIndexToHHMM(v);
                        } else {
                            e.chart.options.scales.x.type = 'category';
                            delete e.chart.options.scales.x.min;
                            delete e.chart.options.scales.x.max;
                            e.chart.options.scales.x.ticks.autoSkip = true;
                            e.chart.options.scales.x.ticks.maxTicksLimit = 8;
                            e.chart.options.scales.x.ticks.callback = undefined;
                            delete e.chart.options.scales.x.ticks.stepSize;
                            delete e.chart.options.scales.x.ticks.includeBounds;
                        }

                        e.chart.options.scales.x.ticks.maxRotation = 0;
                        e.chart.options.scales.x.ticks.minRotation = 0;
                        e.chart.options.scales.x.ticks.backdropColor = 'rgba(0,0,0,0)';
                        e.chart.options.scales.x.ticks.showLabelBackdrop = false;
                        e.mode = mode;
                        try { e.chart.resize(); } catch {}
                    }
                } catch {}
                return e;
            }

            const card = canvas.closest('.sensor-card');
            const cs = card ? getComputedStyle(card) : null;
            const accent = cs ? (cs.getPropertyValue('--accent').trim() || '#60a5fa') : '#60a5fa';
            const accentSoft = cs ? (cs.getPropertyValue('--accent-soft').trim() || 'rgba(96,165,250,0.14)') : 'rgba(96,165,250,0.14)';

            const labels = [];
            const series = [];
            const ts = [];

            const chart = new Chart(canvas, {
                type: 'line',
                data: {
                    labels,
                    datasets: [{
                        label: '',
                        data: series,
                        borderColor: accent,
                        backgroundColor: accentSoft,
                        fill: true,
                        stepped: !!stepped,
                        tension: stepped ? 0 : 0.25,
                        pointRadius: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            enabled: true,
                            callbacks: mode === 'day' ? {
                                title: (items) => {
                                    try {
                                        const it = items && items[0] ? items[0] : null;
                                        const x = it && it.parsed && typeof it.parsed.x === 'number' ? it.parsed.x : null;
                                        if (x == null) return '';
                                        return minuteIndexToHHMM(x);
                                    } catch {
                                        return '';
                                    }
                                }
                            } : undefined
                        }
                    },
                    scales: {
                        y: {
                            min: yMin,
                            max: yMax,
                            ticks: {
                                color: '#fff',
                                callback: yTickCb,
                                stepSize: yTickStep,
                                maxTicksLimit: 8
                            },
                            grid: { color: 'rgba(255,255,255,0.06)' }
                        },
                        x: {
                            type: mode === 'day' ? 'linear' : 'category',
                            min: mode === 'day' ? 0 : undefined,
                            max: mode === 'day' ? 1439 : undefined,
                            ticks: {
                                color: '#fff',
                                autoSkip: mode === 'day' ? false : true,
                                stepSize: mode === 'day' ? 120 : undefined,
                                maxTicksLimit: mode === 'day' ? 13 : 8,
                                includeBounds: mode === 'day' ? true : undefined,
                                callback: mode === 'day' ? (v) => minuteIndexToHHMM(v) : undefined,
                                maxRotation: 0,
                                minRotation: 0,
                                backdropColor: 'rgba(0,0,0,0)',
                                showLabelBackdrop: false
                            },
                            grid: { color: 'rgba(255,255,255,0.04)' }
                        }
                    }
                }
            });

            // Reaplicar scroll (por si el canvas se reparentó en el DOM)
            applyTimelineScrollForCanvas(canvas, mode);
            scrollCanvasToNowIfFollowing(canvas, mode);

            const entry = {
                chart,
                labels,
                series,
                ts,
                lastTsMs: null,
                mode,
                dayKey: null,
                meta: { sum: 0, count: 0, valveOnMs: 0, lastDateMs: null, lastLabel: '' }
            };

            // En modo DÍA queremos eje completo 00:00..23:59 siempre
            if (mode === 'day') {
                try {
                    const pNow = getMadridParts(nowAdjusted());
                    initMiniChartDayAxis(entry, pNow);
                } catch {}
            }
            zoneMiniCharts.set(canvasId, entry);
            return entry;
        }

        async function loadMiniChartHistory(canvasId, channelId, { kind, mode = 'day' } = {}) {
            if (!channelId) return;

            let step = 'raw';
            let limit = 900;
            if (mode === 'day') { step = '1m'; limit = 2000; }
            else { step = '1h'; limit = 2500; }

            const range = rangeForMode(mode);
            const rangeQs = (range && range.from && range.to)
                ? `&from=${encodeURIComponent(range.from.toISOString())}&to=${encodeURIComponent(range.to.toISOString())}`
                : '';

            const url = `/api/channel/history/${encodeURIComponent(deviceCode)}/${encodeURIComponent(channelId)}?step=${encodeURIComponent(step)}&limit=${limit}${rangeQs}`;
            const r = await fetch(url, { credentials: 'include' });
            if (!r.ok) return;
            const payload = await r.json().catch(() => null);
            const rows = Array.isArray(payload?.rows) ? payload.rows : [];

            const entry = zoneMiniCharts.get(canvasId);
            if (!entry) return;

            const labels = [];
            const series = [];
            const tsArr = [];
            let lastTsMs = null;

            // Meta para resumen
            let totalSum = 0;
            let totalCount = 0;
            let totalValveOnMs = 0;

            if (mode === 'day') {
                const pNow = getMadridParts(nowAdjusted());
                try {
                    entry.dayKey = `${pNow?.y ?? ''}-${pNow?.mo ?? ''}-${pNow?.d ?? ''}`;
                } catch {}
                const sArr = new Array(1440);
                const tArr = new Array(1440).fill(null);
                for (let i = 0; i < 1440; i++) sArr[i] = { x: i, y: null };

                let prevT = null;
                let prevOn = false;

                for (const row of rows) {
                    const d = parseTsToDate(row?.ts);
                    if (!d) continue;
                    const tsMs = d.getTime();
                    lastTsMs = tsMs;
                    tsArr.push(tsMs);

                    const idx = madridMinuteIndexForTs(row?.ts, pNow);
                    if (idx == null) continue;
                    tArr[idx] = tsMs;

                    if (kind === 'valve') {
                        const onNow = Number(row?.state || 0) >= 1;
                        sArr[idx].y = onNow ? 1 : 0;

                        if (prevT != null) {
                            const dt = Math.max(0, tsMs - prevT);
                            if (prevOn) totalValveOnMs += dt;
                        }
                        prevT = tsMs;
                        prevOn = onNow;
                    } else {
                        const v = row?.value == null ? null : Number(row.value);
                        if (Number.isFinite(v)) { totalSum += v; totalCount += 1; }
                        sArr[idx].y = Number.isFinite(v) ? v : null;
                    }
                }

                // En DÍA usamos serie de puntos {x,y} y X lineal fijo
                for (const y of sArr) series.push(y);
                // labels se queda vacío (no se usa en escala lineal)

                // Guardar timestamps por minuto (útil para debug y para deltas futuros)
                entry.ts.length = 0;
                for (const t of tArr) entry.ts.push(t);
            } else if (mode === 'month') {
                // Agrupar por día
                if (kind === 'valve') {
                    const byDay = {};
                    for (const row of rows) {
                        const k = row?.ts_madrid_day_key || dayKeyForTs(row?.ts);
                        const b = byDay[k] || (byDay[k] = { on: 0, cnt: 0 });
                        const on = Number(row?.state || 0) >= 1 ? 1 : 0;
                        b.on += on;
                        b.cnt += 1;
                    }
                    const pNow = getMadridParts(nowAdjusted());
                    const daysInMonth = daysInMadridMonthFromParts({ y: pNow.y, mo: pNow.mo });
                    for (let day = 1; day <= daysInMonth; day++) {
                        const k = `${pNow.y}-${pNow.mo}-${pad2(day)}`;
                        labels.push(pad2(day));
                        const b = byDay[k] || null;
                        const onHours = b && b.cnt ? (b.on / b.cnt) * 24 : null;
                        series.push(onHours == null ? null : Number(onHours.toFixed(2)));
                        if (onHours != null) totalValveOnMs += onHours * 3600000;
                    }
                } else {
                    const byDay = {};
                    for (const row of rows) {
                        const k = row?.ts_madrid_day_key || dayKeyForTs(row?.ts);
                        const b = byDay[k] || (byDay[k] = { sum: 0, cnt: 0 });
                        const v = row?.value == null ? null : Number(row.value);
                        if (!Number.isFinite(v)) continue;
                        b.sum += v;
                        b.cnt += 1;
                        totalSum += v;
                        totalCount += 1;
                    }
                    const pNow = getMadridParts(nowAdjusted());
                    const daysInMonth = daysInMadridMonthFromParts({ y: pNow.y, mo: pNow.mo });
                    for (let day = 1; day <= daysInMonth; day++) {
                        const k = `${pNow.y}-${pNow.mo}-${pad2(day)}`;
                        labels.push(pad2(day));
                        const b = byDay[k] || null;
                        const avg = b && b.cnt ? (b.sum / b.cnt) : null;
                        series.push(avg == null ? null : Number(avg.toFixed(2)));
                    }
                }

                const lastRow = rows.length ? rows[rows.length - 1] : null;
                const dLast = lastRow ? parseTsToDate(lastRow.ts) : null;
                lastTsMs = dLast ? dLast.getTime() : null;
            } else {
                // year: agrupar por mes
                if (kind === 'valve') {
                    const byMonth = {};
                    for (const row of rows) {
                        const k = row?.ts_madrid_month_key || monthKeyForTs(row?.ts);
                        const b = byMonth[k] || (byMonth[k] = { on: 0, cnt: 0 });
                        const on = Number(row?.state || 0) >= 1 ? 1 : 0;
                        b.on += on;
                        b.cnt += 1;
                    }
                    const keys = Object.keys(byMonth).sort();
                    for (const k of keys) {
                        labels.push(k.slice(5, 7));
                        const b = byMonth[k];
                        const onHours = b && b.cnt ? (b.on / b.cnt) * (30 * 24) : 0;
                        series.push(Number(onHours.toFixed(1)));
                        totalValveOnMs += onHours * 3600000;
                    }
                } else {
                    const byMonth = {};
                    for (const row of rows) {
                        const k = row?.ts_madrid_month_key || monthKeyForTs(row?.ts);
                        const b = byMonth[k] || (byMonth[k] = { sum: 0, cnt: 0 });
                        const v = row?.value == null ? null : Number(row.value);
                        if (!Number.isFinite(v)) continue;
                        b.sum += v;
                        b.cnt += 1;
                        totalSum += v;
                        totalCount += 1;
                    }
                    const keys = Object.keys(byMonth).sort();
                    for (const k of keys) {
                        labels.push(k.slice(5, 7));
                        const b = byMonth[k];
                        const avg = b && b.cnt ? (b.sum / b.cnt) : null;
                        series.push(avg == null ? null : Number(avg.toFixed(2)));
                    }
                }

                const lastRow = rows.length ? rows[rows.length - 1] : null;
                const dLast = lastRow ? parseTsToDate(lastRow.ts) : null;
                lastTsMs = dLast ? dLast.getTime() : null;
            }

            entry.labels.length = 0;
            entry.series.length = 0;
            if (mode !== 'day') entry.ts.length = 0;
            for (const x of labels) entry.labels.push(x);
            for (const y of series) entry.series.push(y);
            if (mode !== 'day') {
                for (const t of tsArr) entry.ts.push(t);
            }
            entry.lastTsMs = lastTsMs;
            entry.mode = mode;

            entry.meta = entry.meta || { sum: 0, count: 0, valveOnMs: 0, lastDateMs: null, lastLabel: '' };
            entry.meta.sum = totalSum;
            entry.meta.count = totalCount;
            entry.meta.valveOnMs = totalValveOnMs;
            entry.meta.lastDateMs = lastTsMs;
            if (mode === 'day' && lastTsMs != null) {
                const pLast = getMadridPartsFull(new Date(lastTsMs));
                entry.meta.lastLabel = withDiaPrefixLabel(`día ${pLast.d} ${pLast.h}:${pLast.mi}`);
            } else {
                entry.meta.lastLabel = labels.length ? String(labels[labels.length - 1]) : '';
            }

            entry.chart.update('none');

            try {
                const m = String(canvasId).match(/^zone(Hum|Valve)Chart(\d+)$/);
                if (m) updateZoneSummary(Number(m[2]));
            } catch {}
        }

        function ingestMiniChartPoint(canvasId, latest, { kind } = {}) {
            const entry = zoneMiniCharts.get(canvasId);
            if (!entry) return;
            if (entry.mode && entry.mode !== 'day') return;
            const tsMs = (() => {
                const d = parseTsToDate(latest?.ts);
                if (d) return d.getTime();
                // Fallback robusto: si el backend nos da edad, reconstruimos el instante
                const ageMin = Number(latest?.age_minutes);
                if (Number.isFinite(ageMin) && ageMin >= 0) {
                    return nowAdjusted().getTime() - Math.round(ageMin) * 60000;
                }
                // Último recurso (evita quedarnos clavados por parseos raros)
                const d2 = parseTsToDate(latest?.ts_raw || latest?.ts_madrid);
                return d2 ? d2.getTime() : null;
            })();
            if (tsMs == null || !Number.isFinite(tsMs)) return;
            if (entry.lastTsMs != null && tsMs <= entry.lastTsMs) return;

            const val = (kind === 'valve')
                ? (latest?.state == null ? null : (Number(latest.state) >= 1 ? 1 : 0))
                : (latest?.value == null ? null : Number(latest.value));

            entry.meta = entry.meta || { sum: 0, count: 0, valveOnMs: 0, lastDateMs: null, lastLabel: '' };
            if (kind === 'valve') {
                // Tiempo ON basado en delta con el último timestamp real
                const prevT = Number(entry.lastTsMs);
                const prevIdx = (() => {
                    try {
                        const pNow = getMadridParts(nowAdjusted());
                        const lastIdx = (entry.lastTsMs != null) ? madridMinuteIndexForTs(entry.lastTsMs, pNow) : null;
                        return lastIdx;
                    } catch {
                        return null;
                    }
                })();
                if (Number.isFinite(prevT) && prevIdx != null) {
                    const prevV = entry.series?.[prevIdx];
                    const prevOn = Number((prevV && typeof prevV === 'object') ? prevV.y : prevV) >= 0.5;
                    const dt = Math.max(0, tsMs - prevT);
                    if (prevOn) entry.meta.valveOnMs = (Number(entry.meta.valveOnMs) || 0) + dt;
                }
            } else {
                const n = Number(val);
                if (Number.isFinite(n)) {
                    entry.meta.sum = (Number(entry.meta.sum) || 0) + n;
                    entry.meta.count = (Number(entry.meta.count) || 0) + 1;
                }
            }

            // Escribir el dato en su minuto del día (00:00..23:59)
            const pNow = getMadridParts(nowAdjusted());
            // Si ha cambiado el día en Madrid, reiniciar para evitar puntos “fantasma” de ayer
            try {
                const curKey = `${pNow?.y ?? ''}-${pNow?.mo ?? ''}-${pNow?.d ?? ''}`;
                if (entry.dayKey && curKey && entry.dayKey !== curKey) {
                    initMiniChartDayAxis(entry, pNow);
                    entry.lastTsMs = null;
                    entry.meta = { sum: 0, count: 0, valveOnMs: 0, lastDateMs: null, lastLabel: '' };
                }
                entry.dayKey = curKey;
            } catch {}
            let idx = madridMinuteIndexForTs(tsMs, pNow);
            if (idx == null) {
                // Si el timestamp viene en una TZ rara o hay desfase, al menos dibujamos “ahora”
                idx = (Number(pNow?.h) * 60 + Number(pNow?.mi));
                if (!Number.isFinite(idx) || idx < 0 || idx >= 1440) return;
            }

            // Inicializar si venía de una versión anterior sin eje completo
            const needsInit = (() => {
                if (!Array.isArray(entry.series) || entry.series.length !== 1440) return true;
                const first = entry.series[0];
                return !(first && typeof first === 'object' && 'x' in first && 'y' in first);
            })();
            if (needsInit) {
                try {
                    initMiniChartDayAxis(entry, pNow);
                } catch {}
            }

            if (entry.series[idx] && typeof entry.series[idx] === 'object') {
                entry.series[idx].y = (val == null || !Number.isFinite(val)) ? null : val;
            } else {
                entry.series[idx] = (val == null || !Number.isFinite(val)) ? null : val;
            }
            if (Array.isArray(entry.ts) && entry.ts.length === 1440) entry.ts[idx] = tsMs;
            entry.lastTsMs = tsMs;
            entry.meta.lastDateMs = tsMs;
            {
                const pLast = getMadridPartsFull(new Date(tsMs));
                entry.meta.lastLabel = withDiaPrefixLabel(`día ${pLast.d} ${pLast.h}:${pLast.mi}`);
            }

            entry.chart.update('none');

            try {
                const m = String(canvasId).match(/^zone([A-Za-z]+)Chart(\d+)$/);
                if (m) updateZoneCardMeta(Number(m[2]));
            } catch {}

            try {
                const m = String(canvasId).match(/^zone(Hum|Valve)Chart(\d+)$/);
                if (m) updateZoneSummary(Number(m[2]));
            } catch {}
        }

        async function rebuildZoneMiniCharts(zonesToRebuild) {
            if (!deviceCode) return;
            if (!Array.isArray(zonesState) || zonesState.length === 0) return;

            const defs = [
                { base: 'zoneHum', kind: 'soil_sensor', prop: 'soil_channel_index', canvas: (z) => `zoneHumChart${z}`, yMin: 0, yMax: 100, yTickStep: 5, yTickCb: (v) => `${v}%` },
                { base: 'zoneTSoil', kind: 'temperature_soil', prop: 'temperature_soil_channel_index', canvas: (z) => `zoneTSoilChart${z}`, yMin: 0, yMax: 60, yTickStep: 10 },
                { base: 'zoneTAir', kind: 'temperature_air', prop: 'temperature_air_channel_index', canvas: (z) => `zoneTAirChart${z}`, yMin: 0, yMax: 60, yTickStep: 10 },
                { base: 'zoneHAir', kind: 'humidity_air', prop: 'humidity_air_channel_index', canvas: (z) => `zoneHAirChart${z}`, yMin: 0, yMax: 100, yTickStep: 5, yTickCb: (v) => `${v}%` },
                { base: 'zonePH', kind: 'ph_soil', prop: 'ph_soil_channel_index', canvas: (z) => `zonePHChart${z}`, yMin: 0, yMax: 14 },
                { base: 'zoneEC', kind: 'ec_soil', prop: 'ec_soil_channel_index', canvas: (z) => `zoneECChart${z}` },
                { base: 'zoneValve', kind: 'valve', prop: 'valve_channel_index', canvas: (z) => `zoneValveChart${z}`, stepped: true }
            ];

            const wantedZones = Array.isArray(zonesToRebuild) && zonesToRebuild.length
                ? zonesToRebuild
                : [1, 2, 3, 4, 5, 6, 7, 8];

            for (const zoneNumRaw of wantedZones) {
                const zoneNum = Number(zoneNumRaw);
                if (!Number.isFinite(zoneNum) || zoneNum < 1 || zoneNum > 8) continue;
                const i = zoneNum - 1;

                const sec = document.getElementById(`zoneSec${zoneNum}`);
                if (sec && sec.classList.contains('collapsed')) continue;

                const z = zonesState[i];
                if (!z) continue;

                const mode = getZoneViewMode(zoneNum);
                setActiveZoneModeButtons(zoneNum, mode);

                for (const def of defs) {
                    const canvasId = def.canvas(zoneNum);
                    const idx = z[def.prop];
                    // Siempre mostrar mini-gráfica: si no hay asignación, dejamos placeholder (apagada)
                    if (idx == null) {
                        let yMin = def.yMin;
                        let yMax = def.yMax;
                        let yTickCb = def.yTickCb;
                        let yTickStep = def.yTickStep;

                        if (def.kind === 'valve') {
                            if (mode === 'day') {
                                yMin = 0;
                                yMax = 1;
                                yTickCb = (v) => (Number(v) >= 0.5 ? 'ON' : 'OFF');
                                yTickStep = 1;
                            } else {
                                yMin = 0;
                                yMax = undefined;
                                yTickCb = undefined;
                                yTickStep = undefined;
                            }
                        }

                        const e = ensureMiniChart(canvasId, { stepped: def.stepped, yMin, yMax, yTickCb, yTickStep, mode });
                        if (e) {
                            e.labels.length = 0;
                            e.series.length = 0;
                            e.ts.length = 0;
                            e.lastTsMs = null;
                            e.mode = mode;
                            e.meta = { sum: 0, count: 0, valveOnMs: 0, lastDateMs: null, lastLabel: '' };
                            try { e.chart.update('none'); } catch {}
                        }
                        continue;
                    }

                    const channelId = getChannelIdByKindIndex(def.kind, idx);
                    if (!channelId) continue;

                    let yMin = def.yMin;
                    let yMax = def.yMax;
                    let yTickCb = def.yTickCb;
                    let yTickStep = def.yTickStep;

                    if (def.kind === 'valve') {
                        if (mode === 'day') {
                            yMin = 0;
                            yMax = 1;
                            yTickCb = (v) => (Number(v) >= 0.5 ? 'ON' : 'OFF');
                            yTickStep = 1;
                        } else {
                            yMin = 0;
                            yMax = undefined;
                            yTickCb = undefined;
                            yTickStep = undefined;
                        }
                    }

                    ensureMiniChart(canvasId, { stepped: def.stepped, yMin, yMax, yTickCb, yTickStep, mode });
                    await loadMiniChartHistory(canvasId, channelId, { kind: def.kind === 'valve' ? 'valve' : 'value', mode });
                }

                try { updateZoneSummary(zoneNum); } catch {}
                try { updateZoneCardMeta(zoneNum); } catch {}
            }
        }

        function formatLastPointText(mode, dateObj, fallbackLabel) {
            if (dateObj instanceof Date && !Number.isNaN(dateObj.getTime())) {
                const p = getMadridPartsFull(dateObj);
                if (mode === 'year') return `Mes ${p.mo}`;
                if (mode === 'month') return `Día ${p.d}`;
                return `Día ${p.d} ${p.h}:${p.mi}:${p.s}`;
            }
            const lbl = (fallbackLabel == null) ? '' : String(fallbackLabel);
            if (!lbl) return '--';
            if (mode === 'year') return `Mes ${lbl}`;
            if (mode === 'month') return `Día ${lbl}`;
            return lbl.startsWith('Día ') ? lbl : `Día ${lbl}`;
        }

        function updateZoneSummary(zoneNum) {
            const avgEl = document.getElementById(`zoneAvgHumidity${zoneNum}`);
            const lastEl = document.getElementById(`zoneLastPoint${zoneNum}`);
            const onEl = document.getElementById(`zoneTotalValveOn${zoneNum}`);
            if (!avgEl && !lastEl && !onEl) return;

            const humEntry = zoneMiniCharts.get(`zoneHumChart${zoneNum}`) || null;
            const valveEntry = zoneMiniCharts.get(`zoneValveChart${zoneNum}`) || null;

            const mode = getZoneViewMode(zoneNum);

            // Humedad media
            if (avgEl) {
                const sum = humEntry?.meta && Number.isFinite(Number(humEntry.meta.sum)) ? Number(humEntry.meta.sum) : null;
                const cnt = humEntry?.meta && Number.isFinite(Number(humEntry.meta.count)) ? Number(humEntry.meta.count) : null;
                if (sum != null && cnt != null && cnt > 0) avgEl.textContent = `${(sum / cnt).toFixed(1)}%`;
                else avgEl.textContent = '--';
            }

            // Tiempo válvula ON (basado en deltas entre puntos)
            if (onEl) {
                const ms = valveEntry?.meta && Number.isFinite(Number(valveEntry.meta.valveOnMs)) ? Number(valveEntry.meta.valveOnMs) : null;
                onEl.textContent = ms ? formatDuration(ms) : '--';
            }

            // Último punto: el más reciente entre humedad y válvula
            if (lastEl) {
                const humLast = humEntry?.meta && Number.isFinite(Number(humEntry.meta.lastDateMs))
                    ? Number(humEntry.meta.lastDateMs)
                    : (humEntry?.lastTsMs != null ? Number(humEntry.lastTsMs) : null);
                const valveLast = valveEntry?.meta && Number.isFinite(Number(valveEntry.meta.lastDateMs))
                    ? Number(valveEntry.meta.lastDateMs)
                    : (valveEntry?.lastTsMs != null ? Number(valveEntry.lastTsMs) : null);
                const lastMs = (humLast != null && valveLast != null)
                    ? Math.max(humLast, valveLast)
                    : (humLast != null ? humLast : (valveLast != null ? valveLast : null));

                const fallbackLabel = (() => {
                    if (humLast != null && valveLast != null) {
                        return (humLast >= valveLast) ? (humEntry?.meta?.lastLabel || '') : (valveEntry?.meta?.lastLabel || '');
                    }
                    if (humLast != null) return humEntry?.meta?.lastLabel || '';
                    if (valveLast != null) return valveEntry?.meta?.lastLabel || '';
                    return '';
                })();

                if (lastMs == null) {
                    lastEl.textContent = '--';
                } else {
                    const base = formatLastPointText(mode, new Date(lastMs), fallbackLabel);
                    const ageMin = Math.max(0, Math.round((nowAdjusted().getTime() - lastMs) / 60000));
                    const stale = Number.isFinite(ageMin) && ageMin > 10;
                    lastEl.textContent = `${base}${Number.isFinite(ageMin) ? ` (hace ${ageMin} min)` : ''}${stale ? ' · DATOS ANTIGUOS' : ''}`;
                }
            }
        }

        function rebuildChartsFromStore(storeOpt) {
            const store = storeOpt || loadStore();
            const now = nowAdjusted();
            const p = getMadridParts(now);

            let labels = [];
            let hum = [];
            let valve = [];
            let totalHumSum = 0;
            let totalHumCount = 0;
            let totalValveOnMs = 0;

            if (viewMode === 'day') {
                document.getElementById('periodLabel').textContent = 'Día';
                document.getElementById('periodValue').textContent = `${fmtDateEs.format(now)} (hoy)`;

                const axis = buildMadridDayAxisLabels(p);
                labels = axis.map(withDiaPrefixLabel);
                hum = new Array(1440).fill(null);
                valve = new Array(1440).fill(null);

                const todayKey = madridDayKeyFromParts({ y: p.y, mo: p.mo, d: p.d });
                for (const [k, v] of Object.entries(store.minutes || {})) {
                    if (!String(k || '').startsWith(todayKey + ' ')) continue;
                    const hh = Number(String(k).slice(11, 13));
                    const mm = Number(String(k).slice(14, 16));
                    if (!Number.isFinite(hh) || !Number.isFinite(mm)) continue;
                    const idx = hh * 60 + mm;
                    if (idx < 0 || idx >= 1440) continue;
                    const avg = v.humCount ? (v.humSum / v.humCount) : null;
                    const hv = avg === null ? null : Number(avg.toFixed(2));
                    hum[idx] = hv;
                    const duty = Math.max(0, Math.min(1, (v.valveOnMs || 0) / 60000));
                    valve[idx] = Number(duty.toFixed(2));
                    totalHumSum += v.humSum || 0;
                    totalHumCount += v.humCount || 0;
                    totalValveOnMs += v.valveOnMs || 0;
                }

                valveChart.options.scales.y.min = 0;
                valveChart.options.scales.y.max = 1;
                valveChart.options.scales.y.ticks.callback = (v) => (v >= 0.5 ? 'ON' : 'OFF');
                valveChart.options.scales.y.ticks.stepSize = 1;
                valveChart.data.datasets[0].label = 'Válvula (duty 0..1)';

            } else if (viewMode === 'month') {
                const monthKey = `${p.y}-${p.mo}`;
                document.getElementById('periodLabel').textContent = 'Mes';
                document.getElementById('periodValue').textContent = `${p.mo}/${p.y}`;

                const byDay = {};
                for (const [k, v] of Object.entries(store.days || {})) {
                    if (!String(k || '').startsWith(monthKey + '-')) continue;
                    byDay[k] = v;
                }
                const daysInMonth = daysInMadridMonthFromParts({ y: p.y, mo: p.mo });
                for (let day = 1; day <= daysInMonth; day++) {
                    const k = `${p.y}-${p.mo}-${pad2(day)}`;
                    labels.push(pad2(day));
                    const v = byDay[k] || null;
                    const avg = v && v.humCount ? (v.humSum / v.humCount) : null;
                    hum.push(avg === null ? null : Number(avg.toFixed(2)));
                    valve.push(v ? Number(((v.valveOnMs || 0) / 3600000).toFixed(2)) : null); // horas
                    if (v) {
                        totalHumSum += v.humSum || 0;
                        totalHumCount += v.humCount || 0;
                        totalValveOnMs += v.valveOnMs || 0;
                    }
                }

                valveChart.options.scales.y.min = 0;
                valveChart.options.scales.y.max = undefined;
                valveChart.options.scales.y.ticks.callback = undefined;
                valveChart.options.scales.y.ticks.stepSize = undefined;
                valveChart.data.datasets[0].label = 'Válvula (horas ON/día)';

            } else {
                const yearKey = `${p.y}-`;
                document.getElementById('periodLabel').textContent = 'Año';
                document.getElementById('periodValue').textContent = `${p.y}`;

                const entries = Object.entries(store.months)
                    .filter(([k]) => k.startsWith(yearKey))
                    .sort((a, b) => a[0].localeCompare(b[0]));

                for (const [k, v] of entries) {
                    const avg = v.humCount ? (v.humSum / v.humCount) : null;
                    labels.push(k.slice(5, 7));
                    hum.push(avg === null ? null : Number(avg.toFixed(2)));
                    valve.push(Number(((v.valveOnMs || 0) / 3600000).toFixed(1))); // horas ON/mes
                    totalHumSum += v.humSum || 0;
                    totalHumCount += v.humCount || 0;
                    totalValveOnMs += v.valveOnMs || 0;
                }

                valveChart.options.scales.y.min = 0;
                valveChart.options.scales.y.max = undefined;
                valveChart.options.scales.y.ticks.callback = undefined;
                valveChart.options.scales.y.ticks.stepSize = undefined;
                valveChart.data.datasets[0].label = 'Válvula (horas ON/mes)';
            }

            const avgHum = totalHumCount ? (totalHumSum / totalHumCount) : null;
            setMetaValue('avgHumidity', avgHum === null ? '--' : `${avgHum.toFixed(1)}%`, { muted: avgHum === null });
            setMetaValue('valveOnTime', totalValveOnMs ? formatDuration(totalValveOnMs) : '--', { muted: !totalValveOnMs });

            const lastPointEl = document.getElementById('lastPoint');
            if (lastPointEl) {
                const lastDate = store.last && typeof store.last.t === 'number' ? new Date(store.last.t) : null;
                const fallback = labels.length ? String(labels[labels.length - 1]) : '';
                const txt = formatLastPointText(viewMode, lastDate, fallback);
                setMetaValue('lastPoint', txt, { muted: txt === '--' });
            }

            setSeries(humLabels, humSeries, labels, hum);
            setSeries(valveLabels, valveSeries, labels, valve);
            humChart.update('none');
            valveChart.update('none');
            try {
                applyTimelineScrollForCanvas(document.getElementById('humChart'), viewMode);
                applyTimelineScrollForCanvas(document.getElementById('valveChart'), viewMode);
                scrollCanvasToNowIfFollowing(document.getElementById('humChart'), viewMode);
                scrollCanvasToNowIfFollowing(document.getElementById('valveChart'), viewMode);
            } catch {}

            const valveDotChart = document.getElementById('valveDotChart');
            const valveTextChart = document.getElementById('valveTextChart');
            if (store.last && store.last.on) {
                valveDotChart.className = 'valve-dot on';
                valveTextChart.textContent = 'ENCENDIDA';
            } else if (store.last) {
                valveDotChart.className = 'valve-dot off';
                valveTextChart.textContent = 'APAGADA';
            } else {
                valveDotChart.className = 'valve-dot';
                valveTextChart.textContent = 'SIN DATOS';
            }
        }

        function rangeForMode(mode) {
            const now = nowAdjusted();
            const pNow = getMadridParts(now);
            // DÍA (hora Madrid): hoy 00:00 → ahora
            if (mode === 'day') {
                const from = madridZonedTimeToUtcDate({ y: pNow.y, mo: pNow.mo, d: pNow.d, h: 0, mi: 0, s: 0 });
                return { from, to: now, step: '1m', bucketMs: 60000 };
            }
            // MES (hora Madrid): día 1 00:00 → ahora
            if (mode === 'month') {
                const from = madridZonedTimeToUtcDate({ y: pNow.y, mo: pNow.mo, d: 1, h: 0, mi: 0, s: 0 });
                return { from, to: now, step: '1h', bucketMs: 3600000 };
            }
            return { from: new Date(now.getFullYear(), 0, 1), to: now, step: '1h', bucketMs: 3600000 }; // year
        }

        function dayKeyForTs(ts) {
            const p = getMadridParts(new Date(ts));
            return `${p.y}-${p.mo}-${p.d}`;
        }
        function monthKeyForTs(ts) {
            const p = getMadridParts(new Date(ts));
            return `${p.y}-${p.mo}`;
        }

        function applyCompareXAxisTicks(chart, mode) {
            if (!chart || !chart.options || !chart.options.scales || !chart.options.scales.x) return;
            const t = chart.options.scales.x.ticks || (chart.options.scales.x.ticks = {});
            t.color = '#fff';
            if (mode === 'day') {
                t.autoSkip = true;
                t.callback = tickEvery30Minutes;
                t.maxTicksLimit = 49;
            } else if (mode === 'month') {
                // En MES queremos ver 01..31 (aunque se solapen un poco)
                t.autoSkip = false;
                t.callback = undefined;
                t.maxTicksLimit = undefined;
            } else {
                t.autoSkip = true;
                t.callback = undefined;
                t.maxTicksLimit = 10;
            }
            t.maxRotation = 0;
            t.minRotation = 0;
            t.backdropColor = 'rgba(0,0,0,0)';
            t.showLabelBackdrop = false;
        }

        function applyCompareYScale(chart, kind) {
            if (!chart || !chart.options || !chart.options.scales || !chart.options.scales.y) return;
            const k = String(kind || '').toLowerCase();
            if (k === 'soil_sensor' || k === 'humidity_air') {
                chart.options.scales.y.min = 0;
                chart.options.scales.y.max = 100;
                chart.options.scales.y.ticks.stepSize = 5;
                chart.options.scales.y.ticks.callback = (v) => `${v}%`;
            } else if (k === 'temperature_air' || k === 'temperature_soil') {
                chart.options.scales.y.min = 0;
                chart.options.scales.y.max = 60;
                chart.options.scales.y.ticks.stepSize = 10;
                chart.options.scales.y.ticks.callback = undefined;
            } else if (k === 'valve') {
                chart.options.scales.y.min = 0;
                chart.options.scales.y.max = 1;
                chart.options.scales.y.ticks.stepSize = 1;
                chart.options.scales.y.ticks.callback = (v) => (v >= 0.5 ? 'ON' : 'OFF');
            } else {
                chart.options.scales.y.min = 0;
                chart.options.scales.y.max = undefined;
                chart.options.scales.y.ticks.stepSize = undefined;
                chart.options.scales.y.ticks.callback = undefined;
            }
        }

        async function rebuildCompareSlot(slot) {
            const box = document.getElementById(`cmpBox${slot}`);
            if (!box || box.style.display === 'none') return;

            const channelId = cmpChannelIdBySlot[slot] || null;
            const chart = cmpChartsBySlot[slot] || null;
            const labelsArr = cmpLabelsBySlot[slot] || null;
            const seriesArr = cmpSeriesBySlot[slot] || null;
            const titleEl = document.getElementById(`cmpTitle${slot}`);

            if (!chart || !labelsArr || !seriesArr) return;
            if (!channelId) {
                if (titleEl) titleEl.textContent = `Comparación ${slot}`;
                setSeries(labelsArr, seriesArr, [], []);
                chart.update('none');
                return;
            }

            const ch = (channels || []).find(c => c && String(c.id) === String(channelId));
            if (!ch) return;
            const kind = String(ch.kind || '').toLowerCase();

            if (titleEl) titleEl.textContent = `${prettyKind(kind)} · ${ch.name} (${ch.channel_index})`;
            chart.data.datasets[0].label = `${prettyKind(kind)} · ${ch.name}`;
            chart.data.datasets[0].stepped = (kind === 'valve');
            chart.data.datasets[0].tension = (kind === 'valve') ? 0 : 0.25;
            applyCompareYScale(chart, kind);
            applyCompareXAxisTicks(chart, viewMode);

            let step;
            let limit;
            if (viewMode === 'day') { step = '1m'; limit = 2000; }
            else if (viewMode === 'month') { step = '1h'; limit = 2000; }
            else { step = '1h'; limit = 4000; }

            const range = rangeForMode(viewMode);
            const rangeQs = (range && range.from && range.to)
                ? `&from=${encodeURIComponent(range.from.toISOString())}&to=${encodeURIComponent(range.to.toISOString())}`
                : '';

            const url = `/api/channel/history/${encodeURIComponent(deviceCode)}/${encodeURIComponent(channelId)}?step=${encodeURIComponent(step)}&limit=${limit}${rangeQs}`;
            const r = await fetch(url);
            if (!r.ok) return;
            const payload = await r.json().catch(() => null);
            const rows = Array.isArray(payload?.rows) ? payload.rows : [];

            const labels = [];
            const series = [];

            if (viewMode === 'day') {
                const pNow = getMadridParts(nowAdjusted());
                const axis = buildMadridDayAxisLabels(pNow);
                const sArr = new Array(1440).fill(null);

                for (const row of rows) {
                    const idx = madridMinuteIndexForTs(row?.ts, pNow);
                    if (idx == null) continue;
                    if (kind === 'valve') {
                        const onNow = Number(row?.state || 0) >= 1;
                        sArr[idx] = onNow ? 1 : 0;
                    } else {
                        const v = row?.value == null ? null : Number(row.value);
                        sArr[idx] = (v == null || Number.isNaN(v)) ? null : Number(v.toFixed(2));
                    }
                }

                for (const x of axis) labels.push(withDiaPrefixLabel(x));
                for (const y of sArr) series.push(y);
            } else if (viewMode === 'month') {
                const byDay = {};
                for (const row of rows) {
                    const key = row?.ts_madrid_day_key || dayKeyForTs(row?.ts);
                    const b = byDay[key] || (byDay[key] = (kind === 'valve' ? { on: 0, cnt: 0 } : { sum: 0, cnt: 0 }));
                    if (kind === 'valve') {
                        const s = Number(row?.state || 0) >= 1 ? 1 : 0;
                        b.on += s;
                        b.cnt += 1;
                    } else {
                        const v = row?.value == null ? null : Number(row.value);
                        if (v != null && !Number.isNaN(v)) { b.sum += v; b.cnt += 1; }
                    }
                }
                const pNow = getMadridParts(nowAdjusted());
                const daysInMonth = daysInMadridMonthFromParts({ y: pNow.y, mo: pNow.mo });
                for (let day = 1; day <= daysInMonth; day++) {
                    const key = `${pNow.y}-${pNow.mo}-${pad2(day)}`;
                    labels.push(pad2(day));
                    const b = byDay[key] || null;
                    if (kind === 'valve') {
                        const onHours = b && b.cnt ? (b.on / b.cnt) * 24 : null;
                        series.push(onHours == null ? null : Number(onHours.toFixed(2)));
                    } else {
                        const avg = b && b.cnt ? (b.sum / b.cnt) : null;
                        series.push(avg == null ? null : Number(avg.toFixed(2)));
                    }
                }
            } else {
                const byMonth = {};
                for (const row of rows) {
                    const key = row?.ts_madrid_month_key || monthKeyForTs(row?.ts);
                    const b = byMonth[key] || (byMonth[key] = (kind === 'valve' ? { on: 0, cnt: 0 } : { sum: 0, cnt: 0 }));
                    if (kind === 'valve') {
                        const s = Number(row?.state || 0) >= 1 ? 1 : 0;
                        b.on += s;
                        b.cnt += 1;
                    } else {
                        const v = row?.value == null ? null : Number(row.value);
                        if (v != null && !Number.isNaN(v)) { b.sum += v; b.cnt += 1; }
                    }
                }
                const keys = Object.keys(byMonth).sort();
                for (const key of keys) {
                    labels.push(key.slice(5, 7));
                    const b = byMonth[key];
                    if (kind === 'valve') {
                        const onHours = b && b.cnt ? (b.on / b.cnt) * (30 * 24) : null;
                        series.push(onHours == null ? null : Number(onHours.toFixed(1)));
                    } else {
                        const avg = b && b.cnt ? (b.sum / b.cnt) : null;
                        series.push(avg == null ? null : Number(avg.toFixed(2)));
                    }
                }
            }

            setSeries(labelsArr, seriesArr, labels, series);
            chart.update('none');
            try {
                applyTimelineScrollForCanvas(chart?.canvas, viewMode);
                scrollCanvasToNowIfFollowing(chart?.canvas, viewMode);
            } catch {}
        }

        function rebuildCompareExtraCharts() {
            return Promise.all(CMP_SLOTS.map(s => rebuildCompareSlot(s).catch(() => {})));
        }

        async function rebuildChartsFromServer() {
            // Para rendimiento: limitar puntos en DÍA (raw) y usar canales
            if (!humChannelId && !valveChannelId) throw new Error('no channels');

            const now = nowAdjusted();
            const range = rangeForMode(viewMode);
            let step;
            let limit;
            if (viewMode === 'day') { step = '1m'; limit = 2000; }
            else if (viewMode === 'month') { step = '1h'; limit = 2000; }
            else { step = '1h'; limit = 4000; }

            const rangeQs = (range && range.from && range.to)
                ? `&from=${encodeURIComponent(range.from.toISOString())}&to=${encodeURIComponent(range.to.toISOString())}`
                : '';

            const baseHum = humChannelId ? `/api/channel/history/${encodeURIComponent(deviceCode)}/${encodeURIComponent(humChannelId)}?step=${encodeURIComponent(step)}&limit=${limit}${rangeQs}` : null;
            const baseValve = valveChannelId ? `/api/channel/history/${encodeURIComponent(deviceCode)}/${encodeURIComponent(valveChannelId)}?step=${encodeURIComponent(step)}&limit=${limit}${rangeQs}` : null;

            async function rebuildChartsFromSensorHistoryFallback() {
                // Fallback robusto: usar sensor_data (siempre existe aunque el dispositivo esté offline)
                const url = `/api/sensor/history/${encodeURIComponent(deviceCode)}?step=${encodeURIComponent(step)}&limit=${limit}${rangeQs}`;
                const r = await fetch(url);
                if (!r.ok) throw new Error('sensor history failed');
                const payload = await r.json();
                const rows = Array.isArray(payload.rows) ? payload.rows : [];

                // Convertir a “shape” parecido a channel history
                const humRows = rows
                    .filter(x => x && x.humidity != null)
                    .map(x => ({ ts: x.ts, ts_madrid: x.ts_madrid, ts_madrid_label: x.ts_madrid_label, ts_madrid_day_key: x.ts_madrid_day_key, ts_madrid_month_key: x.ts_madrid_month_key, value: x.humidity }));

                const valveRows = rows
                    .map(x => {
                        // raw: valve_state (string), bucket: valve_on (0/1)
                        const s = (x && x.valve_on != null) ? Number(x.valve_on) : null;
                        if (Number.isFinite(s)) return { ts: x.ts, ts_madrid: x.ts_madrid, ts_madrid_label: x.ts_madrid_label, ts_madrid_day_key: x.ts_madrid_day_key, ts_madrid_month_key: x.ts_madrid_month_key, state: s >= 1 ? 1 : 0 };
                        const vs = String(x?.valve_state || '').toUpperCase();
                        if (!vs) return { ts: x.ts, ts_madrid: x.ts_madrid, ts_madrid_label: x.ts_madrid_label, ts_madrid_day_key: x.ts_madrid_day_key, ts_madrid_month_key: x.ts_madrid_month_key, state: null };
                        const on = (vs === 'ON' || vs === '1' || vs === 'TRUE');
                        return { ts: x.ts, ts_madrid: x.ts_madrid, ts_madrid_label: x.ts_madrid_label, ts_madrid_day_key: x.ts_madrid_day_key, ts_madrid_month_key: x.ts_madrid_month_key, state: on ? 1 : 0 };
                    });

                // Reutilizar la misma lógica de pintado (como si viniera de channels)
                const fakeHumPayload = { rows: humRows, range: payload.range };
                const fakeValvePayload = { rows: valveRows, range: payload.range };

                // Copia mínima de las variables que usa el bloque de render
                const humRows2 = humRows;
                const valveRows2 = valveRows;

                let labels = [];
                let hum = [];
                let valve = [];
                let totalHumSum = 0;
                let totalHumCount = 0;
                let totalValveOnMs = 0;

                if (viewMode === 'day') {
                    document.getElementById('periodLabel').textContent = 'Día';
                    const rangeTo = parseTsToDate(fakeHumPayload?.range?.to || fakeValvePayload?.range?.to) || now;
                    document.getElementById('periodValue').textContent = `${fmtDateEs.format(rangeTo)} (hoy, histórico)`;

                    const pNow = getMadridParts(nowAdjusted());
                    const axis = buildMadridDayAxisLabels(pNow);
                    labels = axis.map(withDiaPrefixLabel);
                    hum = new Array(1440).fill(null);
                    valve = new Array(1440).fill(null);

                    for (const r of humRows2) {
                        const idx = madridMinuteIndexForTs(r.ts, pNow);
                        if (idx == null) continue;
                        const v = r.value == null ? null : Number(r.value);
                        const vv = (v == null || Number.isNaN(v)) ? null : Number(v.toFixed(2));
                        hum[idx] = vv;
                        if (vv != null) { totalHumSum += v; totalHumCount += 1; }
                    }

                    let prevT = null;
                    let prevOn = false;
                    for (const r of valveRows2) {
                        const d = parseTsToDate(r.ts);
                        const onNow = Number(r.state || 0) >= 1;
                        const idx = madridMinuteIndexForTs(r.ts, pNow);
                        if (idx != null) valve[idx] = onNow ? 1 : 0;
                        const t = d ? d.getTime() : null;
                        if (t != null && prevT != null) {
                            const dt = Math.max(0, t - prevT);
                            if (prevOn) totalValveOnMs += dt;
                        }
                        prevT = t;
                        prevOn = onNow;
                    }

                    valveChart.options.scales.y.min = 0;
                    valveChart.options.scales.y.max = 1;
                    valveChart.options.scales.y.ticks.callback = (v) => (v >= 0.5 ? 'ON' : 'OFF');
                    valveChart.options.scales.y.ticks.stepSize = 1;
                    valveChart.data.datasets[0].label = 'Válvula (0/1)';
                } else if (viewMode === 'month') {
                    const pNow = getMadridParts(nowAdjusted());
                    document.getElementById('periodLabel').textContent = 'Mes';
                    document.getElementById('periodValue').textContent = `${pNow.mo}/${pNow.y}`;

                    const byDayHum = {};
                    for (const r of humRows2) {
                        const k = r.ts_madrid_day_key || dayKeyForTs(r.ts);
                        const b = byDayHum[k] || (byDayHum[k] = { sum: 0, cnt: 0 });
                        const v = r.value == null ? null : Number(r.value);
                        if (v != null && !Number.isNaN(v)) { b.sum += v; b.cnt += 1; }
                    }
                    const byDayValve = {};
                    for (const r of valveRows2) {
                        const k = r.ts_madrid_day_key || dayKeyForTs(r.ts);
                        const b = byDayValve[k] || (byDayValve[k] = { on: 0, cnt: 0 });
                        const s = Number(r.state || 0) >= 1 ? 1 : 0;
                        b.on += s;
                        b.cnt += 1;
                    }
                    const daysInMonth = daysInMadridMonthFromParts({ y: pNow.y, mo: pNow.mo });
                    for (let day = 1; day <= daysInMonth; day++) {
                        const k = `${pNow.y}-${pNow.mo}-${pad2(day)}`;
                        labels.push(pad2(day));
                        const hB = byDayHum[k] || null;
                        const vB = byDayValve[k] || null;
                        const avg = hB && hB.cnt ? (hB.sum / hB.cnt) : null;
                        hum.push(avg == null ? null : Number(avg.toFixed(2)));
                        const onHours = vB && vB.cnt ? (vB.on / vB.cnt) * 24 : null;
                        valve.push(onHours == null ? null : Number(onHours.toFixed(2)));
                        if (hB) { totalHumSum += hB.sum; totalHumCount += hB.cnt; }
                        if (vB) { totalValveOnMs += (vB.cnt ? (vB.on / vB.cnt) * 24 * 3600000 : 0); }
                    }

                    valveChart.options.scales.y.min = 0;
                    valveChart.options.scales.y.max = undefined;
                    valveChart.options.scales.y.ticks.callback = undefined;
                    valveChart.options.scales.y.ticks.stepSize = undefined;
                    valveChart.data.datasets[0].label = 'Válvula (horas ON/día)';
                } else {
                    const pNow = getMadridParts(nowAdjusted());
                    document.getElementById('periodLabel').textContent = 'Año';
                    document.getElementById('periodValue').textContent = `${pNow.y}`;

                    const byMonthHum = {};
                    for (const r of humRows2) {
                        const k = r.ts_madrid_month_key || monthKeyForTs(r.ts);
                        const b = byMonthHum[k] || (byMonthHum[k] = { sum: 0, cnt: 0 });
                        const v = r.value == null ? null : Number(r.value);
                        if (v != null && !Number.isNaN(v)) { b.sum += v; b.cnt += 1; }
                    }
                    const byMonthValve = {};
                    for (const r of valveRows2) {
                        const k = r.ts_madrid_month_key || monthKeyForTs(r.ts);
                        const b = byMonthValve[k] || (byMonthValve[k] = { on: 0, cnt: 0 });
                        const s = Number(r.state || 0) >= 1 ? 1 : 0;
                        b.on += s;
                        b.cnt += 1;
                    }
                    const keys = Array.from(new Set([...Object.keys(byMonthHum), ...Object.keys(byMonthValve)])).sort();
                    for (const k of keys) {
                        labels.push(k.slice(5, 7));
                        const hB = byMonthHum[k];
                        const vB = byMonthValve[k];
                        const avg = hB && hB.cnt ? (hB.sum / hB.cnt) : null;
                        hum.push(avg == null ? null : Number(avg.toFixed(2)));
                        const onHours = vB && vB.cnt ? (vB.on / vB.cnt) * (30 * 24) : 0;
                        valve.push(Number(onHours.toFixed(1)));
                        if (hB) { totalHumSum += hB.sum; totalHumCount += hB.cnt; }
                        if (vB) { totalValveOnMs += (vB.cnt ? (vB.on / vB.cnt) * (30 * 24) * 3600000 : 0); }
                    }

                    valveChart.options.scales.y.min = 0;
                    valveChart.options.scales.y.max = undefined;
                    valveChart.options.scales.y.ticks.callback = undefined;
                    valveChart.options.scales.y.ticks.stepSize = undefined;
                    valveChart.data.datasets[0].label = 'Válvula (horas ON/mes)';
                }

                const avgHum = totalHumCount ? (totalHumSum / totalHumCount) : null;
                setMetaValue('avgHumidity', avgHum === null ? '--' : `${avgHum.toFixed(1)}%`, { muted: avgHum === null });
                setMetaValue('valveOnTime', totalValveOnMs ? formatDuration(totalValveOnMs) : '--', { muted: !totalValveOnMs });

                const lastPointEl = document.getElementById('lastPoint');
                if (lastPointEl) {
                    const lastLabel = labels.length ? String(labels[labels.length - 1]) : '';
                    let lastDate = null;
                    if (viewMode === 'day') {
                        const lastRow = humRows2.length ? humRows2[humRows2.length - 1] : (valveRows2.length ? valveRows2[valveRows2.length - 1] : null);
                        const d = lastRow ? parseTsToDate(lastRow.ts) : null;
                        lastDate = d || null;
                    }
                    const txt = formatLastPointText(viewMode, lastDate, lastLabel);
                    setMetaValue('lastPoint', txt, { muted: txt === '--' });
                }

                setSeries(humLabels, humSeries, labels, hum);
                setSeries(valveLabels, valveSeries, labels, valve);
                try {
                    if (viewMode === 'day') {
                        humChart.options.scales.x.ticks.autoSkip = true;
                        humChart.options.scales.x.ticks.callback = tickEvery30Minutes;
                        humChart.options.scales.x.ticks.maxTicksLimit = 16;
                    } else if (viewMode === 'month') {
                        humChart.options.scales.x.ticks.autoSkip = false;
                        humChart.options.scales.x.ticks.callback = undefined;
                        humChart.options.scales.x.ticks.maxTicksLimit = undefined;
                    } else {
                        humChart.options.scales.x.ticks.autoSkip = true;
                        humChart.options.scales.x.ticks.callback = undefined;
                        humChart.options.scales.x.ticks.maxTicksLimit = 12;
                    }
                    humChart.options.scales.x.ticks.backdropColor = 'rgba(0,0,0,0)';
                    humChart.options.scales.x.ticks.showLabelBackdrop = false;
                    humChart.options.scales.x.ticks.maxRotation = 0;
                    humChart.options.scales.x.ticks.minRotation = 0;

                    if (viewMode === 'day') {
                        valveChart.options.scales.x.ticks.autoSkip = true;
                        valveChart.options.scales.x.ticks.callback = tickEvery30Minutes;
                        valveChart.options.scales.x.ticks.maxTicksLimit = 16;
                    } else if (viewMode === 'month') {
                        valveChart.options.scales.x.ticks.autoSkip = false;
                        valveChart.options.scales.x.ticks.callback = undefined;
                        valveChart.options.scales.x.ticks.maxTicksLimit = undefined;
                    } else {
                        valveChart.options.scales.x.ticks.autoSkip = true;
                        valveChart.options.scales.x.ticks.callback = undefined;
                        valveChart.options.scales.x.ticks.maxTicksLimit = 12;
                    }
                    valveChart.options.scales.x.ticks.backdropColor = 'rgba(0,0,0,0)';
                    valveChart.options.scales.x.ticks.showLabelBackdrop = false;
                    valveChart.options.scales.x.ticks.maxRotation = 0;
                    valveChart.options.scales.x.ticks.minRotation = 0;
                } catch {}
                humChart.update('none');
                valveChart.update('none');
                try {
                    applyTimelineScrollForCanvas(document.getElementById('humChart'), viewMode);
                    applyTimelineScrollForCanvas(document.getElementById('valveChart'), viewMode);
                    scrollCanvasToNowIfFollowing(document.getElementById('humChart'), viewMode);
                    scrollCanvasToNowIfFollowing(document.getElementById('valveChart'), viewMode);
                } catch {}
            }

            const [humRes, valveRes] = await Promise.all([
                baseHum ? fetch(baseHum) : Promise.resolve(null),
                baseValve ? fetch(baseValve) : Promise.resolve(null)
            ]);

            if (baseHum && (!humRes || !humRes.ok)) return rebuildChartsFromSensorHistoryFallback();
            if (baseValve && (!valveRes || !valveRes.ok)) return rebuildChartsFromSensorHistoryFallback();

            const humPayload = humRes ? await humRes.json() : { rows: [] };
            const valvePayload = valveRes ? await valveRes.json() : { rows: [] };

            const humRows = Array.isArray(humPayload.rows) ? humPayload.rows : [];
            const valveRows = Array.isArray(valvePayload.rows) ? valvePayload.rows : [];

            // Si el backend no está rellenando channel_samples (o están desfasados),
            // la gráfica puede quedarse “clavada” en un timestamp antiguo.
            // En ese caso, usamos el store local (alimentado por /api/sensor/latest).
            {
                const lastRow = humRows.length ? humRows[humRows.length - 1] : (valveRows.length ? valveRows[valveRows.length - 1] : null);
                const lastTs = lastRow ? parseTsToDate(lastRow.ts) : null;
                const ageMs = lastTs ? (now.getTime() - lastTs.getTime()) : Infinity;
                // Si el último punto es muy viejo o no existe, usar histórico de sensor_data.
                if (!lastTs || !Number.isFinite(ageMs) || ageMs > 10 * 60000) {
                    return rebuildChartsFromSensorHistoryFallback();
                }
            }

            let labels = [];
            let hum = [];
            let valve = [];
            let totalHumSum = 0;
            let totalHumCount = 0;
            let totalValveOnMs = 0;

            if (viewMode === 'day') {
                document.getElementById('periodLabel').textContent = 'Día';
                const rangeTo = parseTsToDate(humPayload?.range?.to || valvePayload?.range?.to) || now;
                document.getElementById('periodValue').textContent = `${fmtDateEs.format(rangeTo)} (hoy, tiempo real)`;

                const pNow = getMadridParts(nowAdjusted());
                const axis = buildMadridDayAxisLabels(pNow);
                labels = axis.map(withDiaPrefixLabel);
                hum = new Array(1440).fill(null);
                valve = new Array(1440).fill(null);

                for (const r of humRows) {
                    const idx = madridMinuteIndexForTs(r.ts, pNow);
                    if (idx == null) continue;
                    const v = r.value == null ? null : Number(r.value);
                    const vv = (v == null || Number.isNaN(v)) ? null : Number(v.toFixed(2));
                    hum[idx] = vv;
                    if (vv != null) { totalHumSum += v; totalHumCount += 1; }
                }

                // Serie válvula + tiempo ON
                let prevT = null;
                let prevOn = false;
                for (const r of valveRows) {
                    const d = parseTsToDate(r.ts);
                    const onNow = Number(r.state || 0) >= 1;
                    const idx = madridMinuteIndexForTs(r.ts, pNow);
                    if (idx != null) valve[idx] = onNow ? 1 : 0;
                    const t = d ? d.getTime() : null;
                    if (t != null && prevT != null) {
                        const dt = Math.max(0, t - prevT);
                        if (prevOn) totalValveOnMs += dt;
                    }
                    prevT = t;
                    prevOn = onNow;
                }

                // Estado actual en tarjeta de la gráfica según el último valor del canal
                const valveDotChart = document.getElementById('valveDotChart');
                const valveTextChart = document.getElementById('valveTextChart');
                const lastV = valveRows.length ? valveRows[valveRows.length - 1] : null;
                if (lastV && Number(lastV.state || 0) >= 1) {
                    valveDotChart.className = 'valve-dot on';
                    valveTextChart.textContent = 'ENCENDIDA';
                } else if (lastV) {
                    valveDotChart.className = 'valve-dot off';
                    valveTextChart.textContent = 'APAGADA';
                } else {
                    valveDotChart.className = 'valve-dot';
                    valveTextChart.textContent = 'SIN DATOS';
                }

                valveChart.options.scales.y.min = 0;
                valveChart.options.scales.y.max = 1;
                valveChart.options.scales.y.ticks.callback = (v) => (v >= 0.5 ? 'ON' : 'OFF');
                valveChart.options.scales.y.ticks.stepSize = 1;
                valveChart.data.datasets[0].label = 'Válvula (0/1)';

            } else if (viewMode === 'month') {
                const pNow = getMadridParts(nowAdjusted());
                document.getElementById('periodLabel').textContent = 'Mes';
                document.getElementById('periodValue').textContent = `${pNow.mo}/${pNow.y}`;

                // En month/year, backend ya devuelve buckets por hora; agrupamos a días aquí (usando claves Madrid del backend)
                const byDayHum = {};
                for (const r of humRows) {
                    const k = r.ts_madrid_day_key || dayKeyForTs(r.ts);
                    const b = byDayHum[k] || (byDayHum[k] = { sum: 0, cnt: 0 });
                    const v = r.value == null ? null : Number(r.value);
                    if (v != null && !Number.isNaN(v)) { b.sum += v; b.cnt += 1; }
                }
                const byDayValve = {};
                for (const r of valveRows) {
                    const k = r.ts_madrid_day_key || dayKeyForTs(r.ts);
                    const b = byDayValve[k] || (byDayValve[k] = { on: 0, cnt: 0 });
                    const s = Number(r.state || 0) >= 1 ? 1 : 0;
                    b.on += s;
                    b.cnt += 1;
                }
                const daysInMonth = daysInMadridMonthFromParts({ y: pNow.y, mo: pNow.mo });
                for (let day = 1; day <= daysInMonth; day++) {
                    const key = `${pNow.y}-${pNow.mo}-${pad2(day)}`;
                    labels.push(pad2(day));
                    const hB = byDayHum[key] || null;
                    const vB = byDayValve[key] || null;
                    const avg = hB && hB.cnt ? (hB.sum / hB.cnt) : null;
                    hum.push(avg == null ? null : Number(avg.toFixed(2)));
                    // Horas ON estimadas: (porcentaje de horas con state=1) * 24
                    const onHours = vB && vB.cnt ? (vB.on / vB.cnt) * 24 : null;
                    valve.push(onHours == null ? null : Number(onHours.toFixed(2)));
                    if (hB) { totalHumSum += hB.sum; totalHumCount += hB.cnt; }
                    if (vB) { totalValveOnMs += (vB.cnt ? (vB.on / vB.cnt) * 24 * 3600000 : 0); }
                }

                valveChart.options.scales.y.min = 0;
                valveChart.options.scales.y.max = undefined;
                valveChart.options.scales.y.ticks.callback = undefined;
                valveChart.options.scales.y.ticks.stepSize = undefined;
                valveChart.data.datasets[0].label = 'Válvula (horas ON/día)';

            } else {
                const pNow = getMadridParts(nowAdjusted());
                document.getElementById('periodLabel').textContent = 'Año';
                document.getElementById('periodValue').textContent = `${pNow.y}`;

                const byMonthHum = {};
                for (const r of humRows) {
                    const k = r.ts_madrid_month_key || monthKeyForTs(r.ts);
                    const b = byMonthHum[k] || (byMonthHum[k] = { sum: 0, cnt: 0 });
                    const v = r.value == null ? null : Number(r.value);
                    if (v != null && !Number.isNaN(v)) { b.sum += v; b.cnt += 1; }
                }
                const byMonthValve = {};
                for (const r of valveRows) {
                    const k = r.ts_madrid_month_key || monthKeyForTs(r.ts);
                    const b = byMonthValve[k] || (byMonthValve[k] = { on: 0, cnt: 0 });
                    const s = Number(r.state || 0) >= 1 ? 1 : 0;
                    b.on += s;
                    b.cnt += 1;
                }
                const keys = Array.from(new Set([...Object.keys(byMonthHum), ...Object.keys(byMonthValve)])).sort();
                for (const k of keys) {
                    labels.push(k.slice(5, 7));
                    const hB = byMonthHum[k];
                    const vB = byMonthValve[k];
                    const avg = hB && hB.cnt ? (hB.sum / hB.cnt) : null;
                    hum.push(avg == null ? null : Number(avg.toFixed(2)));
                    const onHours = vB && vB.cnt ? (vB.on / vB.cnt) * (30 * 24) : 0; // aprox
                    valve.push(Number(onHours.toFixed(1)));
                    if (hB) { totalHumSum += hB.sum; totalHumCount += hB.cnt; }
                    if (vB) { totalValveOnMs += (vB.cnt ? (vB.on / vB.cnt) * (30 * 24) * 3600000 : 0); }
                }

                valveChart.options.scales.y.min = 0;
                valveChart.options.scales.y.max = undefined;
                valveChart.options.scales.y.ticks.callback = undefined;
                valveChart.options.scales.y.ticks.stepSize = undefined;
                valveChart.data.datasets[0].label = 'Válvula (horas ON/mes)';
            }

            const avgHum = totalHumCount ? (totalHumSum / totalHumCount) : null;
            setMetaValue('avgHumidity', avgHum === null ? '--' : `${avgHum.toFixed(1)}%`, { muted: avgHum === null });
            setMetaValue('valveOnTime', totalValveOnMs ? formatDuration(totalValveOnMs) : '--', { muted: !totalValveOnMs });

            const lastPointEl = document.getElementById('lastPoint');
            if (lastPointEl) {
                const lastLabel = labels.length ? String(labels[labels.length - 1]) : '';
                let lastDate = null;
                if (viewMode === 'day') {
                    const lastRow = humRows.length ? humRows[humRows.length - 1] : (valveRows.length ? valveRows[valveRows.length - 1] : null);
                    lastDate = lastRow ? (parseTsToDate(lastRow.ts) || null) : null;
                }
                const txt = formatLastPointText(viewMode, lastDate, lastLabel);
                setMetaValue('lastPoint', txt, { muted: txt === '--' });
            }

            setSeries(humLabels, humSeries, labels, hum);
            setSeries(valveLabels, valveSeries, labels, valve);
            try {
                humChart.options.scales.x.ticks.autoSkip = true;
                humChart.options.scales.x.ticks.callback = viewMode === 'day' ? tickEvery30Minutes : undefined;
                humChart.options.scales.x.ticks.maxTicksLimit = viewMode === 'day' ? 49 : 10;
                humChart.options.scales.x.ticks.backdropColor = 'rgba(0,0,0,0)';
                humChart.options.scales.x.ticks.showLabelBackdrop = false;
                humChart.options.scales.x.ticks.maxRotation = 0;
                humChart.options.scales.x.ticks.minRotation = 0;

                valveChart.options.scales.x.ticks.autoSkip = true;
                valveChart.options.scales.x.ticks.callback = viewMode === 'day' ? tickEvery30Minutes : undefined;
                valveChart.options.scales.x.ticks.maxTicksLimit = viewMode === 'day' ? 49 : 10;
                valveChart.options.scales.x.ticks.backdropColor = 'rgba(0,0,0,0)';
                valveChart.options.scales.x.ticks.showLabelBackdrop = false;
                valveChart.options.scales.x.ticks.maxRotation = 0;
                valveChart.options.scales.x.ticks.minRotation = 0;
            } catch {}
            humChart.update('none');
            valveChart.update('none');
            try {
                applyTimelineScrollForCanvas(document.getElementById('humChart'), viewMode);
                applyTimelineScrollForCanvas(document.getElementById('valveChart'), viewMode);
                scrollCanvasToNowIfFollowing(document.getElementById('humChart'), viewMode);
                scrollCanvasToNowIfFollowing(document.getElementById('valveChart'), viewMode);
            } catch {}
        }

        function rebuildCharts(storeOpt) {
            try {
                applyTimelineScrollForCanvas(document.getElementById('humChart'), viewMode);
                applyTimelineScrollForCanvas(document.getElementById('valveChart'), viewMode);
                for (const slot of CMP_SLOTS) applyTimelineScrollForCanvas(document.getElementById(`cmpChart${slot}`), viewMode);
                scrollCanvasToNowIfFollowing(document.getElementById('humChart'), viewMode);
                scrollCanvasToNowIfFollowing(document.getElementById('valveChart'), viewMode);
                for (const slot of CMP_SLOTS) scrollCanvasToNowIfFollowing(document.getElementById(`cmpChart${slot}`), viewMode);
            } catch {}
            if (storeOpt) {
                rebuildChartsFromStore(storeOpt);
                rebuildCompareExtraCharts().catch(() => {});
                return;
            }
            rebuildChartsFromServer()
                .catch(() => rebuildChartsFromStore())
                .finally(() => { rebuildCompareExtraCharts().catch(() => {}); });
        }

        function tickClock() {
            const t = fmtNowEs.format(nowAdjusted());
            document.getElementById('nowEs').textContent = t;
            const topNow = document.getElementById('topNowEs');
            if (topNow) topNow.textContent = t;
        }
        tickClock();
        setInterval(tickClock, 1000);

        function tickChartAutoScroll() {
            try {
                // Principales
                scrollCanvasToNowIfFollowing(document.getElementById('humChart'), viewMode);
                scrollCanvasToNowIfFollowing(document.getElementById('valveChart'), viewMode);

                // Comparador
                for (const slot of CMP_SLOTS) {
                    scrollCanvasToNowIfFollowing(document.getElementById(`cmpChart${slot}`), viewMode);
                }

                // Mini-gráficas (solo las que estén en modo DÍA)
                for (const [canvasId, entry] of zoneMiniCharts.entries()) {
                    if (!entry || entry.mode !== 'day') continue;
                    scrollCanvasToNowIfFollowing(document.getElementById(canvasId), 'day');
                }
            } catch {}
        }
        tickChartAutoScroll();
        setInterval(tickChartAutoScroll, 30000);

        let _scrollResizeTimer = null;
        window.addEventListener('resize', () => {
            try {
                if (_scrollResizeTimer) clearTimeout(_scrollResizeTimer);
                _scrollResizeTimer = setTimeout(() => {
                    try {
                        applyTimelineScrollForCanvas(document.getElementById('humChart'), viewMode);
                        applyTimelineScrollForCanvas(document.getElementById('valveChart'), viewMode);
                        for (const slot of CMP_SLOTS) applyTimelineScrollForCanvas(document.getElementById(`cmpChart${slot}`), viewMode);
                        for (const [canvasId, entry] of zoneMiniCharts.entries()) {
                            if (!entry) continue;
                            applyTimelineScrollForCanvas(document.getElementById(canvasId), entry.mode || 'day');
                        }
                        tickChartAutoScroll();
                    } catch {}
                }, 160);
            } catch {}
        }, { passive: true });

        async function cargarConfig() {
            try {
                const res = await fetch(`/api/config/${encodeURIComponent(deviceCode)}`, { credentials: 'include' });
                const cfg = await res.json();

                let threshold = parseFloat(cfg.humidity_low_threshold);
                if (isNaN(threshold) || threshold < 1) threshold = 25;
                if (threshold > 100) threshold = 100;

                config.threshold = threshold;
                config.colorB = cfg.humidity_low_color || 'Rojo';
                config.colorG = cfg.humidity_good_color || 'Verde';

                const thresholdEl = document.getElementById('threshold');
                const thresholdValueEl = document.getElementById('thresholdValue');
                const colorBuenaEl = document.getElementById('colorBuena');
                const colorBajaEl = document.getElementById('colorBaja');

                // Umbral global ya no se configura en UI (cada planta tiene su propio umbral).
                // Mantenemos config.threshold solo por compatibilidad/legacy.
                if (thresholdEl) thresholdEl.value = String(config.threshold);
                if (thresholdValueEl) thresholdValueEl.textContent = config.threshold + '%';
                if (colorBuenaEl) colorBuenaEl.value = config.colorB;
                if (colorBajaEl) colorBajaEl.value = config.colorG;

                // Campos avanzados
                document.getElementById('wetV').value = (cfg.wet_v == null ? String(DEFAULT_AUTO_CONFIG.wet_v) : cfg.wet_v);
                document.getElementById('dryV').value = (cfg.dry_v == null ? String(DEFAULT_AUTO_CONFIG.dry_v) : cfg.dry_v);
                document.getElementById('alertHumLowMin').value = cfg.alert_humidity_low_minutes ?? DEFAULT_AUTO_CONFIG.alert_humidity_low_minutes;
                document.getElementById('alertValveMaxMin').value = cfg.alert_valve_on_max_minutes ?? DEFAULT_AUTO_CONFIG.alert_valve_on_max_minutes;
                document.getElementById('alertDeadMin').value = cfg.alert_sensor_dead_minutes ?? DEFAULT_AUTO_CONFIG.alert_sensor_dead_minutes;
                document.getElementById('alertVmin').value = (cfg.alert_voltage_min == null ? '' : cfg.alert_voltage_min);
                document.getElementById('alertVmax').value = (cfg.alert_voltage_max == null ? '' : cfg.alert_voltage_max);
                document.getElementById('notifyWebhook').value = (cfg.notify_webhook_url == null ? '' : cfg.notify_webhook_url);
                document.getElementById('notifyTelegram').value = (cfg.notify_telegram_chat_id == null ? '' : cfg.notify_telegram_chat_id);

                // Zonas (8 plantas): umbral y asignación por canal
                zonesState = normalizeZonesFromServer(cfg?.zones, config.threshold);
                renderZonesUI();
            } catch (e) {
                console.log('Error cargando config');
            }
        }

        function applyDefaultAutoConfigToUI() {
            document.getElementById('wetV').value = String(DEFAULT_AUTO_CONFIG.wet_v);
            document.getElementById('dryV').value = String(DEFAULT_AUTO_CONFIG.dry_v);
            document.getElementById('alertHumLowMin').value = String(DEFAULT_AUTO_CONFIG.alert_humidity_low_minutes);
            document.getElementById('alertValveMaxMin').value = String(DEFAULT_AUTO_CONFIG.alert_valve_on_max_minutes);
            document.getElementById('alertDeadMin').value = String(DEFAULT_AUTO_CONFIG.alert_sensor_dead_minutes);
            document.getElementById('alertVmin').value = '';
            document.getElementById('alertVmax').value = '';
        }

        async function resetearDefaults() {
            const ok = confirm('¿Restablecer los valores por defecto de CONFIGURACIÓN AUTOMÁTICA?\n\nSe aplicarán estos valores:\n- WET_V: 1.10\n- DRY_V: 2.60\n- Alertas (min): 0\n- Voltaje mín/máx: vacío (desactivado)');
            if (!ok) return;
            applyDefaultAutoConfigToUI();

            const okSave = confirm('¿Quieres guardarlos ahora en el dispositivo?');
            if (okSave) {
                await guardar();
            }
        }

        {
            const thr = document.getElementById('threshold');
            if (thr) {
                thr.addEventListener('input', (e) => {
                    config.threshold = parseInt(e.target.value);
                    const tv = document.getElementById('thresholdValue');
                    if (tv) tv.textContent = config.threshold + '%';
                });
            }
        }

        document.getElementById('colorBuena').addEventListener('change', (e) => {
            config.colorB = e.target.value;
        });

        document.getElementById('colorBaja').addEventListener('change', (e) => {
            config.colorG = e.target.value;
        });

        async function guardar() {
            const btn = document.getElementById('btnSaveConfig');
            return withBusy(btn, 'Guardando...', async () => {
            try {
                const headersBase = { 'Content-Type': 'application/json' };
                setStatusText(' Guardando configuración...');

                const wetV = document.getElementById('wetV').value;
                const dryV = document.getElementById('dryV').value;
                const alertHumLowMin = document.getElementById('alertHumLowMin').value;
                const alertValveMaxMin = document.getElementById('alertValveMaxMin').value;
                const alertDeadMin = document.getElementById('alertDeadMin').value;
                const alertVmin = document.getElementById('alertVmin').value;
                const alertVmax = document.getElementById('alertVmax').value;
                const notifyWebhook = document.getElementById('notifyWebhook').value;
                const notifyTelegram = document.getElementById('notifyTelegram').value;

                const body = {
                    // Compat: mantener el umbral global sincronizado con PLANTA 1
                    humidity_low_threshold: (zonesState && zonesState[0] && zonesState[0].humidity_low_threshold != null)
                        ? Number(zonesState[0].humidity_low_threshold)
                        : config.threshold,
                    humidity_low_color: config.colorB,
                    humidity_good_color: config.colorG,
                    wet_v: wetV === '' ? undefined : Number(wetV),
                    dry_v: dryV === '' ? undefined : Number(dryV),
                    alert_humidity_low_minutes: Number(alertHumLowMin || 0),
                    alert_valve_on_max_minutes: Number(alertValveMaxMin || 0),
                    alert_sensor_dead_minutes: Number(alertDeadMin || 0),
                    alert_voltage_min: alertVmin === '' ? null : Number(alertVmin),
                    alert_voltage_max: alertVmax === '' ? null : Number(alertVmax),
                    notify_webhook_url: notifyWebhook === '' ? null : String(notifyWebhook),
                    notify_telegram_chat_id: notifyTelegram === '' ? null : String(notifyTelegram),
                    zones: (zonesState || []).slice(0, 8).map((z, i) => ({
                        zone: i + 1,
                        soil_channel_index: z?.soil_channel_index == null ? null : Number(z.soil_channel_index),
                        valve_channel_index: z?.valve_channel_index == null ? null : Number(z.valve_channel_index),
                        temperature_air_channel_index: z?.temperature_air_channel_index == null ? null : Number(z.temperature_air_channel_index),
                        humidity_air_channel_index: z?.humidity_air_channel_index == null ? null : Number(z.humidity_air_channel_index),
                        temperature_soil_channel_index: z?.temperature_soil_channel_index == null ? null : Number(z.temperature_soil_channel_index),
                        ph_soil_channel_index: z?.ph_soil_channel_index == null ? null : Number(z.ph_soil_channel_index),
                        ec_soil_channel_index: z?.ec_soil_channel_index == null ? null : Number(z.ec_soil_channel_index),
                        humidity_low_threshold: z?.humidity_low_threshold == null ? null : Number(z.humidity_low_threshold)
                    }))
                };

                async function doSave(headers) {
                    return fetch(`/api/config/${encodeURIComponent(deviceCode)}`, {
                        method: 'POST',
                        headers,
                        credentials: 'include',
                        body: JSON.stringify(body)
                    });
                }

                const saved = (getSavedToken(deviceCode) || '').trim();
                const headers1 = { ...headersBase };
                if (saved) headers1['X-Device-Token'] = saved;

                let res = await doSave(headers1);

                if (res.status === 401 || res.status === 403) {
                    const msg = saved
                        ? 'Token guardado inválido o caducado. Pega el token correcto:'
                        : 'Este dispositivo requiere token para guardar. Pégalo aquí:';
                    const t = (prompt(msg) || '').trim();
                    if (t) {
                        saveToken(deviceCode, t);
                        const headers2 = { ...headersBase, 'X-Device-Token': t };
                        res = await doSave(headers2);
                    }
                }

                if (res.ok) {
                    setStatusText(' Configuración guardada');
                    alert(' Configuracion guardada!\nEl ESP32 aplicara los cambios en 10 segundos.');
                } else {
                    setStatusText(' Error al guardar');
                    alert(' Error al guardar');
                }
            } catch (e) {
                setStatusText(' Error de conexión');
                alert(' Error de conexion');
            }
            });
        }

        // Hook UI: reset defaults
        document.getElementById('btnResetDefaults')?.addEventListener('click', () => {
            resetearDefaults();
        });

        async function actualizarSensores() {
            try {
                const res = await fetch(`/api/sensor/latest/${encodeURIComponent(deviceCode)}`);
                const data = await res.json();

                // Ajuste de reloj (si el backend lo manda)
                if (data && data.server_now) {
                    const serverMs = Date.parse(data.server_now);
                    if (Number.isFinite(serverMs)) {
                        serverClockOffsetMs = serverMs - Date.now();
                    }
                }
                
                updateConnectedDeviceCards(data);

                const v = (data.voltage == null ? null : Number(data.voltage));
                document.getElementById('voltage').textContent = (v == null || Number.isNaN(v) ? '--' : v.toFixed(2));
                {
                    const el = document.getElementById('voltageMeta');
                    const vOk = !(v == null || Number.isNaN(v));
                    const variant = !vOk ? 'neutral' : (v >= 1.8 ? 'ok' : (v >= 1.0 ? 'warn' : 'bad'));
                    setChips(el, [
                        { k: 'Unidad', v: 'V', variant: 'neutral' },
                        { k: 'Estado', v: !vOk ? '--' : (variant === 'ok' ? 'ok' : (variant === 'warn' ? 'bajo' : 'crítico')), variant },
                    ]);
                }

                const rssi = (data.wifi_rssi == null ? null : Number(data.wifi_rssi));
                const rssiOk = !(rssi == null || Number.isNaN(rssi) || rssi === 0);

                const rbRaw = (data.reboot_count_display != null ? data.reboot_count_display : data.reboot_count);
                const rb = (rbRaw == null ? null : Number(rbRaw));
                lastRebootsBase = (rb == null || Number.isNaN(rb)) ? null : Math.trunc(rb);
                const localOffset = getLocalRebootsOffset(deviceCode);
                const rbShown = (lastRebootsBase == null) ? null : Math.max(0, lastRebootsBase - localOffset);
                document.getElementById('reboots').textContent = (rbShown == null ? '--' : String(Math.trunc(rbShown)));
                {
                    const el = document.getElementById('rebootsMeta');
                    setChips(el, [
                        { k: 'Total', v: (rbShown == null ? '--' : String(Math.trunc(rbShown))), variant: (rbShown != null && rbShown === 0) ? 'ok' : 'neutral' },
                        { k: 'Reset', v: 'manual', variant: 'neutral', title: 'Reset a 0 (UI)' },
                    ]);
                }

                // Colores por umbral (valores típicos; además se respetan min/max de alertas si están configurados)
                const alertVminRaw = document.getElementById('alertVmin')?.value;
                const alertVmaxRaw = document.getElementById('alertVmax')?.value;
                const alertVmin = Number(alertVminRaw);
                const alertVmax = Number(alertVmaxRaw);
                const hasVmin = !!(alertVminRaw != null && alertVminRaw.trim() !== '' && Number.isFinite(alertVmin));
                const hasVmax = !!(alertVmaxRaw != null && alertVmaxRaw.trim() !== '' && Number.isFinite(alertVmax));
                if (v == null || Number.isNaN(v)) {
                    setMetricStateById('voltage', 'metric-neutral');
                } else if ((hasVmin && v < alertVmin) || (hasVmax && v > alertVmax)) {
                    setMetricStateById('voltage', 'metric-bad', `Fuera de rango (${hasVmin ? alertVmin : '-'} – ${hasVmax ? alertVmax : '-' } V)`);
                } else {
                    // fallback si no hay min/max
                    const st = v < 1.0 ? 'metric-bad' : (v < 1.8 ? 'metric-warn' : 'metric-good');
                    setMetricStateById('voltage', st);
                }

                if (!rssiOk) {
                    setMetricStateById('rssi', 'metric-neutral');
                } else {
                    const st = rssi >= -60 ? 'metric-good' : (rssi >= -75 ? 'metric-warn' : 'metric-bad');
                    setMetricStateById('rssi', st);
                }

                // Ya no mostramos el umbral en la sección "DISPOSITIVO CONECTADO"

                if (rbShown == null) {
                    setMetricStateById('reboots', 'metric-neutral');
                } else {
                    const st = rbShown === 0 ? 'metric-good' : (rbShown <= 2 ? 'metric-warn' : 'metric-bad');
                    setMetricStateById('reboots', st);
                }

                const rawValve = (data.valve_state || '').toString().toUpperCase();
                const isOn = rawValve === 'ON' || rawValve === '1' || rawValve === 'TRUE';
                const isOff = rawValve === 'OFF' || rawValve === '0' || rawValve === 'FALSE';

                const valveDotChart = document.getElementById('valveDotChart');
                const valveTextChart = document.getElementById('valveTextChart');
                if (isOn) {
                    valveDotChart.className = 'valve-dot on';
                    valveTextChart.textContent = 'ENCENDIDA';
                } else if (isOff) {
                    valveDotChart.className = 'valve-dot off';
                    valveTextChart.textContent = 'APAGADA';
                } else {
                    valveDotChart.className = 'valve-dot';
                    valveTextChart.textContent = 'SIN DATOS';
                }

                // --- Mantener el histórico local como fallback y refrescar gráficas del servidor ---
                try {
                    const sampleDate = parseTsToDate(data.created_at) || nowAdjusted();
                    const nowMs = sampleDate.getTime();
                    const hum = Number.parseFloat(data.humidity);
                    const valveVal = isOn ? 1 : (isOff ? 0 : null);
                    const store = loadStore();
                    ingestSample(store, nowMs, hum, valveVal === 1);
                    // Importante: si SSE está caído, esto mantiene las gráficas vivas.
                    scheduleChartsRebuild();
                } catch {}

                // Estado online/offline del dispositivo basado en “último dato”
                let deviceOnline = null;
                try {
                    const sampleDate = parseTsToDate(data.created_at);
                    const deadRaw = document.getElementById('alertDeadMin')?.value;
                    const deadMin = Number(deadRaw);
                    const maxAgeMs = (deadRaw != null && deadRaw.trim() !== '' && Number.isFinite(deadMin) && deadMin > 0)
                        ? deadMin * 60000
                        : 3 * 60000;
                    const ageMs = sampleDate ? (nowAdjusted().getTime() - sampleDate.getTime()) : Infinity;
                    const lastSampleLabel = (data && data.created_at_madrid)
                        ? String(data.created_at_madrid)
                        : (sampleDate ? sampleDate.toLocaleString('es-ES', { timeZone: TZ, hour12: false }) : '--');
                    deviceOnline = ageMs <= maxAgeMs;
                    setConnectionUI(deviceOnline ? 'online' : 'offline');
                } catch {
                    setConnectionUI('unknown');
                }

                // Rendimiento: no forzar rebuild de gráficas en cada tick
                // (se reconstruyen con throttle por SSE/intervalos)
                
                // Mostrar también la hora del último dato para detectar desfases/datos viejos
                const sampleDateForUi = parseTsToDate(data?.created_at);
                const lastSampleUi = (data && data.created_at_madrid)
                    ? String(data.created_at_madrid)
                    : (sampleDateForUi ? sampleDateForUi.toLocaleString('es-ES', { timeZone: TZ, hour12: false }) : '--');

                if (deviceOnline === false) {
                    setStatusText(` Offline (datos antiguos) · Último: ${lastSampleUi} · Ahora: ${fmtNowEs.format(nowAdjusted())}`);
                    setStatusClass(false);
                } else {
                    setStatusText(` Online · Último: ${lastSampleUi} · Ahora: ${fmtNowEs.format(nowAdjusted())}`);
                    setStatusClass(true);
                }
            } catch(e) {
                setConnectionUI('offline');
                setStatusText(' Sin conexion');
                setStatusClass(false);
            }

            // Zonas: últimos valores por canal
            try {
                const r2 = await fetch(`/api/channels/${encodeURIComponent(deviceCode)}/latest`, { credentials: 'include' });
                if (r2.ok) {
                    const p = await r2.json();
                    updateZonesFromLatestPayload(p);
                }
            } catch {
                // ignore
            }
        }

        async function cargarAlertas() {
            const st = document.getElementById('alertsStatus');
            const listEl = document.getElementById('alertsList');
            try {
                const r = await fetch(`/api/alerts/${encodeURIComponent(deviceCode)}?limit=10`);
                const j = await r.json();
                const rows = Array.isArray(j.rows) ? j.rows : [];
                st.textContent = rows.length ? `Últimas ${rows.length} alertas` : 'Sin alertas';
                listEl.innerHTML = '';
                for (const a of rows) {
                    const item = document.createElement('div');
                    item.className = 'sensor-card';
                    item.style.textAlign = 'left';
                    const when = a.created_at_madrid || (a.created_at ? new Date(a.created_at).toLocaleString('es-ES', { timeZone: TZ, hour12: false }) : '--');
                    item.innerHTML = `
                        <div class="sensor-label">${a.kind} · ${when}</div>
                        <div style="color:#ddd; font-weight:bold;">${a.message}</div>
                    `;
                    listEl.appendChild(item);
                }
            } catch {
                st.textContent = 'No se pudieron cargar alertas';
            }
        }

        function startSSE() {
            try {
                const es = new EventSource(`/api/sse/${encodeURIComponent(deviceCode)}`);
                es.addEventListener('sensor', () => {
                    actualizarSensores();
                    scheduleChartsRebuild();
                });
                es.addEventListener('alert', () => {
                    cargarAlertas();
                });
                es.onerror = () => {
                    try { es.close(); } catch {}
                };
            } catch {
                // ignore
            }
        }

        async function boot() {
            initCollapsibles();
            try { initCompareButtons(); } catch {}
            const ok = await loadDevices();
            if (!ok) return;
            if (!hasDevices) return;

            await cargarConfig();
            await loadChannels();
            renderZonesUI();
            scheduleChartsRebuild();
            rebuildCharts();
            cargarAlertas();
            actualizarSensores();
            startSSE();
            setInterval(actualizarSensores, 15000);
            setInterval(scheduleChartsRebuild, 60000);
            setInterval(cargarAlertas, 60000);
        }

        boot();

        // --- UI acciones rápidas ---
        document.getElementById('btnAddDevice')?.addEventListener('click', async () => {
            const btn = document.getElementById('btnAddDevice');
            await withBusy(btn, 'Añadiendo...', async () => {
            const deviceRaw = prompt('Código del dispositivo (ej: RIEGO_002):');
            if (deviceRaw === null) return; // Cancel
            const device_code = String(deviceRaw || '').trim();
            if (!device_code) return;

            const tokenRaw = prompt('claim_token (código de emparejamiento):');
            if (tokenRaw === null) return; // Cancel
            const claim_token = String(tokenRaw || '').trim();
            if (!claim_token) {
                alert('Debes pegar el claim_token (token del ESP32) para emparejar.');
                return;
            }
            try {
                // Preferido (multi-tenant): claim
                let r = await fetch('/api/device/claim', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({ device_code, claim_token })
                });

                if (r.status === 401) {
                    const next = encodeURIComponent(location.pathname + location.search + location.hash);
                    window.location.href = `/login?next=${next}`;
                    return;
                }

                // Fallback legacy: register (sin cuentas)
                if (r.status === 404 || r.status === 405) {
                    const name = (prompt('Nombre (opcional):') || 'ESP32 Riego').trim();
                    const locationTxt = (prompt('Ubicación (opcional):') || '').trim();
                    r = await fetch('/api/device/register', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include',
                        body: JSON.stringify({ device_code, name, location: locationTxt || null })
                    });
                }

                const j = await r.json().catch(() => ({}));
                if (!r.ok) throw new Error(j.error || 'No se pudo añadir');

                window.location.href = `/panel/${encodeURIComponent(device_code)}`;
            } catch {
                alert('No se pudo añadir el dispositivo (verifica el claim_token)');
            }
            });
        });

        document.getElementById('btnAddValve')?.addEventListener('click', () => {
            (async () => {
                const btn = document.getElementById('btnAddValve');
                await withBusy(btn, 'Añadiendo...', async () => {
                const current = (channels || []).filter(c => c && c.kind === 'valve').length;
                if (current >= 8) {
                    alert('Máximo 8 válvulas por dispositivo (modelo de 8 zonas).');
                    return;
                }
                const nameRaw = prompt('Nombre de la nueva válvula (ej: Válvula 2):');
                if (nameRaw === null) return; // Cancel
                const name = String(nameRaw || '').trim();
                const headers = { 'Content-Type': 'application/json' };
                const saved = (getSavedToken(deviceCode) || '').trim();
                if (saved) headers['X-Device-Token'] = saved;
                let r = await fetch(`/api/channels/${encodeURIComponent(deviceCode)}`, {
                    method: 'POST',
                    headers,
                    credentials: 'include',
                    body: JSON.stringify({ kind: 'valve', name: name || undefined })
                });
                if ((r.status === 401 || r.status === 403) && !saved) {
                    const tRaw = prompt('Este dispositivo requiere token para añadir válvulas. Pégalo aquí:');
                    if (tRaw === null) return; // Cancel
                    const t = String(tRaw || '').trim();
                    if (t) {
                        saveToken(deviceCode, t);
                        r = await fetch(`/api/channels/${encodeURIComponent(deviceCode)}`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json', 'X-Device-Token': t },
                            credentials: 'include',
                            body: JSON.stringify({ kind: 'valve', name: name || undefined })
                        });
                    }
                }
                if (!r.ok) return alert('No se pudo añadir la válvula');
                await loadChannels();
                scheduleChartsRebuild();
                alert('Válvula añadida. La gráfica aparecerá cuando el ESP32 envíe datos de esa válvula.');
                });
            })();
        });

        function pickSensorTypeModal() {
            const options = [
                { kind: 'temperature_air', label: 'Temperatura aire' },
                { kind: 'temperature_soil', label: 'Temperatura tierra' },
                { kind: 'ph_soil', label: 'pH tierra' },
                { kind: 'ec_soil', label: 'EC tierra' },
                { kind: 'soil_sensor', label: 'Humedad tierra' },
                { kind: 'humidity_air', label: 'Humedad aire' }
            ];

            return new Promise((resolve) => {
                const overlay = document.createElement('div');
                overlay.className = 'modal-overlay';
                overlay.innerHTML = `
                    <div class="modal" role="dialog" aria-modal="true" aria-label="Seleccionar tipo de sensor">
                        <div class="modal-title">¿Qué sensor quieres añadir?</div>
                        <div class="choice-grid">
                            ${options.map(o => `<button class="mini-btn" type="button" data-kind="${escapeHtml(o.kind)}">${escapeHtml(o.label)}</button>`).join('')}
                        </div>
                        <div class="modal-actions">
                            <button class="mini-btn" type="button" data-cancel="1">Cancelar</button>
                        </div>
                    </div>
                `;

                const cleanup = () => {
                    try { document.removeEventListener('keydown', onKeyDown); } catch {}
                    overlay.remove();
                };

                const onKeyDown = (e) => {
                    if (e.key === 'Escape') {
                        cleanup();
                        resolve(null);
                    }
                };

                overlay.addEventListener('click', (e) => {
                    if (e.target === overlay) {
                        cleanup();
                        resolve(null);
                    }
                });

                overlay.querySelectorAll('button[data-kind]').forEach((b) => {
                    b.addEventListener('click', () => {
                        const kind = b.getAttribute('data-kind');
                        const opt = options.find(o => o.kind === kind) || null;
                        cleanup();
                        resolve(opt);
                    });
                });
                overlay.querySelector('button[data-cancel]')?.addEventListener('click', () => {
                    cleanup();
                    resolve(null);
                });

                document.addEventListener('keydown', onKeyDown);
                document.body.appendChild(overlay);
            });
        }

        function pickZoneModal({ title = '¿Para qué planta?' } = {}) {
            return new Promise((resolve) => {
                const overlay = document.createElement('div');
                overlay.className = 'modal-overlay';
                overlay.innerHTML = `
                    <div class="modal" role="dialog" aria-modal="true" aria-label="Seleccionar planta">
                        <div class="modal-title">${escapeHtml(title)}</div>
                        <div class="choice-grid">
                            ${Array.from({ length: 8 }).map((_, i) => {
                                const z = i + 1;
                                return `<button class="mini-btn" type="button" data-zone="${z}">Planta ${z}</button>`;
                            }).join('')}
                            <button class="mini-btn" type="button" data-zone="0">(sin asignar)</button>
                        </div>
                        <div class="modal-actions">
                            <button class="mini-btn" type="button" data-cancel="1">Cancelar</button>
                        </div>
                    </div>
                `;

                const cleanup = () => {
                    try { document.removeEventListener('keydown', onKeyDown); } catch {}
                    overlay.remove();
                };
                const onKeyDown = (e) => {
                    if (e.key === 'Escape') {
                        cleanup();
                        resolve(null);
                    }
                };

                overlay.addEventListener('click', (e) => {
                    if (e.target === overlay) {
                        cleanup();
                        resolve(null);
                    }
                });

                overlay.querySelectorAll('button[data-zone]').forEach((b) => {
                    b.addEventListener('click', () => {
                        const z = Number(b.getAttribute('data-zone'));
                        cleanup();
                        resolve(Number.isFinite(z) ? z : null);
                    });
                });
                overlay.querySelector('button[data-cancel]')?.addEventListener('click', () => {
                    cleanup();
                    resolve(null);
                });

                document.addEventListener('keydown', onKeyDown);
                document.body.appendChild(overlay);
            });
        }

        function pickCompareGraphModal() {
            return new Promise((resolve) => {
                const overlay = document.createElement('div');
                overlay.className = 'modal-overlay';

                const lastZoneKey = `ui:cmpAdd:lastZone:${deviceCode}`;
                let lastZone = '';
                try {
                    const raw = localStorage.getItem(lastZoneKey);
                    if (raw === '' || raw == null) lastZone = '';
                    else {
                        const v = Number(raw);
                        lastZone = (Number.isFinite(v) && v >= 1 && v <= 8) ? String(v) : '';
                    }
                } catch {}

                overlay.innerHTML = `
                    <div class="modal" role="dialog" aria-modal="true" aria-label="Añadir gráfica al comparador">
                        <div class="modal-title">Añadir gráfica</div>
                        <div class="muted" style="margin-top:-6px; margin-bottom: 10px; font-size:12px; color:#8fa3bf; line-height:1.35;">
                            Elige la planta y el sensor para crear una nueva gráfica en tiempo real (máx. 8).
                        </div>
                        <div class="cmp-controls" style="margin: 0;">
                            <div class="control-row" style="margin: 0 0 10px;">
                                <label style="flex: 0 0 auto; min-width: 84px;">Planta:</label>
                                <select class="cmp-select" id="cmpModalZone" title="Seleccionar planta"></select>
                            </div>
                            <div class="control-row" style="margin: 0;">
                                <label style="flex: 0 0 auto; min-width: 84px;">Sensor:</label>
                                <select class="cmp-select" id="cmpModalChannel" title="Seleccionar sensor"></select>
                            </div>
                        </div>
                        <div class="modal-actions">
                            <button class="mini-btn" type="button" data-cancel="1">Cancelar</button>
                            <button class="mini-btn primary" type="button" data-create="1">Crear</button>
                        </div>
                    </div>
                `;

                const zoneSel = overlay.querySelector('#cmpModalZone');
                const chSel = overlay.querySelector('#cmpModalChannel');
                const createBtn = overlay.querySelector('button[data-create]');

                const cleanup = () => {
                    try { document.removeEventListener('keydown', onKeyDown); } catch {}
                    overlay.remove();
                };

                const onKeyDown = (e) => {
                    if (e.key === 'Escape') {
                        cleanup();
                        resolve(null);
                    }
                };

                overlay.addEventListener('click', (e) => {
                    if (e.target === overlay) {
                        cleanup();
                        resolve(null);
                    }
                });

                // Planta: '' = todas (sin filtrar) + 1..8
                if (zoneSel) {
                    zoneSel.innerHTML = '';
                    const all = document.createElement('option');
                    all.value = '';
                    all.textContent = 'Todas';
                    zoneSel.appendChild(all);
                    for (let z = 1; z <= 8; z++) {
                        const opt = document.createElement('option');
                        opt.value = String(z);
                        opt.textContent = `Planta ${z}`;
                        zoneSel.appendChild(opt);
                    }
                    zoneSel.value = String(lastZone);
                }

                const refreshChannels = () => {
                    const z = zoneSel ? Number(zoneSel.value) : NaN;
                    const zoneNum = (Number.isFinite(z) && z >= 1 && z <= 8) ? z : null;
                    populateCompareSelect(chSel, zoneNum);

                    const hasRealChoice = !!(chSel && chSel.querySelector('option[value]:not([value=""])'));
                    if (createBtn) createBtn.disabled = !hasRealChoice;
                };

                zoneSel?.addEventListener('change', () => {
                    try { localStorage.setItem(lastZoneKey, String(zoneSel.value || '')); } catch {}
                    refreshChannels();
                });

                chSel?.addEventListener('change', () => {
                    const ok = !!(chSel && String(chSel.value || '').trim());
                    if (createBtn) createBtn.disabled = !ok;
                });

                overlay.querySelector('button[data-cancel]')?.addEventListener('click', () => {
                    cleanup();
                    resolve(null);
                });

                overlay.querySelector('button[data-create]')?.addEventListener('click', () => {
                    const z = zoneSel ? Number(zoneSel.value) : NaN;
                    const zone = (Number.isFinite(z) && z >= 1 && z <= 8) ? z : null;
                    const channelId = chSel ? String(chSel.value || '').trim() : '';
                    if (!channelId) {
                        alert('Selecciona un sensor.');
                        return;
                    }
                    cleanup();
                    resolve({ zone, channelId });
                });

                document.addEventListener('keydown', onKeyDown);
                document.body.appendChild(overlay);

                // Inicial
                refreshChannels();
                // Si ya hay un valor válido, habilitar
                const ok = !!(chSel && String(chSel.value || '').trim());
                if (createBtn) createBtn.disabled = !ok;
            });
        }

        document.getElementById('btnAddSensor')?.addEventListener('click', () => {
            (async () => {
                const btn = document.getElementById('btnAddSensor');
                await withBusy(btn, 'Añadiendo...', async () => {
                const picked = await pickSensorTypeModal();
                if (!picked) return;
                const kind = picked.kind;

                const zonePicked = await pickZoneModal({ title: `¿En qué planta va este sensor? (${picked.label})` });
                if (zonePicked === null) return; // cancel

                const current = (channels || []).filter(c => c && c.kind === kind).length;
                if (current >= 8) {
                    alert('Máximo 8 sensores de este tipo por dispositivo.');
                    return;
                }

                const suggested = (zonePicked && zonePicked >= 1)
                    ? `P${zonePicked} · ${picked.label}`
                    : `${picked.label} ${current + 1}`;
                const nameRaw = prompt(`Nombre del nuevo sensor (${picked.label}):`, suggested);
                if (nameRaw === null) return; // Cancel
                const name = String(nameRaw || '').trim();
                const headers = { 'Content-Type': 'application/json' };
                const saved = (getSavedToken(deviceCode) || '').trim();
                if (saved) headers['X-Device-Token'] = saved;
                let r = await fetch(`/api/channels/${encodeURIComponent(deviceCode)}`, {
                    method: 'POST',
                    headers,
                    credentials: 'include',
                    body: JSON.stringify({ kind, name: name || undefined })
                });
                if ((r.status === 401 || r.status === 403) && !saved) {
                    const tRaw = prompt('Este dispositivo requiere token para añadir sensores. Pégalo aquí:');
                    if (tRaw === null) return; // Cancel
                    const t = String(tRaw || '').trim();
                    if (t) {
                        saveToken(deviceCode, t);
                        r = await fetch(`/api/channels/${encodeURIComponent(deviceCode)}`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json', 'X-Device-Token': t },
                            credentials: 'include',
                            body: JSON.stringify({ kind, name: name || undefined })
                        });
                    }
                }
                if (!r.ok) return alert('No se pudo añadir el sensor');

                const created = await r.json().catch(() => null);
                const createdChannel = created && created.channel ? created.channel : null;
                if (createdChannel && zonePicked && zonePicked >= 1) {
                    try {
                        const map = {
                            soil_sensor: 'soil_channel_index',
                            temperature_air: 'temperature_air_channel_index',
                            humidity_air: 'humidity_air_channel_index',
                            temperature_soil: 'temperature_soil_channel_index',
                            ph_soil: 'ph_soil_channel_index',
                            ec_soil: 'ec_soil_channel_index'
                        };
                        const prop = map[kind];
                        if (prop && zonesState && zonesState[zonePicked - 1]) {
                            zonesState[zonePicked - 1][prop] = Number(createdChannel.channel_index);
                        }
                    } catch {}
                }

                await loadChannels();
                scheduleChartsRebuild();
                alert('Sensor añadido. Aparecerá cuando el ESP32 envíe datos de ese sensor.');
                });
            })();
        });

        async function renameChannel(channelId, kindLabel) {
            if (!channelId) return;
            const newName = (prompt(`Nuevo nombre para ${kindLabel}:`) || '').trim();
            if (!newName) return;
            const headers = { 'Content-Type': 'application/json' };
            const saved = (getSavedToken(deviceCode) || '').trim();
            if (saved) headers['X-Device-Token'] = saved;

            let r = await fetch(`/api/channels/${encodeURIComponent(deviceCode)}/${encodeURIComponent(channelId)}`,
                { method: 'PATCH', headers, credentials: 'include', body: JSON.stringify({ name: newName }) });

            if ((r.status === 401 || r.status === 403) && !saved) {
                const t = (prompt('Este dispositivo requiere token para renombrar. Pégalo aquí:') || '').trim();
                if (t) {
                    saveToken(deviceCode, t);
                    r = await fetch(`/api/channels/${encodeURIComponent(deviceCode)}/${encodeURIComponent(channelId)}`,
                        { method: 'PATCH', headers: { ...headers, 'X-Device-Token': t }, credentials: 'include', body: JSON.stringify({ name: newName }) });
                }
            }
            if (!r.ok) return alert('No se pudo renombrar');
            await loadChannels();
            scheduleChartsRebuild();
        }

        document.getElementById('btnRenameHum')?.addEventListener('click', () => renameChannel(humChannelId, 'el sensor'));
        document.getElementById('btnRenameValve')?.addEventListener('click', () => renameChannel(valveChannelId, 'la válvula'));

        async function deleteChannelByIndex(kind, kindLabel) {
            const candidates = (channels || [])
                .filter(c => c && c.kind === kind)
                .filter(c => Number(c.channel_index) !== 1);

            if (!candidates.length) {
                alert(`No hay ${kindLabel}s añadidos para eliminar.`);
                return;
            }

            const indices = candidates.map(c => Number(c.channel_index)).filter(n => Number.isFinite(n)).sort((a,b) => a-b);
            const raw = prompt(`Índice de ${kindLabel} a eliminar (disponibles: ${indices.join(', ')}):`);
            if (raw === null) return; // Cancel
            const idx = Number(String(raw).trim());
            if (!Number.isInteger(idx)) return;

            const target = candidates.find(c => Number(c.channel_index) === idx);
            if (!target) {
                alert('Índice no encontrado.');
                return;
            }

            if (!confirm(`¿Eliminar ${kindLabel} ${idx}? Se borrará también su histórico.`)) return;

            const doDelete = async (headers) => {
                return fetch(`/api/channels/${encodeURIComponent(deviceCode)}/${encodeURIComponent(target.id)}`,
                    { method: 'DELETE', headers, credentials: 'include' });
            };

            const baseHeaders = { 'Content-Type': 'application/json' };
            const saved = (getSavedToken(deviceCode) || '').trim();
            const headers1 = { ...baseHeaders };
            if (saved) headers1['X-Device-Token'] = saved;

            let r = await doDelete(headers1);

            if ((r.status === 401 || r.status === 403) && !saved) {
                const tRaw = prompt('Este dispositivo requiere token para eliminar. Pégalo aquí:');
                if (tRaw === null) return; // Cancel
                const t = String(tRaw || '').trim();
                if (t) {
                    saveToken(deviceCode, t);
                    r = await doDelete({ ...baseHeaders, 'X-Device-Token': t });
                }
            }

            const j = await r.json().catch(() => ({}));
            if (!r.ok) {
                alert(j.error || `No se pudo eliminar ${kindLabel}`);
                return;
            }

            await loadChannels();
            scheduleChartsRebuild();
            alert(`${kindLabel} eliminado.`);
        }

        document.getElementById('btnDeleteHum')?.addEventListener('click', () => deleteChannelByIndex('soil_sensor', 'sensor'));
        document.getElementById('btnDeleteValve')?.addEventListener('click', () => deleteChannelByIndex('valve', 'válvula'));

        document.getElementById('btnDeleteDevice')?.addEventListener('click', async () => {
            if (!confirm(`¿Quitar el dispositivo ${deviceCode} de tu cuenta?`)) return;
            const r = await fetch(`/api/devices/${encodeURIComponent(deviceCode)}`, { method: 'DELETE', credentials: 'include' });
            const j = await r.json().catch(() => ({}));
            if (!r.ok) {
                alert(j.error || 'No se pudo eliminar el dispositivo');
                return;
            }
            location.href = '/app';
        });

        document.getElementById('resetRebootsBtn')?.addEventListener('click', async () => {
            if (!confirm('¿Poner el contador de reinicios a 0 (solo en el panel web)?')) return;
            if (lastRebootsBase == null) {
                alert('Aún no hay datos de reinicios para este dispositivo');
                return;
            }

            // Reset local (sin token): guardamos un offset por dispositivo
            setLocalRebootsOffset(deviceCode, lastRebootsBase);
            actualizarSensores();

            // Best-effort: si el backend admite reset sin auth, lo intentamos, pero nunca pedimos token.
            try {
                await fetch(`/api/device/reboots/reset/${encodeURIComponent(deviceCode)}`, { method: 'POST' });
            } catch {}
        });
    </script>
</body>
</html>
