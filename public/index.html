<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AgroSense · Panel</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: Arial, sans-serif; background: #0b1220; color: #e9eef7; padding: 16px; min-height: 100vh; }
        .container { width: 100%; max-width: none; margin: 0; }
        h1 { color: #dff7e3; margin-bottom: 6px; text-align: center; font-size: 18px; }
        :root {
            --logo-w: clamp(260px, 52vw, 560px);
            --c-primary: #4CAF50;
            --c-danger: #ff3333;
            --btn-radius: 12px;
            --btn-border: rgba(255,255,255,0.14);
            --btn-bg: rgba(255,255,255,0.08);
            --btn-bg-hover: rgba(255,255,255,0.12);
            --btn-shadow: 0 14px 30px rgba(0,0,0,0.28);
            --btn-shadow-hover: 0 18px 38px rgba(0,0,0,0.34);
        }
        .brand-header { display:flex; align-items:center; justify-content:center; margin: 6px 0 10px; }
        .brand-header img { width: var(--logo-w); max-width: 100%; height: auto; object-fit: contain; display:block; filter: drop-shadow(0 14px 30px rgba(0,0,0,0.55)); }
        .brand-title { display:none; }
        .section { background: #16213e; padding: 20px; border-radius: 12px; margin-bottom: 20px; }
        /* DISPOSITIVO: no sticky (molesta al hacer scroll) */
        #deviceSection { position: relative; z-index: 1; backdrop-filter: blur(8px); background: rgba(22,33,62,0.92); border: 1px solid rgba(255,255,255,0.08); box-shadow: 0 18px 40px rgba(0,0,0,0.30); }
        #deviceSection h2 { margin-bottom: 10px; }
        #deviceSection select { width: 100%; max-width: 100%; min-width: 0; }
        #deviceSection .control-row { flex-wrap: wrap; }
        #deviceSection .control-row label { flex: 0 0 100%; }
        #deviceSection .control-row select { flex: 1 1 100%; }
        .topbar-mini { display:flex; justify-content:space-between; gap: 10px; flex-wrap: wrap; align-items:center; margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.08); }
        .topbar-mini .mini-k { font-size: 11px; color:#8fa3bf; text-transform: uppercase; letter-spacing: .02em; margin-right: 6px; }
        .topbar-mini .mini-v { font-weight: 700; color:#e9eef7; }
        .topbar-mini .right { display:flex; gap: 10px; align-items:center; flex-wrap: wrap; justify-content:flex-end; }
        .pill { display:inline-flex; gap: 8px; align-items:center; padding: 6px 10px; border-radius: 999px; border: 1px solid rgba(255,255,255,0.10); background: rgba(0,0,0,0.10); font-size: 12px; color:#c9d1d9; }
        .section h2 { color: #4CAF50; font-size: 16px; margin-bottom: 15px; border-bottom: 1px solid #333; padding-bottom: 10px; }
        /* Rejilla responsive: evita que en móvil se “salgan” las tarjetas */
        .sensor-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 15px; }
        .sensor-card { background: #0f3460; padding: 15px; border-radius: 8px; text-align: center; min-width: 0; border: 1px solid rgba(255,255,255,0.06); box-shadow: 0 10px 26px rgba(0,0,0,0.25); transition: transform 0.12s ease, border-color 0.12s ease, box-shadow 0.12s ease; }
        .sensor-card:hover { transform: translateY(-1px); border-color: rgba(255,255,255,0.12); box-shadow: 0 14px 32px rgba(0,0,0,0.30); }
        .sensor-label { font-size: 11px; color: #ffffff; text-transform: uppercase; margin-bottom: 5px; }
        .sensor-value { font-size: clamp(22px, 6vw, 32px); font-weight: bold; color: #4CAF50; }
        .sensor-unit { font-size: 14px; color: #33cc33; }

        /* Estado visual para métricas (voltaje/RSSI/uptime/reinicios) */
        .metric-good .sensor-value { color: #33cc33; }
        .metric-warn .sensor-value { color: #ffcc00; }
        .metric-bad  .sensor-value { color: #ff4d4d; }
        .metric-neutral .sensor-value { color: #aaa; }

        .metric-good { border-color: rgba(51,204,51,0.25); box-shadow: 0 12px 28px rgba(51,204,51,0.08), 0 10px 26px rgba(0,0,0,0.25); }
        .metric-warn { border-color: rgba(255,204,0,0.25); box-shadow: 0 12px 28px rgba(255,204,0,0.08), 0 10px 26px rgba(0,0,0,0.25); }
        .metric-bad  { border-color: rgba(255,77,77,0.30); box-shadow: 0 12px 28px rgba(255,77,77,0.10), 0 10px 26px rgba(0,0,0,0.25); }
        .metric-neutral { border-color: rgba(255,255,255,0.08); }

        /* Mini “pantalla OLED” dentro de tarjeta */
        .oled-panel {
            margin-top: 10px;
            padding: 10px 12px;
            border-radius: 10px;
            border: 1px solid rgba(34,197,94,0.22);
            background: radial-gradient(120% 140% at 10% 0%, rgba(34,197,94,0.10), rgba(0,0,0,0.18));
            box-shadow: 0 14px 30px rgba(0,0,0,0.20), inset 0 0 0 1px rgba(255,255,255,0.04);
            color: rgba(187,247,208,0.95);
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 12px;
            line-height: 1.35;
            white-space: pre-wrap;
            word-break: break-word;
        }

        /* Zonas / Plantas */
        .zone-off { opacity: 0.62; }
        .zone-subtitle { color:#8fa3bf; font-size: 12px; margin-top: -6px; margin-bottom: 8px; overflow-wrap: anywhere; word-break: break-word; }
        .zone-row { display:flex; gap: 10px; flex-wrap: wrap; align-items: center; margin-bottom: 12px; }
        .zone-row .control-row { margin-bottom: 0; flex: 1 1 320px; }
        .zone-mini { font-size: 11px; color:#8fa3bf; }
        .mini-btn.tiny { padding: 6px 10px; font-size: 11px; border-radius: 10px; box-shadow: 0 10px 22px rgba(0,0,0,0.18); }
        .sensor-value.small { font-size: 16px; color: #e9eef7; font-weight: 800; word-break: break-word; }
        .valve-indicator { display: flex; align-items: center; justify-content: center; gap: 10px; margin-top: 8px; flex-wrap: wrap; }
        .valve-dot { width: 14px; height: 14px; border-radius: 50%; background: #666; box-shadow: 0 0 10px #000; }
        .valve-dot.on { background: #33cc33; box-shadow: 0 0 18px #33cc33; }
        .valve-dot.off { background: #ff3333; box-shadow: 0 0 18px #ff3333; }
        .valve-text { font-size: 14px; font-weight: bold; color: #ddd; max-width: 100%; overflow: hidden; text-overflow: ellipsis; }
        .leds-container { display: flex; justify-content: center; gap: 15px; margin: 20px 0; }
        .led { width: 40px; height: 40px; border-radius: 50%; border: 3px solid #333; transition: all 0.3s; }
        .control-row { display: flex; gap: 10px; margin-bottom: 15px; align-items: center; }
        .control-row label { flex: 1; color: #ffffff; }
        .control-row input, .control-row select { flex: 2; padding: 10px; border: none; border-radius: 6px; background: #0f3460; color: #fff; font-size: 14px; min-width: 0; }
        .control-row textarea { flex: 2; width: 100%; min-width: 0; padding: 12px; border: 1px solid rgba(255,255,255,0.12); border-radius: 14px; background: rgba(15,52,96,0.55); color: #fff; font-size: 14px; line-height: 1.4; min-height: 140px; resize: vertical; box-shadow: 0 12px 28px rgba(0,0,0,0.18); }
        .control-row input:focus, .control-row select:focus, .control-row textarea:focus { outline: 2px solid rgba(76,175,80,0.35); outline-offset: 2px; }
        .control-row.textarea-row { align-items: flex-start; }
        .control-row.textarea-row label { padding-top: 10px; }
        .control-row input[type="range"] { -webkit-appearance: none; appearance: none; height: 8px; }
        .control-row input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 20px; height: 20px; background: #4CAF50; border-radius: 50%; cursor: pointer; }
        .btn-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin: 15px 0; }
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 12px 10px;
            border: 1px solid var(--btn-border);
            border-radius: var(--btn-radius);
            cursor: pointer;
            font-weight: 800;
            font-size: 12px;
            letter-spacing: .02em;
            box-shadow: var(--btn-shadow);
            transition: transform 0.12s ease, box-shadow 0.18s ease, filter 0.18s ease, background 0.18s ease, border-color 0.18s ease;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        .btn:hover { transform: translateY(-1px); box-shadow: var(--btn-shadow-hover); filter: brightness(1.03); }
        .btn:active { transform: translateY(0); filter: brightness(0.98); }
        .btn:focus-visible { outline: 2px solid rgba(76,175,80,0.45); outline-offset: 2px; }
        .btn-rojo { background: linear-gradient(180deg, rgba(255,77,77,1), rgba(255,51,51,1)); color: white; border-color: rgba(255,77,77,0.35); }
        .btn-verde { background: linear-gradient(180deg, rgba(76,175,80,1), rgba(51,204,51,1)); color: white; border-color: rgba(76,175,80,0.35); }
        .btn-azul { background: linear-gradient(180deg, rgba(59,130,246,1), rgba(51,102,255,1)); color: white; border-color: rgba(59,130,246,0.35); }
        .btn-amarillo { background: linear-gradient(180deg, rgba(255,224,102,1), rgba(255,204,0,1)); color: #0b1220; border-color: rgba(255,204,0,0.35); }
        .btn-cian { background: linear-gradient(180deg, rgba(34,211,238,1), rgba(0,204,204,1)); color: #0b1220; border-color: rgba(34,211,238,0.35); }
        .btn-magenta { background: linear-gradient(180deg, rgba(217,70,239,1), rgba(204,51,204,1)); color: white; border-color: rgba(217,70,239,0.35); }
        .btn-blanco { background: linear-gradient(180deg, rgba(255,255,255,1), rgba(226,232,240,1)); color: #0b1220; border-color: rgba(255,255,255,0.35); }
        /* Botón neutro/off: estilo más moderno (glass + azul) */
        .btn-off {
            background: linear-gradient(180deg, rgba(59,130,246,0.22), rgba(15,23,42,0.70));
            color: rgba(226,232,240,0.92);
            border-color: rgba(56,189,248,0.22);
            box-shadow: 0 14px 30px rgba(0,0,0,0.22);
        }
        .btn-save { background: linear-gradient(180deg, rgba(76,175,80,1), rgba(45,183,95,1)); color: white; width: 100%; padding: 14px; font-size: 15px; margin-top: 10px; border-color: rgba(76,175,80,0.35); }
        .status { text-align: center; font-size: 12px; color: #33cc33; margin-top: 15px; }
        .status.online { color: #4CAF50; }
        .status.offline { color: #ff3333; }
        .current-color { text-align: center; padding: 10px; background: #0f3460; border-radius: 8px; margin: 10px 0; }
        .current-color span { font-weight: bold; color: #4CAF50; }
        /* Gráficas sin scroll: se ajustan al espacio disponible */
        .charts-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
        @media (max-width: 900px) {
            .charts-grid { grid-template-columns: 1fr; }
        }
        .chart-box { text-align: left; min-width: 0; }
        .chart-wrap { position: relative; width: 100%; height: clamp(160px, 24vh, 260px); }
        .chart-wrap canvas { width: 100% !important; height: 100% !important; display: block; }
        .btn.active { outline: 2px solid rgba(255,255,255,0.35); opacity: 0.95; }
        .summary { display:flex; justify-content:space-between; gap: 12px; flex-wrap: wrap; margin: 8px 0 0; }
        .summary .k { color: #33cc33; font-size: 11px; text-transform: uppercase; }
        .summary .v { color: #ddd; font-weight: bold; }

        .hidden { display: none; }

        /* Navegación Cuenta/Dispositivos */
        .top-nav { display:flex; gap: 10px; align-items:center; flex-wrap: wrap; margin: 6px 0 12px; }
        .top-nav .spacer { flex: 1 1 auto; }
        .mini-btn.active { outline: 2px solid rgba(255,255,255,0.30); }

        body.mode-account .container > .section { display: none; }
        body.mode-account #accountSection { display: block; }
        body.mode-account #status { display:none; }

        body.mode-support .container > .section { display: none; }
        body.mode-support #supportSection { display: block; }
        body.mode-support #status { display:none; }

        .tickets-list { display:flex; flex-direction:column; gap: 8px; margin-top: 10px; }
        .ticket-item { padding: 10px; border-radius: 12px; background: rgba(15,52,96,0.35); border: 1px solid rgba(255,255,255,0.08); cursor: pointer; }
        .ticket-item:hover { background: rgba(15,52,96,0.45); }
        .ticket-title { font-weight: 800; }
        .ticket-meta { color: #8fa3bf; font-size: 12px; margin-top: 4px; }
        .messages { border: 1px solid rgba(255,255,255,0.10); border-radius: 12px; background: rgba(0,0,0,0.10); padding: 10px; max-height: 320px; overflow:auto; }
        .msg { padding: 10px; border-radius: 12px; background: rgba(15,52,96,0.22); border: 1px solid rgba(255,255,255,0.06); margin-bottom: 8px; }
        .msg-meta { color:#8fa3bf; font-size: 12px; margin-bottom: 6px; }
        .msg-body { white-space: pre-wrap; }

        /* Selector de canales (más moderno) */
        .channel-cards { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin: 10px 0 6px; }
        @media (max-width: 900px) { .channel-cards { grid-template-columns: 1fr; } }
        .channel-card { background: rgba(15,52,96,0.35); border: 1px solid rgba(255,255,255,0.08); border-radius: 12px; padding: 12px; min-width: 0; }
        .channel-title { display:flex; align-items:center; justify-content:space-between; gap: 10px; margin-bottom: 8px; }
        .channel-title .sensor-label { margin-bottom: 0; }
        .channel-actions { display:flex; gap: 8px; margin-top: 8px; flex-wrap: wrap; }
        .channel-card select { width: 100%; }

        .mini-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            background: linear-gradient(180deg, rgba(59,130,246,0.22), rgba(34,211,238,0.10));
            border: 1px solid rgba(56,189,248,0.20);
            color: #e9eef7;
            padding: 8px 12px;
            border-radius: var(--btn-radius);
            cursor: pointer;
            font-size: 12px;
            font-weight: 800;
            letter-spacing: .02em;
            box-shadow: 0 12px 26px rgba(0,0,0,0.20);
            transition: transform 0.12s ease, box-shadow 0.18s ease, filter 0.18s ease, background 0.18s ease, border-color 0.18s ease;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        .mini-btn:hover { transform: translateY(-1px); box-shadow: 0 16px 34px rgba(0,0,0,0.28); filter: brightness(1.04); }
        .mini-btn:active { transform: translateY(0); filter: brightness(0.98); }
        .mini-btn:focus-visible { outline: 2px solid rgba(76,175,80,0.45); outline-offset: 2px; }
        .mini-btn.danger { border-color: rgba(255,77,77,0.35); color: #ffd1d1; background: linear-gradient(180deg, rgba(255,77,77,0.18), rgba(255,255,255,0.06)); }
        .mini-btn.primary { border-color: rgba(76,175,80,0.40); color: #d7ffe0; background: linear-gradient(180deg, rgba(76,175,80,0.22), rgba(255,255,255,0.06)); }
        .mini-btn:disabled {
            cursor: not-allowed;
            opacity: 0.72;
            filter: grayscale(0.15);
            background: linear-gradient(180deg, rgba(148,163,184,0.14), rgba(15,23,42,0.55));
            border-color: rgba(148,163,184,0.18);
            box-shadow: 0 10px 22px rgba(0,0,0,0.16);
        }
        .badge { display:inline-flex; align-items:center; justify-content:center; min-width: 18px; height: 18px; padding: 0 6px; border-radius: 999px; font-size: 11px; font-weight: 900; background: rgba(239,68,68,0.95); color: #fff; margin-left: 8px; border: 1px solid rgba(255,255,255,0.20); }
        .badge.hidden { display:none; }

        .conn { display: inline-flex; align-items: center; gap: 8px; margin-top: 6px; font-size: 12px; color: #c9d1d9; opacity: 0.95; }
        .dot { width: 10px; height: 10px; border-radius: 999px; background: #6b7280; box-shadow: 0 0 0 2px rgba(255,255,255,0.08) inset; }
        .dot.online { background: #22c55e; }
        .dot.offline { background: #ef4444; }
        .dot.unknown { background: #6b7280; }

        /* Secciones plegables */
        .section-head { display:flex; align-items:center; justify-content:space-between; gap: 10px; }
        .collapse-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            background: linear-gradient(180deg, rgba(255,255,255,0.10), rgba(255,255,255,0.06));
            border: 1px solid var(--btn-border);
            color: #e9eef7;
            padding: 7px 10px;
            border-radius: var(--btn-radius);
            cursor: pointer;
            font-size: 12px;
            font-weight: 800;
            letter-spacing: .02em;
            box-shadow: 0 12px 26px rgba(0,0,0,0.20);
            transition: transform 0.12s ease, box-shadow 0.18s ease, filter 0.18s ease, background 0.18s ease, border-color 0.18s ease;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        .collapse-btn:hover { transform: translateY(-1px); box-shadow: 0 16px 34px rgba(0,0,0,0.28); filter: brightness(1.04); }
        .collapse-btn:active { transform: translateY(0); filter: brightness(0.98); }
        .collapse-btn:focus-visible { outline: 2px solid rgba(76,175,80,0.45); outline-offset: 2px; }
        .section.collapsed .section-body { display:none; }

        /* Compacto en móvil */
        @media (max-width: 640px) {
            body { padding: 10px; }
            .section { padding: 14px; margin-bottom: 14px; }
            #deviceSection { top: auto; }
            .sensor-grid { grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 10px; }
            .sensor-card { padding: 12px; }
            .btn-grid { grid-template-columns: repeat(2, 1fr); }
            /* Zonas: evitar overflow horizontal en móvil */
            .zone-row { gap: 8px; }
            .zone-row .control-row { flex: 1 1 100%; }
            .zone-subtitle { font-size: 11px; line-height: 1.35; }

            /* Controles: label arriba, control abajo */
            .zone-row .control-row { flex-wrap: wrap; }
            .zone-row .control-row label { flex: 0 0 100%; }
            .zone-row .control-row input,
            .zone-row .control-row select { flex: 1 1 100%; width: 100%; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="brand-header">
            <img
                            src="/logo-wide.png?v=20260128r2"
                            srcset="/logo-wide.png?v=20260128r2 1x, /logo-wide@2x.png?v=20260128r2 2x"
              alt="AgroSense"
              onerror="this.style.display='none'"
            />
        </div>
        <div class="status" style="margin-bottom: 12px;">UI vRt1548A</div>

        <div class="top-nav">
            <button class="mini-btn active" id="navDevices" type="button">Dispositivos</button>
            <button class="mini-btn" id="navAccount" type="button">Cuenta</button>
                <button class="mini-btn" id="navSupport" type="button">Soporte <span class="badge hidden" id="supportBadge">0</span></button>
            <span class="spacer"></span>
            <button class="mini-btn danger" id="navLogout" type="button">Salir</button>
        </div>

        <div class="section hidden" id="accountSection">
            <h2> CUENTA</h2>
            <div class="status" id="accountStatus">—</div>
            <div class="control-row"><label>Email:</label><input id="accEmail" type="email" disabled /></div>
            <div class="control-row"><label>Nombre:</label><input id="accFullName" type="text" placeholder="Nombre y apellidos" /></div>
            <div class="control-row"><label>Teléfono:</label><input id="accPhone" type="tel" placeholder="Teléfono" /></div>
            <div class="control-row"><label>Dirección:</label><input id="accAddress" type="text" placeholder="Calle, número, etc." /></div>
            <div class="control-row"><label>Provincia:</label><input id="accProvince" type="text" placeholder="Provincia" /></div>
            <div class="control-row"><label>Ciudad:</label><input id="accCity" type="text" placeholder="Ciudad" /></div>
            <div class="control-row"><label>País:</label><input id="accCountry" type="text" placeholder="País" /></div>
            <div style="display:flex; gap: 10px; flex-wrap: wrap; margin-top: 10px;">
                <button class="mini-btn primary" id="btnSaveProfile" type="button">Guardar</button>
                <button class="mini-btn danger" id="btnDeleteAccount" type="button">Eliminar cuenta</button>
            </div>
            <div class="muted" style="margin-top:10px; font-size:12px; color:#8fa3bf; line-height:1.35;">
                Eliminar cuenta borra tu usuario y desvincula tus dispositivos.
            </div>
        </div>

        <div class="section hidden" id="supportSection">
            <h2> SOPORTE (TICKETS)</h2>
            <div class="status" id="supportStatus">—</div>

            <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.08);"></div>
            <h2 style="margin-top: 10px;"> ABRIR TICKET</h2>
            <div class="control-row"><label>Asunto:</label><input id="tSubject" type="text" placeholder="Ej: No riega / sensor falla" /></div>
            <div class="control-row"><label>Dispositivo (opcional):</label>
                <select id="tDevice" title="Dispositivo (opcional)">
                    <option value="">(sin dispositivo)</option>
                </select>
            </div>
            <div class="control-row textarea-row"><label>Mensaje:</label><textarea id="tMessage" placeholder="Describe el problema..."></textarea></div>
            <button class="btn btn-save" id="btnCreateTicket" type="button">ENVIAR TICKET</button>

            <div style="margin-top: 16px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.08);"></div>
            <h2 style="margin-top: 10px;"> MIS TICKETS</h2>
            <div class="tickets-list" id="ticketsList"></div>

            <div style="margin-top: 16px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.08);"></div>
            <h2 style="margin-top: 10px;"> DETALLE</h2>
            <div class="control-row"><label>ID:</label><input id="tId" type="text" disabled /></div>
            <div class="control-row"><label>Estado:</label><input id="tStatus" type="text" disabled /></div>
            <div class="control-row"><label>Mensajes:</label><div id="tMessages" class="messages" style="flex:2;"></div></div>
            <div class="control-row textarea-row"><label>Responder:</label><textarea id="tReply" placeholder="Añade más información..."></textarea></div>
            <div style="display:flex; gap: 10px; flex-wrap: wrap; margin-top: 10px;">
                <button class="mini-btn primary" id="btnReplyTicket" type="button">Enviar respuesta</button>
                <button class="mini-btn danger" id="btnCloseTicket" type="button">Cerrar ticket</button>
            </div>
        </div>

        <div class="section" id="deviceSection" style="padding: 14px 20px;">
            <h2> DISPOSITIVO</h2>
            <div class="control-row" style="margin-bottom: 0;">
                <label>Seleccionar:</label>
                <select id="deviceSelect" title="Seleccionar dispositivo"></select>
            </div>
            <div style="display:flex; gap: 10px; margin-top: 10px; flex-wrap: wrap;">
                <button class="mini-btn primary" id="btnAddDevice" type="button">+ Añadir dispositivo</button>
                <button class="mini-btn danger" id="btnDeleteDevice" type="button" title="Quitar este dispositivo de tu cuenta">Eliminar dispositivo</button>
                <button class="mini-btn" id="btnAddValve" type="button">+ Añadir válvula</button>
                <button class="mini-btn" id="btnAddSensor" type="button">+ Añadir sensor humedad</button>
            </div>
            <div class="status" style="margin-top: 10px;" id="deviceMeta">--</div>

            <div class="topbar-mini">
                <div class="right">
                    <span class="pill" title="Conexión del dispositivo">
                        <span class="dot unknown" id="topConnDot"></span>
                        <span id="topConnText">--</span>
                    </span>
                    <span class="pill" id="topStatusText">Conectando...</span>
                </div>
            </div>
            <!-- Mantener el ID para compatibilidad (JS lo actualiza si existe), pero oculto -->
            <span class="hidden" id="topNowEs">--</span>
        </div>
        <div class="section" id="connectedSection">
            <h2> DISPOSITIVO CONECTADO</h2>
            <div class="sensor-grid">
                <div class="sensor-card metric-neutral">
                    <div class="sensor-label">Pantalla OLED (tiempo real)</div>
                    <div class="sensor-value" id="sendInterval">--</div>
                    <div class="sensor-unit" id="sendIntervalHint">--</div>
                    <div class="oled-panel" id="oledPanel">--</div>
                </div>
                <div class="sensor-card metric-neutral">
                    <div class="sensor-label">Tiempo encendido</div>
                    <div class="sensor-value small" id="uptime">--</div>
                    <div class="sensor-unit" id="uptimeMeta">--</div>
                </div>
                <div class="sensor-card metric-neutral">
                    <div class="sensor-label">IP</div>
                    <div class="sensor-value small" id="ip">--</div>
                    <div class="sensor-unit">red</div>
                </div>
                <div class="sensor-card metric-neutral">
                    <div class="sensor-label">Memoria libre</div>
                    <div class="sensor-value" id="heap">--</div>
                    <div class="sensor-unit">KB</div>
                </div>
                <div class="sensor-card">
                    <div class="sensor-label">Voltaje</div>
                    <div class="sensor-value" id="voltage">--</div>
                    <div class="sensor-unit">V</div>
                </div>
                <div class="sensor-card">
                    <div class="sensor-label">WiFi</div>
                    <div class="sensor-value" id="rssi">--</div>
                    <div class="sensor-unit" id="wifiMeta">dBm · --</div>
                </div>
                <div class="sensor-card">
                    <div class="sensor-label">Reinicios</div>
                    <div class="sensor-value" id="reboots">--</div>
                    <div class="sensor-unit">#</div>
                    <div style="margin-top: 10px;">
                        <button class="mini-btn danger" id="resetRebootsBtn" type="button">Reset a 0</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="section" id="zonesSection">
            <h2> ZONAS / PLANTAS (1–8)</h2>
            <div class="muted" style="margin-top: -6px; margin-bottom: 10px; font-size:12px; color:#8fa3bf; line-height:1.35;">
                Configura cada planta con su sensor de humedad, su válvula y su umbral.
                Si un sensor/válvula no está enviando datos, la zona se verá “apagada”.
            </div>
            <div id="zonesContainer"></div>
        </div>

        <div class="section">
            <h2> GRÁFICAS EN TIEMPO REAL</h2>
            <div style="display:flex; align-items:center; justify-content:space-between; gap: 12px; flex-wrap: wrap; margin: 4px 0 8px;">
                <div>
                    <div class="sensor-label">FECHA / HORA </div>
                    <div style="font-size: 18px; font-weight: bold; color: #ddd;" id="nowEs">--</div>
                    <div class="conn" title="Conexión del dispositivo">
                        <span class="dot unknown" id="connDot"></span>
                        <span id="connText">--</span>
                    </div>
                </div>
                <div style="display:flex; gap: 10px; align-items:center; flex-wrap: wrap; justify-content:flex-end;">
                    <button class="btn btn-azul" id="btnDia" type="button">DÍA</button>
                    <button class="btn btn-azul" id="btnMes" type="button">MES</button>
                    <button class="btn btn-azul" id="btnAno" type="button">AÑO</button>
                </div>
            </div>

            <div class="channel-cards">
                <div class="channel-card">
                    <div class="channel-title">
                        <div class="sensor-label">Sensor de humedad (gráfica)</div>
                    </div>
                    <select id="humChannelSelect" title="Seleccionar sensor de humedad"></select>
                    <div class="channel-actions">
                        <button class="mini-btn" id="btnRenameHum" type="button">Renombrar</button>
                        <button class="mini-btn danger" id="btnDeleteHum" type="button" title="Eliminar sensores añadidos">Eliminar</button>
                    </div>
                </div>
                <div class="channel-card">
                    <div class="channel-title">
                        <div class="sensor-label">Válvula (gráfica)</div>
                    </div>
                    <select id="valveChannelSelect" title="Seleccionar válvula"></select>
                    <div class="channel-actions">
                        <button class="mini-btn" id="btnRenameValve" type="button">Renombrar</button>
                        <button class="mini-btn danger" id="btnDeleteValve" type="button" title="Eliminar válvulas añadidas">Eliminar</button>
                    </div>
                </div>
            </div>
            <div class="summary">
                <div>
                    <div class="k">Humedad Media</div>
                    <div class="v" id="avgHumidity">--</div>
                </div>
                <div>
                    <div class="k">Último punto</div>
                    <div class="v" id="lastPoint">--</div>
                </div>
                <div>
                    <div class="k">Tiempo Válvula ON</div>
                    <div class="v" id="totalValveOn">--</div>
                </div>
                <!-- Mantener estos IDs para que el JS pueda actualizar el periodo, pero sin mostrarlo en la UI -->
                <div class="hidden">
                    <div class="k" id="periodLabel">Periodo</div>
                    <div class="v" id="periodValue">--</div>
                </div>
            </div>
            <div class="charts-grid">
                <div class="sensor-card chart-box">
                    <div class="sensor-label">Humedad del suelo (%)</div>
                    <div class="chart-wrap">
                        <canvas id="humChart"></canvas>
                    </div>
                </div>
                <div class="sensor-card chart-box">
                    <div class="sensor-label">Válvula (ON/OFF) + tiempo activa</div>
                    <div style="display:flex; justify-content:space-between; align-items:center; gap: 10px; margin: 8px 0 6px;">
                        <div class="valve-indicator" style="margin-top: 0; justify-content:flex-start;">
                            <div class="valve-dot" id="valveDotChart"></div>
                            <div class="valve-text" id="valveTextChart">--</div>
                        </div>
                        <div class="sensor-unit" id="valveOnTime">Tiempo ON: --</div>
                    </div>
                    <div class="chart-wrap">
                        <canvas id="valveChart"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <div class="section">
            <h2> CONFIGURACIÓN AUTOMÁTICA</h2>
            <div class="control-row">
                <label>Color si Humedad BAJA:</label>
                <select id="colorBuena" title="Color si humedad baja">
                    <option value="Rojo">Rojo</option>
                    <option value="Verde">Verde</option>
                    <option value="Azul">Azul</option>
                    <option value="Amarillo">Amarillo</option>
                    <option value="Cian">Cian</option>
                    <option value="Magenta">Magenta</option>
                    <option value="Blanco">Blanco</option>
                </select>
            </div>
            <div class="control-row">
                <label>Color si Humedad BUENA:</label>
                <select id="colorBaja" title="Color si humedad buena">
                    <option value="Rojo">Rojo</option>
                    <option value="Verde" selected>Verde</option>
                    <option value="Azul">Azul</option>
                    <option value="Amarillo">Amarillo</option>
                    <option value="Cian">Cian</option>
                    <option value="Magenta">Magenta</option>
                    <option value="Blanco">Blanco</option>
                </select>
            </div>
            <div class="control-row">
                <label>Calibración WET_V (V):</label>
                <input id="wetV" type="number" step="0.001" placeholder="ej: 1.10" />
            </div>
            <div class="control-row">
                <label>Calibración DRY_V (V):</label>
                <input id="dryV" type="number" step="0.001" placeholder="ej: 2.60" />
            </div>
            <div class="control-row">
                <label>Alerta: Humedad baja (min):</label>
                <input id="alertHumLowMin" type="number" min="0" step="1" placeholder="0 = desactivado" />
            </div>
            <div class="control-row">
                <label>Alerta: Válvula ON máx (min):</label>
                <input id="alertValveMaxMin" type="number" min="0" step="1" placeholder="0 = desactivado" />
            </div>
            <div class="control-row">
                <label>Alerta: Sensor muerto (min):</label>
                <input id="alertDeadMin" type="number" min="0" step="1" placeholder="0 = desactivado" />
            </div>
            <div class="control-row">
                <label>Alerta: Voltaje mín (V):</label>
                <input id="alertVmin" type="number" step="0.01" placeholder="vacío = desactivado" />
            </div>
            <div class="control-row">
                <label>Alerta: Voltaje máx (V):</label>
                <input id="alertVmax" type="number" step="0.01" placeholder="vacío = desactivado" />
            </div>
            <div class="control-row">
                <label>Webhook (URL):</label>
                <input id="notifyWebhook" type="url" placeholder="https://..." />
            </div>
            <div class="control-row">
                <label>Telegram Chat ID:</label>
                <input id="notifyTelegram" type="text" placeholder="123456789" />
            </div>
            <div style="display:flex; gap: 10px; flex-wrap: wrap; margin-top: 10px;">
                <button class="mini-btn" id="btnResetDefaults" type="button">Reset a valores por defecto</button>
                <button class="btn btn-save" id="btnSaveConfig" onclick="guardar()" type="button"> GUARDAR CONFIGURACION</button>
            </div>
        </div>

        <div class="section">
            <h2> ALERTAS</h2>
            <div class="status" id="alertsStatus">--</div>
            <div id="alertsList" style="margin-top: 10px; display:flex; flex-direction:column; gap: 8px;"></div>
        </div>

        <div class="status" id="status">Conectando...</div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script>
        let config = { threshold: 25, colorB: 'Rojo', colorG: 'Verde' };

        const DEFAULT_AUTO_CONFIG = {
            wet_v: 1.10,
            dry_v: 2.60,
            alert_humidity_low_minutes: 0,
            alert_valve_on_max_minutes: 0,
            alert_sensor_dead_minutes: 0,
            alert_voltage_min: null,
            alert_voltage_max: null
        };

        function makeDefaultZones(baseThreshold) {
            const thr = Number(baseThreshold);
            const t = Number.isFinite(thr) ? Math.max(0, Math.min(100, thr)) : 25;
            // Por defecto solo dejamos asignada PLANTA 1 (si existe), el resto SIN ASIGNAR.
            // Así plantas 2..8 aparecen apagadas hasta que haya sensores/válvulas reales.
            return Array.from({ length: 8 }, (_, i) => ({
                zone: i + 1,
                soil_channel_index: i === 0 ? 1 : null,
                valve_channel_index: i === 0 ? 1 : null,
                humidity_low_threshold: t
            }));
        }

        let zonesState = makeDefaultZones(25);

        function normalizeZonesFromServer(raw, baseThreshold) {
            const out = makeDefaultZones(baseThreshold);
            const arr = Array.isArray(raw) ? raw : [];
            for (const z of arr) {
                const zone = Number(z?.zone);
                if (!Number.isInteger(zone) || zone < 1 || zone > 8) continue;
                const idx = zone - 1;

                const soilIdx = z?.soil_channel_index == null ? null : Number(z.soil_channel_index);
                const valveIdx = z?.valve_channel_index == null ? null : Number(z.valve_channel_index);
                const thr = z?.humidity_low_threshold == null ? null : Number(z.humidity_low_threshold);

                out[idx] = {
                    zone,
                    soil_channel_index: Number.isFinite(soilIdx) ? soilIdx : null,
                    valve_channel_index: Number.isFinite(valveIdx) ? valveIdx : null,
                    humidity_low_threshold: Number.isFinite(thr)
                        ? Math.max(0, Math.min(100, thr))
                        : out[idx].humidity_low_threshold
                };
            }
            return out;
        }

        function updateZoneSubtitles() {
            const soil = (channels || []).filter(c => c && c.kind === 'soil_sensor');
            const valves = (channels || []).filter(c => c && c.kind === 'valve');
            const findName = (arr, idx) => {
                const n = Number(idx);
                const c = arr.find(x => Number(x.channel_index) === n);
                return c ? c.name : null;
            };

            for (let i = 0; i < 8; i++) {
                const zoneNum = i + 1;
                const el = document.getElementById(`zoneSubtitle${zoneNum}`);
                if (!el) continue;
                const z = zonesState[i];
                const sName = z.soil_channel_index == null ? null : findName(soil, z.soil_channel_index);
                const vName = z.valve_channel_index == null ? null : findName(valves, z.valve_channel_index);
                const sTxt = z.soil_channel_index == null ? 'Sensor: (sin asignar)' : `Sensor: ${sName || '—'} (${z.soil_channel_index})`;
                const vTxt = z.valve_channel_index == null ? 'Válvula: (sin asignar)' : `Válvula: ${vName || '—'} (${z.valve_channel_index})`;
                el.textContent = `${sTxt} · ${vTxt} · Umbral: ${Math.round(Number(z.humidity_low_threshold ?? 25))}%`;
            }
        }

        function renderZonesUI() {
            const container = document.getElementById('zonesContainer');
            if (!container) return;

            const soil = (channels || [])
                .filter(c => c && c.kind === 'soil_sensor')
                .slice()
                .sort((a, b) => Number(a.channel_index) - Number(b.channel_index));
            const valves = (channels || [])
                .filter(c => c && c.kind === 'valve')
                .slice()
                .sort((a, b) => Number(a.channel_index) - Number(b.channel_index));

            // Importante: NO auto-asignar plantas 2..8.
            // Solo intentamos auto-asignar PLANTA 1 si está sin asignar.
            try {
                const z0 = zonesState?.[0];
                if (z0) {
                    if (z0.soil_channel_index == null && soil.some(x => Number(x.channel_index) === 1)) z0.soil_channel_index = 1;
                    if (z0.valve_channel_index == null && valves.some(x => Number(x.channel_index) === 1)) z0.valve_channel_index = 1;
                }
            } catch {}

            function usedSetFor(kind, excludeIdx) {
                const s = new Set();
                for (let i = 0; i < 8; i++) {
                    if (i === excludeIdx) continue;
                    const z = zonesState[i];
                    if (!z) continue;
                    const v = kind === 'soil' ? z.soil_channel_index : z.valve_channel_index;
                    if (v == null) continue;
                    const n = Number(v);
                    if (Number.isFinite(n)) s.add(n);
                }
                return s;
            }

            function populateSelect(sel, list, currentValue, usedSet, kindLabel) {
                if (!sel) return;
                sel.innerHTML = '';

                const optNone = document.createElement('option');
                optNone.value = '';
                optNone.textContent = '(sin asignar)';
                sel.appendChild(optNone);

                for (const c of list) {
                    const idx = Number(c.channel_index);
                    if (!Number.isFinite(idx)) continue;
                    const opt = document.createElement('option');
                    opt.value = String(idx);
                    const nm = String(c.name || `${kindLabel} ${idx}`);
                    opt.textContent = `${nm} (${idx})`;
                    // No permitir reutilizar el mismo canal en varias plantas
                    if (usedSet.has(idx) && Number(currentValue) !== idx) {
                        opt.disabled = true;
                        opt.textContent = `${nm} (${idx}) — usado en otra planta`;
                    }
                    sel.appendChild(opt);
                }

                sel.value = currentValue == null ? '' : String(currentValue);
            }

            async function saveZoneConfig(zoneNum, btnEl) {
                const i = zoneNum - 1;
                const z = zonesState[i];
                if (!z) return;
                const headersBase = { 'Content-Type': 'application/json' };

                async function doSave(headers, body) {
                    return fetch(`/api/config/${encodeURIComponent(deviceCode)}`, {
                        method: 'POST',
                        headers,
                        credentials: 'include',
                        body: JSON.stringify(body)
                    });
                }

                const saved = (getSavedToken(deviceCode) || '').trim();
                const headers1 = { ...headersBase };
                if (saved) headers1['X-Device-Token'] = saved;

                // Traemos config actual y solo tocamos zones
                const rCfg = await fetch(`/api/config/${encodeURIComponent(deviceCode)}`, { credentials: 'include' });
                if (rCfg.status === 401) return doLogout();
                const cfg = await rCfg.json().catch(() => ({}));
                const baseThr = Number(cfg?.humidity_low_threshold ?? config.threshold ?? 25);
                const zones = normalizeZonesFromServer(cfg?.zones, baseThr);
                zones[i] = {
                    zone: zoneNum,
                    soil_channel_index: z.soil_channel_index == null ? null : Number(z.soil_channel_index),
                    valve_channel_index: z.valve_channel_index == null ? null : Number(z.valve_channel_index),
                    humidity_low_threshold: z.humidity_low_threshold == null ? null : Number(z.humidity_low_threshold)
                };

                const body = {
                    // Compat: muchos firmwares/ OLED solo leen el umbral global.
                    // Si hay umbral por planta, usamos PLANTA 1 como umbral global.
                    humidity_low_threshold: (zones && zones[0] && zones[0].humidity_low_threshold != null)
                        ? Number(zones[0].humidity_low_threshold)
                        : (cfg?.humidity_low_threshold ?? config.threshold),
                    humidity_low_color: cfg?.humidity_low_color ?? config.colorB,
                    humidity_good_color: cfg?.humidity_good_color ?? config.colorG,
                    wet_v: cfg?.wet_v,
                    dry_v: cfg?.dry_v,
                    alert_humidity_low_minutes: cfg?.alert_humidity_low_minutes ?? 0,
                    alert_valve_on_max_minutes: cfg?.alert_valve_on_max_minutes ?? 0,
                    alert_sensor_dead_minutes: cfg?.alert_sensor_dead_minutes ?? 0,
                    alert_voltage_min: (cfg?.alert_voltage_min == null ? null : cfg.alert_voltage_min),
                    alert_voltage_max: (cfg?.alert_voltage_max == null ? null : cfg.alert_voltage_max),
                    notify_webhook_url: (cfg?.notify_webhook_url == null ? null : cfg.notify_webhook_url),
                    notify_telegram_chat_id: (cfg?.notify_telegram_chat_id == null ? null : cfg.notify_telegram_chat_id),
                    zones
                };

                if (btnEl) btnEl.disabled = true;
                const oldText = btnEl ? btnEl.textContent : '';
                if (btnEl) btnEl.textContent = 'Guardando…';

                try {
                    let res = await doSave(headers1, body);
                    if (res.status === 401 || res.status === 403) {
                        const msg = saved
                            ? 'Token guardado inválido o caducado. Pega el token correcto:'
                            : 'Este dispositivo requiere token para guardar. Pégalo aquí:';
                        const t = (prompt(msg) || '').trim();
                        if (t) {
                            saveToken(deviceCode, t);
                            const headers2 = { ...headersBase, 'X-Device-Token': t };
                            res = await doSave(headers2, body);
                        }
                    }
                    if (!res.ok) throw new Error('Error guardando');
                    if (btnEl) btnEl.textContent = 'Guardado';
                    setTimeout(() => {
                        if (btnEl) btnEl.textContent = oldText || 'Guardar';
                    }, 1200);
                } finally {
                    if (btnEl) btnEl.disabled = false;
                }
            }

            container.innerHTML = '';

            for (let i = 0; i < 8; i++) {
                const zoneNum = i + 1;

                const sec = document.createElement('div');
                sec.className = 'section';
                sec.id = `zoneSec${zoneNum}`;

                const h2 = document.createElement('h2');
                h2.textContent = `PLANTA ${zoneNum}`;
                sec.appendChild(h2);

                const subtitle = document.createElement('div');
                subtitle.className = 'zone-subtitle';
                subtitle.id = `zoneSubtitle${zoneNum}`;
                subtitle.textContent = '—';
                sec.appendChild(subtitle);

                const zoneRow = document.createElement('div');
                zoneRow.className = 'zone-row';

                // Selector sensor
                {
                    const row = document.createElement('div');
                    row.className = 'control-row';
                    const label = document.createElement('label');
                    label.textContent = 'Sensor de humedad:';
                    const sel = document.createElement('select');
                    sel.id = `zoneSoilSel${zoneNum}`;
                    sel.title = 'Seleccionar sensor de humedad (canal)';
                    populateSelect(sel, soil, zonesState[i]?.soil_channel_index ?? null, usedSetFor('soil', i), 'Sensor');
                    row.appendChild(label);
                    row.appendChild(sel);
                    zoneRow.appendChild(row);

                    sel.addEventListener('change', () => {
                        const v = sel.value === '' ? null : Number(sel.value);
                        zonesState[i].soil_channel_index = Number.isFinite(v) ? v : null;
                        // Refrescar disables para no reutilizar canales
                        for (let zi = 0; zi < 8; zi++) {
                            const zNum = zi + 1;
                            const sSel = document.getElementById(`zoneSoilSel${zNum}`);
                            populateSelect(sSel, soil, zonesState[zi]?.soil_channel_index ?? null, usedSetFor('soil', zi), 'Sensor');
                        }
                        updateZoneSubtitles();
                        // Apagar visualmente si queda sin asignar
                        const sec = document.getElementById(`zoneSec${zoneNum}`);
                        const anyAssigned = zonesState[i]?.soil_channel_index != null || zonesState[i]?.valve_channel_index != null;
                        if (sec) sec.classList.toggle('zone-off', !anyAssigned);
                    });
                }

                // Selector válvula
                {
                    const row = document.createElement('div');
                    row.className = 'control-row';
                    const label = document.createElement('label');
                    label.textContent = 'Válvula:';
                    const sel = document.createElement('select');
                    sel.id = `zoneValveSel${zoneNum}`;
                    sel.title = 'Seleccionar válvula (canal)';
                    populateSelect(sel, valves, zonesState[i]?.valve_channel_index ?? null, usedSetFor('valve', i), 'Válvula');
                    row.appendChild(label);
                    row.appendChild(sel);
                    zoneRow.appendChild(row);

                    sel.addEventListener('change', () => {
                        const v = sel.value === '' ? null : Number(sel.value);
                        zonesState[i].valve_channel_index = Number.isFinite(v) ? v : null;
                        // Refrescar disables para no reutilizar canales
                        for (let zi = 0; zi < 8; zi++) {
                            const zNum = zi + 1;
                            const vSel = document.getElementById(`zoneValveSel${zNum}`);
                            populateSelect(vSel, valves, zonesState[zi]?.valve_channel_index ?? null, usedSetFor('valve', zi), 'Válvula');
                        }
                        updateZoneSubtitles();
                        const sec = document.getElementById(`zoneSec${zoneNum}`);
                        const anyAssigned = zonesState[i]?.soil_channel_index != null || zonesState[i]?.valve_channel_index != null;
                        if (sec) sec.classList.toggle('zone-off', !anyAssigned);
                    });
                }

                // Umbral por planta
                {
                    const row = document.createElement('div');
                    row.className = 'control-row';
                    const label = document.createElement('label');
                    label.textContent = 'Umbral riego automático:';
                    const wrap = document.createElement('div');
                    wrap.style.display = 'flex';
                    wrap.style.gap = '10px';
                    wrap.style.alignItems = 'center';
                    wrap.style.flex = '2';
                    const rng = document.createElement('input');
                    rng.type = 'range';
                    rng.min = '1';
                    rng.max = '100';
                    rng.id = `zoneThr${zoneNum}`;
                    rng.title = 'Umbral de humedad baja (zona)';
                    const val = document.createElement('span');
                    val.id = `zoneThrVal${zoneNum}`;
                    val.style.width = '50px';
                    val.style.textAlign = 'right';

                    const btn = document.createElement('button');
                    btn.type = 'button';
                    btn.className = 'mini-btn primary tiny';
                    btn.textContent = 'Guardar';
                    btn.title = 'Guardar umbral (y asignación) solo de esta planta';

                    wrap.appendChild(rng);
                    wrap.appendChild(val);
                    wrap.appendChild(btn);
                    row.appendChild(label);
                    row.appendChild(wrap);
                    zoneRow.appendChild(row);

                    rng.addEventListener('input', () => {
                        const n = Number(rng.value);
                        zonesState[i].humidity_low_threshold = Number.isFinite(n) ? Math.max(0, Math.min(100, n)) : zonesState[i].humidity_low_threshold;
                        val.textContent = `${zonesState[i].humidity_low_threshold}%`;
                        updateZoneSubtitles();
                    });

                    btn.addEventListener('click', async () => {
                        await saveZoneConfig(zoneNum, btn);
                    });
                }

                sec.appendChild(zoneRow);

                const grid = document.createElement('div');
                grid.className = 'sensor-grid';

                const humCard = document.createElement('div');
                humCard.className = 'sensor-card metric-neutral';
                humCard.innerHTML = `<div class="sensor-label">Humedad (zona)</div><div class="sensor-value" id="zoneHum${zoneNum}">--</div><div class="sensor-unit">%</div>`;

                const valveCard = document.createElement('div');
                valveCard.className = 'sensor-card metric-neutral';
                valveCard.innerHTML = `<div class="sensor-label">Válvula (zona)</div><div class="sensor-value" id="zoneValve${zoneNum}">--</div><div class="valve-indicator"><div class="valve-dot" id="zoneValveDot${zoneNum}"></div><div class="valve-text" id="zoneValveText${zoneNum}">--</div></div>`;

                const statusCard = document.createElement('div');
                statusCard.className = 'sensor-card metric-neutral';
                statusCard.innerHTML = `<div class="sensor-label">Estado</div><div class="sensor-value" id="zoneState${zoneNum}">--</div><div class="sensor-unit zone-mini" id="zoneAge${zoneNum}"></div>`;

                grid.appendChild(humCard);
                grid.appendChild(valveCard);
                grid.appendChild(statusCard);

                sec.appendChild(grid);
                container.appendChild(sec);
            }

            applyZonesStateToUI();
            initCollapsibles();
            updateZoneSubtitles();

            // Marcar OFF las zonas sin asignar desde el primer render
            for (let i = 0; i < 8; i++) {
                const zoneNum = i + 1;
                const sec = document.getElementById(`zoneSec${zoneNum}`);
                const z = zonesState[i];
                const anyAssigned = z?.soil_channel_index != null || z?.valve_channel_index != null;
                if (sec) sec.classList.toggle('zone-off', !anyAssigned);
            }
        }

        function applyZonesStateToUI() {
            for (let i = 0; i < 8; i++) {
                const zoneNum = i + 1;
                const z = zonesState[i];
                const soilSel = document.getElementById(`zoneSoilSel${zoneNum}`);
                const valveSel = document.getElementById(`zoneValveSel${zoneNum}`);
                const thr = document.getElementById(`zoneThr${zoneNum}`);
                const thrVal = document.getElementById(`zoneThrVal${zoneNum}`);

                if (soilSel) soilSel.value = z.soil_channel_index == null ? '' : String(z.soil_channel_index);
                if (valveSel) valveSel.value = z.valve_channel_index == null ? '' : String(z.valve_channel_index);
                if (thr) thr.value = String(Math.round(Number(z.humidity_low_threshold ?? 25)));
                if (thrVal) thrVal.textContent = `${Math.round(Number(z.humidity_low_threshold ?? 25))}%`;
            }
        }

        function updateZonesFromLatestPayload(payload) {
            lastChannelsLatestPayload = payload || null;
            const ch = Array.isArray(payload?.channels) ? payload.channels : [];
            const byKey = new Map();
            for (const c of ch) {
                const kind = String(c?.kind || '');
                const idx = Number(c?.channel_index);
                if (!kind || !Number.isFinite(idx)) continue;
                byKey.set(`${kind}:${idx}`, c.latest || null);
            }

            const STALE_MIN = 10;

            // Heurística anti-datos-falsos:
            // Si solo hay 1 sensor y 1 válvula con datos recientes, mantenemos solo PLANTA 1 asignada.
            // Esto es local (no guarda nada en servidor).
            try {
                const presentSoil = new Set();
                const presentValve = new Set();
                for (const c of ch) {
                    const kind = String(c?.kind || '');
                    const idx = Number(c?.channel_index);
                    if (!Number.isFinite(idx)) continue;
                    const age = c?.latest?.age_minutes;
                    const okAge = (age == null) || (Number(age) <= STALE_MIN);
                    if (!okAge) continue;
                    if (kind === 'soil_sensor' && c?.latest?.value != null) presentSoil.add(idx);
                    if (kind === 'valve' && c?.latest?.state != null) presentValve.add(idx);
                }
                if (presentSoil.size <= 1 && presentValve.size <= 1) {
                    for (let i = 1; i < 8; i++) {
                        const z = zonesState[i];
                        if (!z) continue;
                        z.soil_channel_index = null;
                        z.valve_channel_index = null;
                    }
                }
            } catch {}

            for (let i = 0; i < 8; i++) {
                const zoneNum = i + 1;
                const z = zonesState[i];
                const sec = document.getElementById(`zoneSec${zoneNum}`);

                const soilIdx = z.soil_channel_index;
                const valveIdx = z.valve_channel_index;
                const soilLatest = soilIdx == null ? null : byKey.get(`soil_sensor:${soilIdx}`);
                const valveLatest = valveIdx == null ? null : byKey.get(`valve:${valveIdx}`);

                const humEl = document.getElementById(`zoneHum${zoneNum}`);
                const valveEl = document.getElementById(`zoneValve${zoneNum}`);
                const dotEl = document.getElementById(`zoneValveDot${zoneNum}`);
                const txtEl = document.getElementById(`zoneValveText${zoneNum}`);
                const stateEl = document.getElementById(`zoneState${zoneNum}`);
                const ageEl = document.getElementById(`zoneAge${zoneNum}`);

                const soilAge = soilLatest?.age_minutes;
                const valveAge = valveLatest?.age_minutes;
                const soilOk = soilLatest && soilLatest.value != null && (soilAge == null || Number(soilAge) <= STALE_MIN);
                const valveOk = valveLatest && valveLatest.state != null && (valveAge == null || Number(valveAge) <= STALE_MIN);

                if (humEl) {
                    const v = soilLatest?.value;
                    const num = v == null ? null : Number(v);
                    humEl.textContent = soilOk && Number.isFinite(num) ? num.toFixed(1) : '--';
                }

                if (valveEl || dotEl || txtEl) {
                    const s = valveLatest?.state;
                    const st = s == null ? null : Number(s);
                    const isOn = valveOk && Number.isFinite(st) && st >= 1;
                    if (valveEl) valveEl.textContent = valveOk ? (isOn ? 'ON' : 'OFF') : '--';
                    if (dotEl) dotEl.className = 'valve-dot' + (valveOk ? (isOn ? ' on' : ' off') : '');
                    if (txtEl) txtEl.textContent = valveOk ? (isOn ? 'ENCENDIDA' : 'APAGADA') : 'SIN DATOS';
                }

                const anyAssigned = (soilIdx != null || valveIdx != null);
                const anyOk = soilOk || valveOk;
                if (stateEl) stateEl.textContent = !anyAssigned ? 'SIN ASIGNAR' : (anyOk ? 'ACTIVA' : 'APAGADA');

                const parts = [];
                if (soilIdx != null) parts.push(`S${soilIdx}:${soilLatest?.age_minutes ?? '--'}m`);
                if (valveIdx != null) parts.push(`V${valveIdx}:${valveLatest?.age_minutes ?? '--'}m`);
                if (ageEl) ageEl.textContent = parts.join(' · ');

                if (sec) sec.classList.toggle('zone-off', !anyAssigned || (anyAssigned && !anyOk));
            }
        }

        let channels = [];
        let humChannelId = null;
        let valveChannelId = null;

        let lastRebootsBase = null;
        let lastSampleMsForInterval = null;

        // --- Cuenta / navegación ---
        const navDevicesBtn = document.getElementById('navDevices');
        const navAccountBtn = document.getElementById('navAccount');
        const navSupportBtn = document.getElementById('navSupport');
            const supportBadge = document.getElementById('supportBadge');
        const navLogoutBtn = document.getElementById('navLogout');

        const accountSection = document.getElementById('accountSection');
        const accountStatus = document.getElementById('accountStatus');
        const accEmail = document.getElementById('accEmail');
        const accFullName = document.getElementById('accFullName');
        const accPhone = document.getElementById('accPhone');
        const accAddress = document.getElementById('accAddress');
        const accProvince = document.getElementById('accProvince');
        const accCity = document.getElementById('accCity');
        const accCountry = document.getElementById('accCountry');
        const btnSaveProfile = document.getElementById('btnSaveProfile');
        const btnDeleteAccount = document.getElementById('btnDeleteAccount');

        const supportSection = document.getElementById('supportSection');
        const supportStatus = document.getElementById('supportStatus');
        const tSubject = document.getElementById('tSubject');
        const tDevice = document.getElementById('tDevice');
        const tMessage = document.getElementById('tMessage');
        const btnCreateTicket = document.getElementById('btnCreateTicket');
        const ticketsList = document.getElementById('ticketsList');
        const tId = document.getElementById('tId');
        const tStatus = document.getElementById('tStatus');
        const tMessages = document.getElementById('tMessages');
        const tReply = document.getElementById('tReply');
        const btnReplyTicket = document.getElementById('btnReplyTicket');
        const btnCloseTicket = document.getElementById('btnCloseTicket');

        let selectedTicketId = null;

        function setAccountStatus(text, isErr = false) {
            if (!accountStatus) return;
            accountStatus.textContent = text || '—';
            accountStatus.className = 'status' + (isErr ? ' offline' : ' online');
        }

        function setView(view) {
            const isAccount = view === 'account';
            const isSupport = view === 'support';
            document.body.classList.toggle('mode-account', isAccount);
            document.body.classList.toggle('mode-support', isSupport);
            accountSection?.classList.toggle('hidden', !isAccount);
            supportSection?.classList.toggle('hidden', !isSupport);
            navDevicesBtn?.classList.toggle('active', !isAccount && !isSupport);
            navAccountBtn?.classList.toggle('active', isAccount);
            navSupportBtn?.classList.toggle('active', isSupport);
        }

        function setSupportStatus(text, isErr = false) {
            if (!supportStatus) return;
            supportStatus.textContent = text || '—';
            supportStatus.className = 'status' + (isErr ? ' offline' : ' online');
        }

        async function supportApi(path, opts = {}) {
            const r = await fetch(path, Object.assign({}, opts, { credentials: 'include' }));
            if (r.status === 401) return doLogout();
            const text = await r.text();
            let j = null;
            try { j = text ? JSON.parse(text) : null; } catch { j = { raw: text }; }
            if (!r.ok) throw new Error((j && j.error) ? j.error : `HTTP ${r.status}`);
            return j;
        }

            function setSupportBadge(n) {
                if (!supportBadge) return;
                const count = Math.max(0, Number(n) || 0);
                supportBadge.textContent = String(count);
                supportBadge.classList.toggle('hidden', count <= 0);
                // Si hay no leídos, resaltamos el botón
                navSupportBtn?.classList.toggle('primary', count > 0);
            }

            async function refreshSupportBadge() {
                try {
                    const j = await supportApi('/api/tickets/unread-count');
                    setSupportBadge(j.unread_count || 0);
                } catch {
                    // silencioso
                }
            }

        function safeText(el, text) {
            if (!el) return;
            el.textContent = text == null ? '' : String(text);
        }

        function renderTicketMessages(messages) {
            if (!tMessages) return;
            const rows = Array.isArray(messages) ? messages : [];
            if (!rows.length) {
                tMessages.innerHTML = '<div class="muted">Sin mensajes</div>';
                return;
            }
            tMessages.innerHTML = '';
            for (const m of rows) {
                const wrap = document.createElement('div');
                wrap.className = 'msg';
                const meta = document.createElement('div');
                meta.className = 'msg-meta';
                meta.textContent = `${m.author_type === 'admin' ? 'Soporte' : 'Tú'} · ${m.created_at_madrid || m.created_at || ''}`;
                const body = document.createElement('div');
                body.className = 'msg-body';
                body.textContent = String(m.body || '');
                wrap.appendChild(meta);
                wrap.appendChild(body);
                tMessages.appendChild(wrap);
            }
            tMessages.scrollTop = tMessages.scrollHeight;
        }

        function renderTicketsList(tickets) {
            if (!ticketsList) return;
            const rows = Array.isArray(tickets) ? tickets : [];
            ticketsList.innerHTML = '';
            if (!rows.length) {
                const empty = document.createElement('div');
                empty.className = 'muted';
                empty.textContent = 'No tienes tickets todavía.';
                ticketsList.appendChild(empty);
                return;
            }
            for (const t of rows) {
                const item = document.createElement('div');
                item.className = 'ticket-item';
                    if (t.has_unread) item.style.borderColor = 'rgba(239,68,68,0.55)';
                const title = document.createElement('div');
                title.className = 'ticket-title';
                title.textContent = t.subject || '(sin asunto)';
                const meta = document.createElement('div');
                meta.className = 'ticket-meta';
                meta.textContent = `${t.status || ''} · ${t.priority || ''}${t.device_code ? ' · ' + t.device_code : ''}`;
                item.appendChild(title);
                item.appendChild(meta);
                item.addEventListener('click', async () => {
                    await selectTicket(t.id);
                });
                ticketsList.appendChild(item);
            }
        }

        async function loadTickets() {
            try {
                setSupportStatus('Cargando tickets...', false);
                const j = await supportApi('/api/tickets');
                renderTicketsList(j.tickets || []);
                if (selectedTicketId) await selectTicket(selectedTicketId, true);
                    await refreshSupportBadge();
                setSupportStatus('Listo.', false);
            } catch (e) {
                setSupportStatus(e.message || 'Error cargando tickets', true);
            }
        }

        async function selectTicket(id, silent = false) {
            const tid = String(id || '').trim();
            if (!tid) return;
            selectedTicketId = tid;
            try {
                if (!silent) setSupportStatus('Cargando ticket...', false);
                const j = await supportApi(`/api/tickets/${encodeURIComponent(tid)}`);
                safeText(tId, j.ticket?.id || tid);
                safeText(tStatus, j.ticket?.status || '');
                renderTicketMessages(j.messages || []);
                    try { await supportApi(`/api/tickets/${encodeURIComponent(tid)}/mark-read`, { method: 'POST' }); } catch {}
                    await refreshSupportBadge();
                if (!silent) setSupportStatus('Ticket cargado.', false);
            } catch (e) {
                if (!silent) setSupportStatus(e.message || 'Error', true);
            }
        }

        async function populateTicketDeviceSelect() {
            if (!tDevice) return;
            const select = document.getElementById('deviceSelect');
            // Mantener opción "sin dispositivo"
            const keep = [{ value: '', text: '(sin dispositivo)' }];
            const opts = select ? Array.from(select.options || []).map(o => ({ value: o.value, text: o.textContent })) : [];
            const all = keep.concat(opts.filter(o => o.value));
            tDevice.innerHTML = '';
            for (const o of all) {
                const opt = document.createElement('option');
                opt.value = o.value;
                opt.textContent = o.text;
                tDevice.appendChild(opt);
            }
        }

        async function createTicket() {
            try {
                setSupportStatus('Enviando ticket...', false);
                const payload = {
                    subject: String(tSubject.value || '').trim(),
                    device_code: String(tDevice.value || '').trim() || null,
                    message: String(tMessage.value || '').trim()
                };
                if (!payload.subject || payload.subject.length < 3) throw new Error('Asunto demasiado corto');
                if (!payload.message || payload.message.length < 3) throw new Error('Mensaje demasiado corto');

                const j = await supportApi('/api/tickets', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                tSubject.value = '';
                tMessage.value = '';
                selectedTicketId = j.ticket_id || null;
                await loadTickets();
                if (selectedTicketId) await selectTicket(selectedTicketId, true);
                setSupportStatus('Ticket creado.', false);
            } catch (e) {
                setSupportStatus(e.message || 'Error creando ticket', true);
            }
        }

        async function replyToTicket() {
            if (!selectedTicketId) return setSupportStatus('Selecciona un ticket.', true);
            const body = String(tReply.value || '').trim();
            if (!body) return setSupportStatus('Escribe un mensaje.', true);
            try {
                setSupportStatus('Enviando respuesta...', false);
                await supportApi(`/api/tickets/${encodeURIComponent(selectedTicketId)}/messages`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ body })
                });
                tReply.value = '';
                await selectTicket(selectedTicketId, true);
                await loadTickets();
                setSupportStatus('Enviado.', false);
            } catch (e) {
                setSupportStatus(e.message || 'Error', true);
            }
        }

        async function closeTicket() {
            if (!selectedTicketId) return setSupportStatus('Selecciona un ticket.', true);
            const ok = confirm('¿Seguro que quieres cerrar este ticket?');
            if (!ok) return;
            try {
                setSupportStatus('Cerrando...', false);
                await supportApi(`/api/tickets/${encodeURIComponent(selectedTicketId)}/close`, { method: 'POST' });
                await selectTicket(selectedTicketId, true);
                await loadTickets();
                setSupportStatus('Ticket cerrado.', false);
            } catch (e) {
                setSupportStatus(e.message || 'Error', true);
            }
        }

        async function doLogout() {
            try { await fetch('/api/auth/logout', { method: 'POST', credentials: 'include' }); } catch {}
            const next = encodeURIComponent(location.pathname + location.search + location.hash);
            window.location.href = `/login?next=${next}`;
        }

        async function loadProfileIntoForm() {
            try {
                setAccountStatus('Cargando...', false);
                const r = await fetch('/api/me/profile', { credentials: 'include' });
                if (r.status === 401) return doLogout();
                const p = await r.json().catch(() => ({}));
                accEmail.value = p.email || '';
                accFullName.value = p.full_name || '';
                accPhone.value = p.phone || '';
                accAddress.value = p.address || '';
                accProvince.value = p.province || '';
                accCity.value = p.city || '';
                accCountry.value = p.country || '';
                setAccountStatus('Listo.', false);
            } catch {
                setAccountStatus('No se pudo cargar tu perfil.', true);
            }
        }

        async function saveProfileFromForm() {
            try {
                setAccountStatus('Guardando...', false);
                const payload = {
                    full_name: String(accFullName.value || '').trim() || undefined,
                    phone: String(accPhone.value || '').trim() || null,
                    address: String(accAddress.value || '').trim() || null,
                    province: String(accProvince.value || '').trim() || null,
                    city: String(accCity.value || '').trim() || null,
                    country: String(accCountry.value || '').trim() || null
                };
                const r = await fetch('/api/me/profile', {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify(payload)
                });
                if (r.status === 401) return doLogout();
                const j = await r.json().catch(() => ({}));
                if (!r.ok) throw new Error(j.error || 'No se pudo guardar');
                setAccountStatus('Guardado.', false);
            } catch (e) {
                setAccountStatus(e.message || 'Error guardando.', true);
            }
        }

        async function deleteAccount() {
            const ok = confirm('¿Seguro que quieres eliminar tu cuenta? Esta acción no se puede deshacer.');
            if (!ok) return;
            try {
                setAccountStatus('Eliminando cuenta...', false);
                const r = await fetch('/api/me', { method: 'DELETE', credentials: 'include' });
                const j = await r.json().catch(() => ({}));
                if (!r.ok) throw new Error(j.error || 'No se pudo eliminar');
                window.location.href = '/login';
            } catch (e) {
                setAccountStatus(e.message || 'Error eliminando.', true);
            }
        }

        navDevicesBtn?.addEventListener('click', () => setView('devices'));
        navAccountBtn?.addEventListener('click', async () => {
            setView('account');
            await loadProfileIntoForm();
        });
        navSupportBtn?.addEventListener('click', async () => {
            setView('support');
            try {
                await loadDevices();
                await populateTicketDeviceSelect();
            } catch {}
            await loadTickets();
        });
        navLogoutBtn?.addEventListener('click', doLogout);
        btnSaveProfile?.addEventListener('click', saveProfileFromForm);
        btnDeleteAccount?.addEventListener('click', deleteAccount);
        btnCreateTicket?.addEventListener('click', createTicket);
        btnReplyTicket?.addEventListener('click', replyToTicket);
        btnCloseTicket?.addEventListener('click', closeTicket);

            // Polling ligero: badge de tickets no leídos
            setTimeout(() => { refreshSupportBadge(); }, 800);
            setInterval(() => { refreshSupportBadge(); }, 15000);

        function rebootsOffsetKey(code) { return `rebootsOffset:${code}`; }
        function getLocalRebootsOffset(code) {
            try {
                const v = localStorage.getItem(rebootsOffsetKey(code));
                if (v == null || v === '') return 0;
                const n = Number(v);
                return Number.isFinite(n) && n >= 0 ? n : 0;
            } catch { return 0; }
        }
        function setLocalRebootsOffset(code, offset) {
            try { localStorage.setItem(rebootsOffsetKey(code), String(Math.max(0, Number(offset) || 0))); } catch {}
        }

        let chartsRebuildTimer = null;
        function scheduleChartsRebuild() {
            if (chartsRebuildTimer) return;
            chartsRebuildTimer = setTimeout(() => {
                chartsRebuildTimer = null;
                rebuildCharts();
            }, 1200);
        }

        const DEFAULT_DEVICE = 'RIEGO_001';
        let deviceCode = (() => {
            const m = location.pathname.match(/\/panel\/([^\/?#]+)/);
            return m ? decodeURIComponent(m[1]) : DEFAULT_DEVICE;
        })();

        let hasDevices = true;

        function tokenStorageKey(code) { return `deviceToken:${code}`; }
        function getSavedToken(code) {
            try { return localStorage.getItem(tokenStorageKey(code)) || ''; } catch { return ''; }
        }
        function saveToken(code, token) {
            try { localStorage.setItem(tokenStorageKey(code), token || ''); } catch {}
        }

        function consumeTokenFromUrl() {
            try {
                const params = new URLSearchParams(location.search);
                const t = (params.get('token') || params.get('t') || '').trim();
                if (!t) return;
                saveToken(deviceCode, t);
                params.delete('token');
                params.delete('t');
                const qs = params.toString();
                const next = location.pathname + (qs ? `?${qs}` : '') + location.hash;
                history.replaceState({}, '', next);
            } catch {}
        }

        consumeTokenFromUrl();

        async function loadDevices() {
            const section = document.getElementById('deviceSection');
            const select = document.getElementById('deviceSelect');
            const meta = document.getElementById('deviceMeta');
            try {
                const r = await fetch('/api/devices', { credentials: 'include' });
                if (r.status === 401) {
                    const next = encodeURIComponent(location.pathname + location.search + location.hash);
                    window.location.href = `/login?next=${next}`;
                    return false;
                }
                const list = await r.json();

                if (!Array.isArray(list)) throw new Error('Sin lista');
                if (list.length === 0) {
                    hasDevices = false;
                    select.innerHTML = '';
                    meta.textContent = 'No hay dispositivos asignados a tu cuenta. Pulsa “+ Añadir dispositivo”.';
                    return true;
                }
                hasDevices = true;

                select.innerHTML = '';
                for (const d of list) {
                    const opt = document.createElement('option');
                    opt.value = d.device_code;
                    opt.textContent = `${d.device_code} — ${d.name || ''}`.trim();
                    select.appendChild(opt);
                }

                const exists = list.some(d => d.device_code === deviceCode);
                if (!exists) {
                    deviceCode = list[0].device_code;
                    history.replaceState({}, '', `/panel/${encodeURIComponent(deviceCode)}`);
                }
                select.value = deviceCode;

                const current = list.find(d => d.device_code === deviceCode);
                const lastSeen = current?.last_seen_madrid || (current?.last_seen ? new Date(current.last_seen).toLocaleString('es-ES', { timeZone: TZ, hour12: false }) : '--');
                const lastSeenDate = current?.last_seen ? parseTsToDate(current.last_seen) : null;
                const ageMin = lastSeenDate ? Math.max(0, Math.round((nowAdjusted().getTime() - lastSeenDate.getTime()) / 60000)) : null;
                const ageText = ageMin == null ? '' : ` (hace ${ageMin} min)`;
                meta.textContent = `${current?.name || deviceCode}${current?.location ? ' · ' + current.location : ''} · Último dato: ${lastSeen}${ageText}`;

                select.addEventListener('change', () => {
                    const next = select.value;
                    if (next && next !== deviceCode) window.location.href = `/panel/${encodeURIComponent(next)}`;
                });

            } catch {
                if (section) section.style.display = 'none';
                return false;
            }

            return true;
        }

        async function loadChannels() {
            try {
                const r = await fetch(`/api/channels/${encodeURIComponent(deviceCode)}`);
                if (!r.ok) throw new Error('channels failed');
                const j = await r.json();
                channels = Array.isArray(j.channels) ? j.channels : [];

                const hums = channels.filter(c => c.kind === 'soil_sensor');
                const valves = channels.filter(c => c.kind === 'valve');

                const humSel = document.getElementById('humChannelSelect');
                const valveSel = document.getElementById('valveChannelSelect');
                humSel.innerHTML = '';
                valveSel.innerHTML = '';

                for (const c of hums) {
                    const opt = document.createElement('option');
                    opt.value = c.id;
                    opt.textContent = `${c.name} (${c.channel_index})`;
                    humSel.appendChild(opt);
                }
                for (const c of valves) {
                    const opt = document.createElement('option');
                    opt.value = c.id;
                    opt.textContent = `${c.name} (${c.channel_index})`;
                    valveSel.appendChild(opt);
                }

                if (!humChannelId || !hums.some(c => c.id === humChannelId)) humChannelId = hums[0]?.id || null;
                if (!valveChannelId || !valves.some(c => c.id === valveChannelId)) valveChannelId = valves[0]?.id || null;

                humSel.value = humChannelId || '';
                valveSel.value = valveChannelId || '';

                humSel.onchange = () => { humChannelId = humSel.value || null; scheduleChartsRebuild(); };
                valveSel.onchange = () => { valveChannelId = valveSel.value || null; scheduleChartsRebuild(); };

                const renameHumBtn = document.getElementById('btnRenameHum');
                const renameValveBtn = document.getElementById('btnRenameValve');
                if (renameHumBtn) renameHumBtn.disabled = hums.length === 0;
                if (renameValveBtn) renameValveBtn.disabled = valves.length === 0;

                // Si no hay canales, ocultar gráficas (pero normalmente habrá canal 1 por defecto)
                document.getElementById('humChannelSelect').disabled = hums.length === 0;
                document.getElementById('valveChannelSelect').disabled = valves.length === 0;

                // Re-render zonas para actualizar selects/labels
                renderZonesUI();

            } catch (e) {
                // Si falla, no rompemos
            }
        }

        // --- Zona horaria España (Europe/Madrid) ---
        const TZ = 'Europe/Madrid';
        const fmtNowEs = new Intl.DateTimeFormat('es-ES', {
            timeZone: TZ,
            year: 'numeric', month: '2-digit', day: '2-digit',
            hour: '2-digit', minute: '2-digit', second: '2-digit',
            hour12: false
        });
        const fmtDateEs = new Intl.DateTimeFormat('es-ES', {
            timeZone: TZ,
            year: 'numeric', month: '2-digit', day: '2-digit'
        });

        // Si el reloj del PC está mal, ajustamos con la hora del servidor.
        let serverClockOffsetMs = null; // server_now_ms - Date.now()
        function nowAdjusted() {
            return new Date(Date.now() + (serverClockOffsetMs == null ? 0 : serverClockOffsetMs));
        }

        function setConnectionUI(status) {
            const s = (status || 'unknown').toString().toLowerCase();
            const pairs = [
                { dot: document.getElementById('connDot'), text: document.getElementById('connText') },
                { dot: document.getElementById('topConnDot'), text: document.getElementById('topConnText') }
            ].filter(p => p.dot && p.text);
            if (!pairs.length) return;

            for (const { dot, text } of pairs) {
                dot.classList.remove('online', 'offline', 'unknown');
                if (s === 'online') {
                    dot.classList.add('online');
                    text.textContent = 'Online';
                } else if (s === 'offline') {
                    dot.classList.add('offline');
                    text.textContent = 'Offline';
                } else {
                    dot.classList.add('unknown');
                    text.textContent = '--';
                }
            }

            if (s === 'online') {
            } else if (s === 'offline') {
            } else {
            }
        }

        // Cache del último payload de /api/channels/:device_code/latest
        let lastChannelsLatestPayload = null;

        function setStatusText(text) {
            const st = document.getElementById('status');
            const top = document.getElementById('topStatusText');
            if (st) st.textContent = text;
            if (top) top.textContent = text;
        }

        function setStatusClass(isOnline) {
            const st = document.getElementById('status');
            if (!st) return;
            st.className = isOnline ? 'status online' : 'status offline';
        }

        async function withBusy(btn, busyText, fn) {
            if (!btn) return fn();
            const prevText = btn.textContent;
            const prevDisabled = btn.disabled;
            btn.disabled = true;
            if (busyText) btn.textContent = busyText;
            try { return await fn(); }
            finally {
                btn.disabled = prevDisabled;
                btn.textContent = prevText;
            }
        }

        function initCollapsibles() {
            const sections = Array.from(document.querySelectorAll('.section'));
            for (const sec of sections) {
                if (sec.id === 'deviceSection') continue;
                if (sec.dataset.collapsibleInit === '1') continue;

                const h2 = sec.querySelector('h2');
                if (!h2) continue;

                const head = document.createElement('div');
                head.className = 'section-head';

                const body = document.createElement('div');
                body.className = 'section-body';

                const title = (h2.textContent || '').trim() || 'section';
                const key = `ui:collapsed:${title}`;

                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = 'collapse-btn';
                const applyState = (collapsed) => {
                    sec.classList.toggle('collapsed', !!collapsed);
                    btn.textContent = collapsed ? 'Mostrar' : 'Ocultar';
                    try { localStorage.setItem(key, collapsed ? '1' : '0'); } catch {}
                };

                const stored = (() => {
                    try { return localStorage.getItem(key); } catch { return null; }
                })();
                const initialCollapsed = stored === '1';
                applyState(initialCollapsed);

                btn.addEventListener('click', () => applyState(!sec.classList.contains('collapsed')));

                // Reestructurar DOM: h2 + botón en head; el resto dentro de body
                head.appendChild(h2);
                head.appendChild(btn);

                const toMove = [];
                for (const child of Array.from(sec.childNodes)) {
                    if (child === h2) continue;
                    if (child.nodeType === 3 && String(child.textContent || '').trim() === '') continue;
                    toMove.push(child);
                }
                for (const n of toMove) body.appendChild(n);

                sec.appendChild(head);
                sec.appendChild(body);
                sec.dataset.collapsibleInit = '1';
            }
        }

        function getMadridParts(date) {
            const parts = new Intl.DateTimeFormat('sv-SE', {
                timeZone: TZ,
                year: 'numeric', month: '2-digit', day: '2-digit',
                hour: '2-digit', minute: '2-digit',
                hourCycle: 'h23'
            }).formatToParts(date);
            const m = Object.fromEntries(parts.map(p => [p.type, p.value]));
            return { y: m.year, mo: m.month, d: m.day, h: m.hour, mi: m.minute };
        }

        function getMadridPartsFull(date) {
            const parts = new Intl.DateTimeFormat('sv-SE', {
                timeZone: TZ,
                year: 'numeric', month: '2-digit', day: '2-digit',
                hour: '2-digit', minute: '2-digit', second: '2-digit',
                hourCycle: 'h23'
            }).formatToParts(date);
            const m = Object.fromEntries(parts.map(p => [p.type, p.value]));
            return { y: m.year, mo: m.month, d: m.day, h: m.hour, mi: m.minute, s: m.second };
        }

        function parseTsToDate(ts) {
            if (ts == null) return null;
            if (ts instanceof Date) return ts;
            if (typeof ts === 'number') {
                // Heurística: si viene en segundos (muy pequeño), convertir a ms
                const ms = ts < 1e12 ? ts * 1000 : ts;
                const d = new Date(ms);
                return Number.isNaN(d.getTime()) ? null : d;
            }
            const d = new Date(String(ts));
            return Number.isNaN(d.getTime()) ? null : d;
        }
        function pad2(n) { return String(n).padStart(2, '0'); }
        function formatUptimeSeconds(sec) {
            const n = Number(sec);
            if (!Number.isFinite(n) || n < 0) return '--';
            return formatDuration(n * 1000);
        }
        function formatDuration(ms) {
            const s = Math.floor(ms / 1000);
            const hh = Math.floor(s / 3600);
            const mm = Math.floor((s % 3600) / 60);
            const ss = s % 60;
            if (hh > 0) return `${hh}h ${pad2(mm)}m ${pad2(ss)}s`;
            if (mm > 0) return `${mm}m ${pad2(ss)}s`;
            return `${ss}s`;
        }

        function formatIntervalSeconds(sec) {
            const n = Number(sec);
            if (!Number.isFinite(n) || n <= 0) return '--';
            // Mostrar compacto: segundos si < 90s, si no duración
            if (n < 90) return `${Math.round(n)}s`;
            return formatDuration(n * 1000);
        }

        function setMetricStateById(valueId, state, title) {
            const valueEl = document.getElementById(valueId);
            const card = valueEl ? valueEl.closest('.sensor-card') : null;
            if (!card) return;
            card.classList.remove('metric-good', 'metric-warn', 'metric-bad', 'metric-neutral');
            card.classList.add(state);
            if (title) card.title = title;
        }

        function updateThresholdCard() {
            const el = document.getElementById('uptime');
            if (!el) return;
            const t = Number(config.threshold);
            el.textContent = Number.isFinite(t) ? String(Math.round(t)) : '--';
            // Colorear el valor del umbral para que destaque
            // (bajo = verde, medio = amarillo, alto = rojo)
            if (!Number.isFinite(t)) {
                setMetricStateById('uptime', 'metric-neutral', 'Umbral de humedad baja configurado');
            } else if (t <= 30) {
                setMetricStateById('uptime', 'metric-good', 'Umbral bajo');
            } else if (t <= 50) {
                setMetricStateById('uptime', 'metric-warn', 'Umbral medio');
            } else {
                setMetricStateById('uptime', 'metric-bad', 'Umbral alto');
            }
        }

        function updateConnectedDeviceCards(data) {
            const createdAt = parseTsToDate(data?.created_at);
            const createdAtLabel = (data && data.created_at_madrid)
                ? String(data.created_at_madrid)
                : (createdAt ? createdAt.toLocaleString('es-ES', { timeZone: TZ, hour12: false }) : '--');

            // Intervalo de envío (delta entre esta lectura y la anterior)
            const sendIntervalEl = document.getElementById('sendInterval');
            const sendIntervalHintEl = document.getElementById('sendIntervalHint');
            const createdMs = createdAt ? createdAt.getTime() : null;
            let deltaSec = null;
            if (createdMs != null && lastSampleMsForInterval != null) {
                const d = (createdMs - lastSampleMsForInterval) / 1000;
                // Ignorar valores raros (p.ej. reloj cambiado / lecturas duplicadas)
                if (Number.isFinite(d) && d > 0.5 && d < 3600) deltaSec = d;
            }
            if (createdMs != null) lastSampleMsForInterval = createdMs;
            if (sendIntervalEl) sendIntervalEl.textContent = deltaSec == null ? '--' : formatIntervalSeconds(deltaSec);
            if (sendIntervalHintEl) {
                const nowTxt = fmtNowEs.format(nowAdjusted());
                const lastTxt = createdAtLabel === '--' ? '--' : createdAtLabel;
                sendIntervalHintEl.textContent = `intervalo: ${deltaSec == null ? '--' : formatIntervalSeconds(deltaSec)} · último: ${lastTxt} · ahora: ${nowTxt}`;
            }

            const uptimeEl = document.getElementById('uptime');
            if (uptimeEl) uptimeEl.textContent = formatUptimeSeconds(data?.uptime_s);

            // Sensores/válvulas activos (dato reciente) según /api/channels/:device_code/latest
            try {
                const ch = Array.isArray(lastChannelsLatestPayload?.channels) ? lastChannelsLatestPayload.channels : [];
                const STALE_MIN = 10;
                let soilTotal = 0;
                let valveTotal = 0;
                let soilActive = 0;
                let valveActive = 0;
                for (const c of ch) {
                    const kind = String(c?.kind || '');
                    const age = c?.latest?.age_minutes;
                    const okAge = (age == null) || (Number(age) <= STALE_MIN);
                    if (kind === 'soil_sensor') {
                        soilTotal++;
                        if (okAge && c?.latest?.value != null) soilActive++;
                    }
                    if (kind === 'valve') {
                        valveTotal++;
                        if (okAge && c?.latest?.state != null) valveActive++;
                    }
                }
                const uptimeMeta = document.getElementById('uptimeMeta');
                if (uptimeMeta) uptimeMeta.textContent = `Sensores: ${soilActive}/${soilTotal} · Válvulas: ${valveActive}/${valveTotal}`;
            } catch {
                const uptimeMeta = document.getElementById('uptimeMeta');
                if (uptimeMeta) uptimeMeta.textContent = '--';
            }

            const ipEl = document.getElementById('ip');
            if (ipEl) {
                const ip = (data && data.ip != null) ? String(data.ip).trim() : '';
                ipEl.textContent = ip || '--';
            }

            const heapEl = document.getElementById('heap');
            if (heapEl) {
                const hb = (data?.heap_free == null ? null : Number(data.heap_free));
                const kb = (hb == null || Number.isNaN(hb)) ? null : Math.max(0, Math.round(hb / 1024));
                heapEl.textContent = kb == null ? '--' : String(kb);
            }

            // WiFi: SSID + RSSI
            {
                const ssidRaw = (data && (data.wifi_ssid != null ? data.wifi_ssid : (data.ssid != null ? data.ssid : null)));
                const ssid = ssidRaw == null ? '' : String(ssidRaw).trim();
                const rssi = (data?.wifi_rssi == null ? null : Number(data.wifi_rssi));
                const rssiOk = !(rssi == null || Number.isNaN(rssi) || rssi === 0);
                const wifiMeta = document.getElementById('wifiMeta');
                if (wifiMeta) {
                    const rssiTxt = rssiOk ? `${Math.trunc(rssi)} dBm` : '-- dBm';
                    wifiMeta.textContent = `${rssiTxt} · ${ssid ? ssid : '--'}`;
                }
            }

            // Pantalla OLED (aprox: como OLED para PLANTA 1)
            try {
                const panel = document.getElementById('oledPanel');
                if (panel) {
                    const z0 = zonesState && zonesState[0] ? zonesState[0] : null;
                    const soilIdx = (z0 && z0.soil_channel_index != null) ? Number(z0.soil_channel_index) : 1;
                    const valveIdx = (z0 && z0.valve_channel_index != null) ? Number(z0.valve_channel_index) : 1;
                    const thr = (z0 && z0.humidity_low_threshold != null) ? Number(z0.humidity_low_threshold) : null;

                    const ch = Array.isArray(lastChannelsLatestPayload?.channels) ? lastChannelsLatestPayload.channels : [];
                    const byKey = new Map();
                    for (const c of ch) {
                        const kind = String(c?.kind || '');
                        const idx = Number(c?.channel_index);
                        if (!kind || !Number.isFinite(idx)) continue;
                        byKey.set(`${kind}:${idx}`, c?.latest || null);
                    }

                    const soilLatest = byKey.get(`soil_sensor:${soilIdx}`) || null;
                    const valveLatest = byKey.get(`valve:${valveIdx}`) || null;

                    const hum = soilLatest?.value == null ? null : Number(soilLatest.value);
                    const humTxt = Number.isFinite(hum) ? `${hum.toFixed(1)}%` : '--%';
                    const thrTxt = Number.isFinite(thr) ? `${Math.round(thr)}%` : '--%';

                    const st = valveLatest?.state == null ? null : Number(valveLatest.state);
                    const valveTxt = (st == null || Number.isNaN(st)) ? '--' : (st >= 1 ? 'ON' : 'OFF');

                    const v = (data?.voltage == null ? null : Number(data.voltage));
                    const vTxt = (v == null || Number.isNaN(v)) ? '--.-V' : `${v.toFixed(2)}V`;
                    const rssi = (data?.wifi_rssi == null ? null : Number(data.wifi_rssi));
                    const rssiTxt = (rssi == null || Number.isNaN(rssi) || rssi === 0) ? '--dBm' : `${Math.trunc(rssi)}dBm`;

                    const now = nowAdjusted();
                    const p = getMadridPartsFull(now);
                    const timeTxt = `${p.h}:${p.mi}:${p.s}`;
                    const ip = (data && data.ip != null) ? String(data.ip).trim() : '';

                    panel.textContent =
                        `OLED ${timeTxt}\n` +
                        `PL1 HUM ${humTxt}  THR ${thrTxt}\n` +
                        `VAL ${valveTxt}   V ${vTxt}\n` +
                        `WiFi ${rssiTxt}${ip ? `  IP ${ip}` : ''}`;
                }
            } catch {
                const panel = document.getElementById('oledPanel');
                if (panel) panel.textContent = '--';
            }
        }

        // --- Persistencia ("datos que va recibiendo") ---
        const STORE_KEY = 'riego_stats_v1';
        function loadStore() {
            try {
                const raw = localStorage.getItem(STORE_KEY);
                if (!raw) return { minutes: {}, days: {}, months: {}, last: null };
                const obj = JSON.parse(raw);
                return {
                    minutes: obj.minutes || {},
                    days: obj.days || {},
                    months: obj.months || {},
                    last: obj.last || null
                };
            } catch {
                return { minutes: {}, days: {}, months: {}, last: null };
            }
        }
        function saveStore(store) {
            localStorage.setItem(STORE_KEY, JSON.stringify(store));
        }
        function ensureBucket(map, key) {
            if (!map[key]) map[key] = { humSum: 0, humCount: 0, valveOnMs: 0 };
            return map[key];
        }
        function pruneStore(store) {
            const dayKeys = Object.keys(store.days).sort();
            if (dayKeys.length > 370) {
                for (let i = 0; i < dayKeys.length - 370; i++) delete store.days[dayKeys[i]];
            }
            const monthKeys = Object.keys(store.months).sort();
            if (monthKeys.length > 36) {
                for (let i = 0; i < monthKeys.length - 36; i++) delete store.months[monthKeys[i]];
            }
            // minutes: mantener últimos 2 días (según keys de days)
            const keepDays = new Set(dayKeys.slice(-2));
            const minuteKeys = Object.keys(store.minutes);
            for (const mk of minuteKeys) {
                const dayPart = mk.slice(0, 10);
                if (!keepDays.has(dayPart)) delete store.minutes[mk];
            }
        }
        function ingestSample(store, sampleMs, humidity, valveIsOn) {
            const now = new Date(sampleMs);
            const p = getMadridParts(now);
            const dayKey = `${p.y}-${p.mo}-${p.d}`;
            const monthKey = `${p.y}-${p.mo}`;
            const minuteKey = `${dayKey}T${p.h}:${p.mi}`;

            // Tiempo ON entre muestras (usamos el estado anterior)
            let dt = 0;
            if (store.last && typeof store.last.t === 'number') {
                dt = Math.max(0, sampleMs - store.last.t);
            }
            const prevOn = store.last ? !!store.last.on : false;
            const onMs = prevOn ? dt : 0;

            const bMin = ensureBucket(store.minutes, minuteKey);
            const bDay = ensureBucket(store.days, dayKey);
            const bMonth = ensureBucket(store.months, monthKey);

            bMin.valveOnMs += onMs;
            bDay.valveOnMs += onMs;
            bMonth.valveOnMs += onMs;

            if (!Number.isNaN(humidity)) {
                bMin.humSum += humidity; bMin.humCount += 1;
                bDay.humSum += humidity; bDay.humCount += 1;
                bMonth.humSum += humidity; bMonth.humCount += 1;
            }

            store.last = { t: sampleMs, on: !!valveIsOn };
            pruneStore(store);
            saveStore(store);
        }

        // --- Modo de visualización ---
        let viewMode = 'day'; // day | month | year
        function setActiveModeButtons(mode) {
            document.getElementById('btnDia').classList.toggle('active', mode === 'day');
            document.getElementById('btnMes').classList.toggle('active', mode === 'month');
            document.getElementById('btnAno').classList.toggle('active', mode === 'year');
        }
        setActiveModeButtons(viewMode);

        document.getElementById('btnDia').addEventListener('click', () => { viewMode = 'day'; setActiveModeButtons(viewMode); rebuildCharts(); });
        document.getElementById('btnMes').addEventListener('click', () => { viewMode = 'month'; setActiveModeButtons(viewMode); rebuildCharts(); });
        document.getElementById('btnAno').addEventListener('click', () => { viewMode = 'year'; setActiveModeButtons(viewMode); rebuildCharts(); });

        // --- Datos para Chart.js ---
        const humLabels = [];
        const humSeries = [];
        const valveLabels = [];
        const valveSeries = [];
        function setSeries(labels, series, newLabels, newSeries) {
            labels.length = 0;
            series.length = 0;
            for (const x of newLabels) labels.push(x);
            for (const y of newSeries) series.push(y);
        }

        const humChart = new Chart(document.getElementById('humChart'), {
            type: 'line',
            data: {
                labels: humLabels,
                datasets: [{
                    label: 'Humedad (%)',
                    data: humSeries,
                    borderColor: '#4CAF50',
                    backgroundColor: 'rgba(76, 175, 80, 0.15)',
                    fill: true,
                    tension: 0.25,
                    pointRadius: 0
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                plugins: { legend: { display: false } },
                scales: {
                    y: { min: 0, max: 100, ticks: { color: '#aaa' }, grid: { color: 'rgba(255,255,255,0.06)' } },
                    x: { ticks: { color: '#888', maxTicksLimit: 6 }, grid: { color: 'rgba(255,255,255,0.04)' } }
                }
            }
        });

        const valveChart = new Chart(document.getElementById('valveChart'), {
            type: 'line',
            data: {
                labels: valveLabels,
                datasets: [{
                    label: 'Válvula (0/1)',
                    data: valveSeries,
                    borderColor: '#33cc33',
                    backgroundColor: 'rgba(51, 204, 51, 0.12)',
                    fill: true,
                    stepped: true,
                    tension: 0,
                    pointRadius: 0
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                plugins: { legend: { display: false } },
                scales: {
                    y: {
                        min: -0.1,
                        max: 1.1,
                        ticks: {
                            color: '#aaa',
                            callback: (v) => (v >= 0.5 ? 'ON' : 'OFF')
                        },
                        grid: { color: 'rgba(255,255,255,0.06)' }
                    },
                    x: { ticks: { color: '#888', maxTicksLimit: 6 }, grid: { color: 'rgba(255,255,255,0.04)' } }
                }
            }
        });

        function rebuildChartsFromStore(storeOpt) {
            const store = storeOpt || loadStore();
            const now = nowAdjusted();
            const p = getMadridParts(now);

            let labels = [];
            let hum = [];
            let valve = [];
            let totalHumSum = 0;
            let totalHumCount = 0;
            let totalValveOnMs = 0;

            if (viewMode === 'day') {
                document.getElementById('periodLabel').textContent = 'Día';
                document.getElementById('periodValue').textContent = `${fmtDateEs.format(now)} (últimas 24h)`;

                const entries = Object.entries(store.minutes).sort((a, b) => a[0].localeCompare(b[0]));
                const last = entries.slice(-1440); // 24h * 60
                for (const [k, v] of last) {
                    const avg = v.humCount ? (v.humSum / v.humCount) : null;
                    // Mostrar DD HH:mm para que al cambiar de día se note
                    labels.push(`${k.slice(8, 10)} ${k.slice(11)}`);
                    hum.push(avg === null ? null : Number(avg.toFixed(2)));
                    const duty = Math.max(0, Math.min(1, (v.valveOnMs || 0) / 60000));
                    valve.push(Number(duty.toFixed(2)));
                    totalHumSum += v.humSum || 0;
                    totalHumCount += v.humCount || 0;
                    totalValveOnMs += v.valveOnMs || 0;
                }

                valveChart.options.scales.y.min = -0.1;
                valveChart.options.scales.y.max = 1.1;
                valveChart.options.scales.y.ticks.callback = (v) => (v >= 0.5 ? 'ON' : 'OFF');
                valveChart.data.datasets[0].label = 'Válvula (duty 0..1)';

            } else if (viewMode === 'month') {
                const monthKey = `${p.y}-${p.mo}`;
                document.getElementById('periodLabel').textContent = 'Mes';
                document.getElementById('periodValue').textContent = `${p.mo}/${p.y}`;

                const entries = Object.entries(store.days)
                    .filter(([k]) => k.startsWith(monthKey + '-'))
                    .sort((a, b) => a[0].localeCompare(b[0]));

                for (const [k, v] of entries) {
                    const avg = v.humCount ? (v.humSum / v.humCount) : null;
                    labels.push(k.slice(8, 10));
                    hum.push(avg === null ? null : Number(avg.toFixed(2)));
                    valve.push(Number(((v.valveOnMs || 0) / 3600000).toFixed(2))); // horas
                    totalHumSum += v.humSum || 0;
                    totalHumCount += v.humCount || 0;
                    totalValveOnMs += v.valveOnMs || 0;
                }

                valveChart.options.scales.y.min = 0;
                valveChart.options.scales.y.max = undefined;
                valveChart.options.scales.y.ticks.callback = undefined;
                valveChart.data.datasets[0].label = 'Válvula (horas ON/día)';

            } else {
                const yearKey = `${p.y}-`;
                document.getElementById('periodLabel').textContent = 'Año';
                document.getElementById('periodValue').textContent = `${p.y}`;

                const entries = Object.entries(store.months)
                    .filter(([k]) => k.startsWith(yearKey))
                    .sort((a, b) => a[0].localeCompare(b[0]));

                for (const [k, v] of entries) {
                    const avg = v.humCount ? (v.humSum / v.humCount) : null;
                    labels.push(k.slice(5, 7));
                    hum.push(avg === null ? null : Number(avg.toFixed(2)));
                    valve.push(Number(((v.valveOnMs || 0) / 3600000).toFixed(1))); // horas ON/mes
                    totalHumSum += v.humSum || 0;
                    totalHumCount += v.humCount || 0;
                    totalValveOnMs += v.valveOnMs || 0;
                }

                valveChart.options.scales.y.min = 0;
                valveChart.options.scales.y.max = undefined;
                valveChart.options.scales.y.ticks.callback = undefined;
                valveChart.data.datasets[0].label = 'Válvula (horas ON/mes)';
            }

            const avgHum = totalHumCount ? (totalHumSum / totalHumCount) : null;
            document.getElementById('avgHumidity').textContent = avgHum === null ? '--' : `${avgHum.toFixed(1)}%`;
            document.getElementById('totalValveOn').textContent = totalValveOnMs ? formatDuration(totalValveOnMs) : '--';
            document.getElementById('valveOnTime').textContent = `Tiempo ON (periodo): ${totalValveOnMs ? formatDuration(totalValveOnMs) : '--'}`;

            const lastPointEl = document.getElementById('lastPoint');
            if (lastPointEl) lastPointEl.textContent = labels.length ? String(labels[labels.length - 1]) : '--';

            setSeries(humLabels, humSeries, labels, hum);
            setSeries(valveLabels, valveSeries, labels, valve);
            humChart.update('none');
            valveChart.update('none');

            const valveDotChart = document.getElementById('valveDotChart');
            const valveTextChart = document.getElementById('valveTextChart');
            if (store.last && store.last.on) {
                valveDotChart.className = 'valve-dot on';
                valveTextChart.textContent = 'ENCENDIDA';
            } else if (store.last) {
                valveDotChart.className = 'valve-dot off';
                valveTextChart.textContent = 'APAGADA';
            } else {
                valveDotChart.className = 'valve-dot';
                valveTextChart.textContent = 'SIN DATOS';
            }
        }

        function rangeForMode(mode) {
            const now = nowAdjusted();
            // DÍA: usar RAW para que se vea en tiempo real (segundos) y no “a saltos” por minuto.
            if (mode === 'day') return { from: null, to: null, step: 'raw', bucketMs: null };
            if (mode === 'month') return { from: new Date(now.getFullYear(), now.getMonth(), 1), to: now, step: '1h', bucketMs: 3600000 };
            return { from: new Date(now.getFullYear(), 0, 1), to: now, step: '1h', bucketMs: 3600000 }; // year
        }

        function dayKeyForTs(ts) {
            const p = getMadridParts(new Date(ts));
            return `${p.y}-${p.mo}-${p.d}`;
        }
        function monthKeyForTs(ts) {
            const p = getMadridParts(new Date(ts));
            return `${p.y}-${p.mo}`;
        }

        async function rebuildChartsFromServer() {
            // Para rendimiento: limitar puntos en DÍA (raw) y usar canales
            if (!humChannelId && !valveChannelId) throw new Error('no channels');

            const now = nowAdjusted();
            const range = rangeForMode(viewMode);
            let step;
            let limit;
            if (viewMode === 'day') { step = 'raw'; limit = 1500; }
            else if (viewMode === 'month') { step = '1h'; limit = 2000; }
            else { step = '1h'; limit = 4000; }

            const rangeQs = (range && range.from && range.to)
                ? `&from=${encodeURIComponent(range.from.toISOString())}&to=${encodeURIComponent(range.to.toISOString())}`
                : '';

            const baseHum = humChannelId ? `/api/channel/history/${encodeURIComponent(deviceCode)}/${encodeURIComponent(humChannelId)}?step=${encodeURIComponent(step)}&limit=${limit}${rangeQs}` : null;
            const baseValve = valveChannelId ? `/api/channel/history/${encodeURIComponent(deviceCode)}/${encodeURIComponent(valveChannelId)}?step=${encodeURIComponent(step)}&limit=${limit}${rangeQs}` : null;

            async function rebuildChartsFromSensorHistoryFallback() {
                // Fallback robusto: usar sensor_data (siempre existe aunque el dispositivo esté offline)
                const url = `/api/sensor/history/${encodeURIComponent(deviceCode)}?step=${encodeURIComponent(step)}&limit=${limit}${rangeQs}`;
                const r = await fetch(url);
                if (!r.ok) throw new Error('sensor history failed');
                const payload = await r.json();
                const rows = Array.isArray(payload.rows) ? payload.rows : [];

                // Convertir a “shape” parecido a channel history
                const humRows = rows
                    .filter(x => x && x.humidity != null)
                    .map(x => ({ ts: x.ts, ts_madrid: x.ts_madrid, ts_madrid_label: x.ts_madrid_label, ts_madrid_day_key: x.ts_madrid_day_key, ts_madrid_month_key: x.ts_madrid_month_key, value: x.humidity }));

                const valveRows = rows
                    .map(x => {
                        // raw: valve_state (string), bucket: valve_on (0/1)
                        const s = (x && x.valve_on != null) ? Number(x.valve_on) : null;
                        if (Number.isFinite(s)) return { ts: x.ts, ts_madrid: x.ts_madrid, ts_madrid_label: x.ts_madrid_label, ts_madrid_day_key: x.ts_madrid_day_key, ts_madrid_month_key: x.ts_madrid_month_key, state: s >= 1 ? 1 : 0 };
                        const vs = String(x?.valve_state || '').toUpperCase();
                        if (!vs) return { ts: x.ts, ts_madrid: x.ts_madrid, ts_madrid_label: x.ts_madrid_label, ts_madrid_day_key: x.ts_madrid_day_key, ts_madrid_month_key: x.ts_madrid_month_key, state: null };
                        const on = (vs === 'ON' || vs === '1' || vs === 'TRUE');
                        return { ts: x.ts, ts_madrid: x.ts_madrid, ts_madrid_label: x.ts_madrid_label, ts_madrid_day_key: x.ts_madrid_day_key, ts_madrid_month_key: x.ts_madrid_month_key, state: on ? 1 : 0 };
                    });

                // Reutilizar la misma lógica de pintado (como si viniera de channels)
                const fakeHumPayload = { rows: humRows, range: payload.range };
                const fakeValvePayload = { rows: valveRows, range: payload.range };

                // Copia mínima de las variables que usa el bloque de render
                const humRows2 = humRows;
                const valveRows2 = valveRows;

                let labels = [];
                let hum = [];
                let valve = [];
                let totalHumSum = 0;
                let totalHumCount = 0;
                let totalValveOnMs = 0;

                if (viewMode === 'day') {
                    document.getElementById('periodLabel').textContent = 'Día';
                    const rangeTo = parseTsToDate(fakeHumPayload?.range?.to || fakeValvePayload?.range?.to) || now;
                    document.getElementById('periodValue').textContent = `${fmtDateEs.format(rangeTo)} (últimas 24h, histórico)`;

                    const labelSource = humRows2.length ? humRows2 : valveRows2;
                    for (const r of labelSource) labels.push(r.ts_madrid_label || (r.ts_madrid || String(r.ts || '')));

                    for (const r of humRows2) {
                        const v = r.value == null ? null : Number(r.value);
                        hum.push(v == null || Number.isNaN(v) ? null : Number(v.toFixed(2)));
                        if (v != null && !Number.isNaN(v)) { totalHumSum += v; totalHumCount += 1; }
                    }

                    let prevT = null;
                    let prevOn = false;
                    for (const r of valveRows2) {
                        const d = parseTsToDate(r.ts);
                        const onNow = Number(r.state || 0) >= 1;
                        valve.push(onNow ? 1 : 0);
                        const t = d ? d.getTime() : null;
                        if (t != null && prevT != null) {
                            const dt = Math.max(0, t - prevT);
                            if (prevOn) totalValveOnMs += dt;
                        }
                        prevT = t;
                        prevOn = onNow;
                    }

                    while (hum.length < labels.length) hum.push(null);
                    while (valve.length < labels.length) valve.push(null);

                    valveChart.options.scales.y.min = -0.1;
                    valveChart.options.scales.y.max = 1.1;
                    valveChart.options.scales.y.ticks.callback = (v) => (v >= 0.5 ? 'ON' : 'OFF');
                    valveChart.data.datasets[0].label = 'Válvula (0/1)';
                } else if (viewMode === 'month') {
                    const pNow = getMadridParts(nowAdjusted());
                    document.getElementById('periodLabel').textContent = 'Mes';
                    document.getElementById('periodValue').textContent = `${pNow.mo}/${pNow.y}`;

                    const byDayHum = {};
                    for (const r of humRows2) {
                        const k = r.ts_madrid_day_key || dayKeyForTs(r.ts);
                        const b = byDayHum[k] || (byDayHum[k] = { sum: 0, cnt: 0 });
                        const v = r.value == null ? null : Number(r.value);
                        if (v != null && !Number.isNaN(v)) { b.sum += v; b.cnt += 1; }
                    }
                    const byDayValve = {};
                    for (const r of valveRows2) {
                        const k = r.ts_madrid_day_key || dayKeyForTs(r.ts);
                        const b = byDayValve[k] || (byDayValve[k] = { on: 0, cnt: 0 });
                        const s = Number(r.state || 0) >= 1 ? 1 : 0;
                        b.on += s;
                        b.cnt += 1;
                    }
                    const keys = Array.from(new Set([...Object.keys(byDayHum), ...Object.keys(byDayValve)])).sort();
                    for (const k of keys) {
                        labels.push(k.slice(8, 10));
                        const hB = byDayHum[k];
                        const vB = byDayValve[k];
                        const avg = hB && hB.cnt ? (hB.sum / hB.cnt) : null;
                        hum.push(avg == null ? null : Number(avg.toFixed(2)));
                        const onHours = vB && vB.cnt ? (vB.on / vB.cnt) * 24 : 0;
                        valve.push(Number(onHours.toFixed(2)));
                        if (hB) { totalHumSum += hB.sum; totalHumCount += hB.cnt; }
                        if (vB) { totalValveOnMs += (vB.cnt ? (vB.on / vB.cnt) * 24 * 3600000 : 0); }
                    }

                    valveChart.options.scales.y.min = 0;
                    valveChart.options.scales.y.max = undefined;
                    valveChart.options.scales.y.ticks.callback = undefined;
                    valveChart.data.datasets[0].label = 'Válvula (horas ON/día)';
                } else {
                    const pNow = getMadridParts(nowAdjusted());
                    document.getElementById('periodLabel').textContent = 'Año';
                    document.getElementById('periodValue').textContent = `${pNow.y}`;

                    const byMonthHum = {};
                    for (const r of humRows2) {
                        const k = r.ts_madrid_month_key || monthKeyForTs(r.ts);
                        const b = byMonthHum[k] || (byMonthHum[k] = { sum: 0, cnt: 0 });
                        const v = r.value == null ? null : Number(r.value);
                        if (v != null && !Number.isNaN(v)) { b.sum += v; b.cnt += 1; }
                    }
                    const byMonthValve = {};
                    for (const r of valveRows2) {
                        const k = r.ts_madrid_month_key || monthKeyForTs(r.ts);
                        const b = byMonthValve[k] || (byMonthValve[k] = { on: 0, cnt: 0 });
                        const s = Number(r.state || 0) >= 1 ? 1 : 0;
                        b.on += s;
                        b.cnt += 1;
                    }
                    const keys = Array.from(new Set([...Object.keys(byMonthHum), ...Object.keys(byMonthValve)])).sort();
                    for (const k of keys) {
                        labels.push(k.slice(5, 7));
                        const hB = byMonthHum[k];
                        const vB = byMonthValve[k];
                        const avg = hB && hB.cnt ? (hB.sum / hB.cnt) : null;
                        hum.push(avg == null ? null : Number(avg.toFixed(2)));
                        const onHours = vB && vB.cnt ? (vB.on / vB.cnt) * (30 * 24) : 0;
                        valve.push(Number(onHours.toFixed(1)));
                        if (hB) { totalHumSum += hB.sum; totalHumCount += hB.cnt; }
                        if (vB) { totalValveOnMs += (vB.cnt ? (vB.on / vB.cnt) * (30 * 24) * 3600000 : 0); }
                    }

                    valveChart.options.scales.y.min = 0;
                    valveChart.options.scales.y.max = undefined;
                    valveChart.options.scales.y.ticks.callback = undefined;
                    valveChart.data.datasets[0].label = 'Válvula (horas ON/mes)';
                }

                const avgHum = totalHumCount ? (totalHumSum / totalHumCount) : null;
                document.getElementById('avgHumidity').textContent = avgHum === null ? '--' : `${avgHum.toFixed(1)}%`;
                document.getElementById('totalValveOn').textContent = totalValveOnMs ? formatDuration(totalValveOnMs) : '--';
                document.getElementById('valveOnTime').textContent = `Tiempo ON (periodo): ${totalValveOnMs ? formatDuration(totalValveOnMs) : '--'}`;

                const lastPointEl = document.getElementById('lastPoint');
                if (lastPointEl) lastPointEl.textContent = labels.length ? String(labels[labels.length - 1]) : '--';

                setSeries(humLabels, humSeries, labels, hum);
                setSeries(valveLabels, valveSeries, labels, valve);
                humChart.update('none');
                valveChart.update('none');
            }

            const [humRes, valveRes] = await Promise.all([
                baseHum ? fetch(baseHum) : Promise.resolve(null),
                baseValve ? fetch(baseValve) : Promise.resolve(null)
            ]);

            if (baseHum && (!humRes || !humRes.ok)) return rebuildChartsFromSensorHistoryFallback();
            if (baseValve && (!valveRes || !valveRes.ok)) return rebuildChartsFromSensorHistoryFallback();

            const humPayload = humRes ? await humRes.json() : { rows: [] };
            const valvePayload = valveRes ? await valveRes.json() : { rows: [] };

            const humRows = Array.isArray(humPayload.rows) ? humPayload.rows : [];
            const valveRows = Array.isArray(valvePayload.rows) ? valvePayload.rows : [];

            // Si el backend no está rellenando channel_samples (o están desfasados),
            // la gráfica puede quedarse “clavada” en un timestamp antiguo.
            // En ese caso, usamos el store local (alimentado por /api/sensor/latest).
            {
                const lastRow = humRows.length ? humRows[humRows.length - 1] : (valveRows.length ? valveRows[valveRows.length - 1] : null);
                const lastTs = lastRow ? parseTsToDate(lastRow.ts) : null;
                const ageMs = lastTs ? (now.getTime() - lastTs.getTime()) : Infinity;
                // Si el último punto es muy viejo o no existe, usar histórico de sensor_data.
                if (!lastTs || !Number.isFinite(ageMs) || ageMs > 10 * 60000) {
                    return rebuildChartsFromSensorHistoryFallback();
                }
            }

            let labels = [];
            let hum = [];
            let valve = [];
            let totalHumSum = 0;
            let totalHumCount = 0;
            let totalValveOnMs = 0;

            if (viewMode === 'day') {
                document.getElementById('periodLabel').textContent = 'Día';
                const rangeTo = parseTsToDate(humPayload?.range?.to || valvePayload?.range?.to) || now;
                document.getElementById('periodValue').textContent = `${fmtDateEs.format(rangeTo)} (últimas 24h, tiempo real)`;

                // Unificar labels por timestamp: usamos los del sensor si existen, si no los de válvula.
                const labelSource = humRows.length ? humRows : valveRows;
                for (const r of labelSource) {
                    labels.push(r.ts_madrid_label || (r.ts_madrid || String(r.ts || '')));
                }

                // Serie humedad
                for (const r of humRows) {
                    const v = r.value == null ? null : Number(r.value);
                    hum.push(v == null || Number.isNaN(v) ? null : Number(v.toFixed(2)));
                    if (v != null && !Number.isNaN(v)) { totalHumSum += v; totalHumCount += 1; }
                }

                // Serie válvula + tiempo ON
                let prevT = null;
                let prevOn = false;
                for (const r of valveRows) {
                    const d = parseTsToDate(r.ts);
                    const onNow = Number(r.state || 0) >= 1;
                    valve.push(onNow ? 1 : 0);
                    const t = d ? d.getTime() : null;
                    if (t != null && prevT != null) {
                        const dt = Math.max(0, t - prevT);
                        if (prevOn) totalValveOnMs += dt;
                    }
                    prevT = t;
                    prevOn = onNow;
                }

                // Alinear longitudes (Chart.js agradece arrays consistentes)
                while (hum.length < labels.length) hum.push(null);
                while (valve.length < labels.length) valve.push(null);

                // Estado actual en tarjeta de la gráfica según el último valor del canal
                const valveDotChart = document.getElementById('valveDotChart');
                const valveTextChart = document.getElementById('valveTextChart');
                const lastV = valveRows.length ? valveRows[valveRows.length - 1] : null;
                if (lastV && Number(lastV.state || 0) >= 1) {
                    valveDotChart.className = 'valve-dot on';
                    valveTextChart.textContent = 'ENCENDIDA';
                } else if (lastV) {
                    valveDotChart.className = 'valve-dot off';
                    valveTextChart.textContent = 'APAGADA';
                } else {
                    valveDotChart.className = 'valve-dot';
                    valveTextChart.textContent = 'SIN DATOS';
                }

                valveChart.options.scales.y.min = -0.1;
                valveChart.options.scales.y.max = 1.1;
                valveChart.options.scales.y.ticks.callback = (v) => (v >= 0.5 ? 'ON' : 'OFF');
                valveChart.data.datasets[0].label = 'Válvula (0/1)';

            } else if (viewMode === 'month') {
                const pNow = getMadridParts(nowAdjusted());
                document.getElementById('periodLabel').textContent = 'Mes';
                document.getElementById('periodValue').textContent = `${pNow.mo}/${pNow.y}`;

                // En month/year, backend ya devuelve buckets por hora; agrupamos a días aquí (usando claves Madrid del backend)
                const byDayHum = {};
                for (const r of humRows) {
                    const k = r.ts_madrid_day_key || dayKeyForTs(r.ts);
                    const b = byDayHum[k] || (byDayHum[k] = { sum: 0, cnt: 0 });
                    const v = r.value == null ? null : Number(r.value);
                    if (v != null && !Number.isNaN(v)) { b.sum += v; b.cnt += 1; }
                }
                const byDayValve = {};
                for (const r of valveRows) {
                    const k = r.ts_madrid_day_key || dayKeyForTs(r.ts);
                    const b = byDayValve[k] || (byDayValve[k] = { on: 0, cnt: 0 });
                    const s = Number(r.state || 0) >= 1 ? 1 : 0;
                    b.on += s;
                    b.cnt += 1;
                }
                const keys = Array.from(new Set([...Object.keys(byDayHum), ...Object.keys(byDayValve)])).sort();
                for (const k of keys) {
                    labels.push(k.slice(8, 10));
                    const hB = byDayHum[k];
                    const vB = byDayValve[k];
                    const avg = hB && hB.cnt ? (hB.sum / hB.cnt) : null;
                    hum.push(avg == null ? null : Number(avg.toFixed(2)));
                    // Horas ON estimadas: (porcentaje de horas con state=1) * 24
                    const onHours = vB && vB.cnt ? (vB.on / vB.cnt) * 24 : 0;
                    valve.push(Number(onHours.toFixed(2)));
                    if (hB) { totalHumSum += hB.sum; totalHumCount += hB.cnt; }
                    if (vB) { totalValveOnMs += (vB.cnt ? (vB.on / vB.cnt) * 24 * 3600000 : 0); }
                }

                valveChart.options.scales.y.min = 0;
                valveChart.options.scales.y.max = undefined;
                valveChart.options.scales.y.ticks.callback = undefined;
                valveChart.data.datasets[0].label = 'Válvula (horas ON/día)';

            } else {
                const pNow = getMadridParts(nowAdjusted());
                document.getElementById('periodLabel').textContent = 'Año';
                document.getElementById('periodValue').textContent = `${pNow.y}`;

                const byMonthHum = {};
                for (const r of humRows) {
                    const k = r.ts_madrid_month_key || monthKeyForTs(r.ts);
                    const b = byMonthHum[k] || (byMonthHum[k] = { sum: 0, cnt: 0 });
                    const v = r.value == null ? null : Number(r.value);
                    if (v != null && !Number.isNaN(v)) { b.sum += v; b.cnt += 1; }
                }
                const byMonthValve = {};
                for (const r of valveRows) {
                    const k = r.ts_madrid_month_key || monthKeyForTs(r.ts);
                    const b = byMonthValve[k] || (byMonthValve[k] = { on: 0, cnt: 0 });
                    const s = Number(r.state || 0) >= 1 ? 1 : 0;
                    b.on += s;
                    b.cnt += 1;
                }
                const keys = Array.from(new Set([...Object.keys(byMonthHum), ...Object.keys(byMonthValve)])).sort();
                for (const k of keys) {
                    labels.push(k.slice(5, 7));
                    const hB = byMonthHum[k];
                    const vB = byMonthValve[k];
                    const avg = hB && hB.cnt ? (hB.sum / hB.cnt) : null;
                    hum.push(avg == null ? null : Number(avg.toFixed(2)));
                    const onHours = vB && vB.cnt ? (vB.on / vB.cnt) * (30 * 24) : 0; // aprox
                    valve.push(Number(onHours.toFixed(1)));
                    if (hB) { totalHumSum += hB.sum; totalHumCount += hB.cnt; }
                    if (vB) { totalValveOnMs += (vB.cnt ? (vB.on / vB.cnt) * (30 * 24) * 3600000 : 0); }
                }

                valveChart.options.scales.y.min = 0;
                valveChart.options.scales.y.max = undefined;
                valveChart.options.scales.y.ticks.callback = undefined;
                valveChart.data.datasets[0].label = 'Válvula (horas ON/mes)';
            }

            const avgHum = totalHumCount ? (totalHumSum / totalHumCount) : null;
            document.getElementById('avgHumidity').textContent = avgHum === null ? '--' : `${avgHum.toFixed(1)}%`;
            document.getElementById('totalValveOn').textContent = totalValveOnMs ? formatDuration(totalValveOnMs) : '--';
            document.getElementById('valveOnTime').textContent = `Tiempo ON (periodo): ${totalValveOnMs ? formatDuration(totalValveOnMs) : '--'}`;

            const lastPointEl = document.getElementById('lastPoint');
            if (lastPointEl) lastPointEl.textContent = labels.length ? String(labels[labels.length - 1]) : '--';

            setSeries(humLabels, humSeries, labels, hum);
            setSeries(valveLabels, valveSeries, labels, valve);
            humChart.update('none');
            valveChart.update('none');
        }

        function rebuildCharts(storeOpt) {
            if (storeOpt) return rebuildChartsFromStore(storeOpt);
            rebuildChartsFromServer().catch(() => rebuildChartsFromStore());
        }

        function tickClock() {
            const t = fmtNowEs.format(nowAdjusted());
            document.getElementById('nowEs').textContent = t;
            const topNow = document.getElementById('topNowEs');
            if (topNow) topNow.textContent = t;
        }
        tickClock();
        setInterval(tickClock, 1000);

        async function cargarConfig() {
            try {
                const res = await fetch(`/api/config/${encodeURIComponent(deviceCode)}`, { credentials: 'include' });
                const cfg = await res.json();

                let threshold = parseFloat(cfg.humidity_low_threshold);
                if (isNaN(threshold) || threshold < 1) threshold = 25;
                if (threshold > 100) threshold = 100;

                config.threshold = threshold;
                config.colorB = cfg.humidity_low_color || 'Rojo';
                config.colorG = cfg.humidity_good_color || 'Verde';

                const thresholdEl = document.getElementById('threshold');
                const thresholdValueEl = document.getElementById('thresholdValue');
                const colorBuenaEl = document.getElementById('colorBuena');
                const colorBajaEl = document.getElementById('colorBaja');

                // Umbral global ya no se configura en UI (cada planta tiene su propio umbral).
                // Mantenemos config.threshold solo por compatibilidad/legacy.
                if (thresholdEl) thresholdEl.value = String(config.threshold);
                if (thresholdValueEl) thresholdValueEl.textContent = config.threshold + '%';
                if (colorBuenaEl) colorBuenaEl.value = config.colorB;
                if (colorBajaEl) colorBajaEl.value = config.colorG;

                // Campos avanzados
                document.getElementById('wetV').value = (cfg.wet_v == null ? String(DEFAULT_AUTO_CONFIG.wet_v) : cfg.wet_v);
                document.getElementById('dryV').value = (cfg.dry_v == null ? String(DEFAULT_AUTO_CONFIG.dry_v) : cfg.dry_v);
                document.getElementById('alertHumLowMin').value = cfg.alert_humidity_low_minutes ?? DEFAULT_AUTO_CONFIG.alert_humidity_low_minutes;
                document.getElementById('alertValveMaxMin').value = cfg.alert_valve_on_max_minutes ?? DEFAULT_AUTO_CONFIG.alert_valve_on_max_minutes;
                document.getElementById('alertDeadMin').value = cfg.alert_sensor_dead_minutes ?? DEFAULT_AUTO_CONFIG.alert_sensor_dead_minutes;
                document.getElementById('alertVmin').value = (cfg.alert_voltage_min == null ? '' : cfg.alert_voltage_min);
                document.getElementById('alertVmax').value = (cfg.alert_voltage_max == null ? '' : cfg.alert_voltage_max);
                document.getElementById('notifyWebhook').value = (cfg.notify_webhook_url == null ? '' : cfg.notify_webhook_url);
                document.getElementById('notifyTelegram').value = (cfg.notify_telegram_chat_id == null ? '' : cfg.notify_telegram_chat_id);

                // Zonas (8 plantas): umbral y asignación por canal
                zonesState = normalizeZonesFromServer(cfg?.zones, config.threshold);
                renderZonesUI();
            } catch (e) {
                console.log('Error cargando config');
            }
        }

        function applyDefaultAutoConfigToUI() {
            document.getElementById('wetV').value = String(DEFAULT_AUTO_CONFIG.wet_v);
            document.getElementById('dryV').value = String(DEFAULT_AUTO_CONFIG.dry_v);
            document.getElementById('alertHumLowMin').value = String(DEFAULT_AUTO_CONFIG.alert_humidity_low_minutes);
            document.getElementById('alertValveMaxMin').value = String(DEFAULT_AUTO_CONFIG.alert_valve_on_max_minutes);
            document.getElementById('alertDeadMin').value = String(DEFAULT_AUTO_CONFIG.alert_sensor_dead_minutes);
            document.getElementById('alertVmin').value = '';
            document.getElementById('alertVmax').value = '';
        }

        async function resetearDefaults() {
            const ok = confirm('¿Restablecer los valores por defecto de CONFIGURACIÓN AUTOMÁTICA?\n\nSe aplicarán estos valores:\n- WET_V: 1.10\n- DRY_V: 2.60\n- Alertas (min): 0\n- Voltaje mín/máx: vacío (desactivado)');
            if (!ok) return;
            applyDefaultAutoConfigToUI();

            const okSave = confirm('¿Quieres guardarlos ahora en el dispositivo?');
            if (okSave) {
                await guardar();
            }
        }

        {
            const thr = document.getElementById('threshold');
            if (thr) {
                thr.addEventListener('input', (e) => {
                    config.threshold = parseInt(e.target.value);
                    const tv = document.getElementById('thresholdValue');
                    if (tv) tv.textContent = config.threshold + '%';
                });
            }
        }

        document.getElementById('colorBuena').addEventListener('change', (e) => {
            config.colorB = e.target.value;
        });

        document.getElementById('colorBaja').addEventListener('change', (e) => {
            config.colorG = e.target.value;
        });

        async function guardar() {
            const btn = document.getElementById('btnSaveConfig');
            return withBusy(btn, 'Guardando...', async () => {
            try {
                const headersBase = { 'Content-Type': 'application/json' };
                setStatusText(' Guardando configuración...');

                const wetV = document.getElementById('wetV').value;
                const dryV = document.getElementById('dryV').value;
                const alertHumLowMin = document.getElementById('alertHumLowMin').value;
                const alertValveMaxMin = document.getElementById('alertValveMaxMin').value;
                const alertDeadMin = document.getElementById('alertDeadMin').value;
                const alertVmin = document.getElementById('alertVmin').value;
                const alertVmax = document.getElementById('alertVmax').value;
                const notifyWebhook = document.getElementById('notifyWebhook').value;
                const notifyTelegram = document.getElementById('notifyTelegram').value;

                const body = {
                    // Compat: mantener el umbral global sincronizado con PLANTA 1
                    humidity_low_threshold: (zonesState && zonesState[0] && zonesState[0].humidity_low_threshold != null)
                        ? Number(zonesState[0].humidity_low_threshold)
                        : config.threshold,
                    humidity_low_color: config.colorB,
                    humidity_good_color: config.colorG,
                    wet_v: wetV === '' ? undefined : Number(wetV),
                    dry_v: dryV === '' ? undefined : Number(dryV),
                    alert_humidity_low_minutes: Number(alertHumLowMin || 0),
                    alert_valve_on_max_minutes: Number(alertValveMaxMin || 0),
                    alert_sensor_dead_minutes: Number(alertDeadMin || 0),
                    alert_voltage_min: alertVmin === '' ? null : Number(alertVmin),
                    alert_voltage_max: alertVmax === '' ? null : Number(alertVmax),
                    notify_webhook_url: notifyWebhook === '' ? null : String(notifyWebhook),
                    notify_telegram_chat_id: notifyTelegram === '' ? null : String(notifyTelegram),
                    zones: (zonesState || []).slice(0, 8).map((z, i) => ({
                        zone: i + 1,
                        soil_channel_index: z?.soil_channel_index == null ? null : Number(z.soil_channel_index),
                        valve_channel_index: z?.valve_channel_index == null ? null : Number(z.valve_channel_index),
                        humidity_low_threshold: z?.humidity_low_threshold == null ? null : Number(z.humidity_low_threshold)
                    }))
                };

                async function doSave(headers) {
                    return fetch(`/api/config/${encodeURIComponent(deviceCode)}`, {
                        method: 'POST',
                        headers,
                        credentials: 'include',
                        body: JSON.stringify(body)
                    });
                }

                const saved = (getSavedToken(deviceCode) || '').trim();
                const headers1 = { ...headersBase };
                if (saved) headers1['X-Device-Token'] = saved;

                let res = await doSave(headers1);

                if (res.status === 401 || res.status === 403) {
                    const msg = saved
                        ? 'Token guardado inválido o caducado. Pega el token correcto:'
                        : 'Este dispositivo requiere token para guardar. Pégalo aquí:';
                    const t = (prompt(msg) || '').trim();
                    if (t) {
                        saveToken(deviceCode, t);
                        const headers2 = { ...headersBase, 'X-Device-Token': t };
                        res = await doSave(headers2);
                    }
                }

                if (res.ok) {
                    setStatusText(' Configuración guardada');
                    alert(' Configuracion guardada!\nEl ESP32 aplicara los cambios en 10 segundos.');
                } else {
                    setStatusText(' Error al guardar');
                    alert(' Error al guardar');
                }
            } catch (e) {
                setStatusText(' Error de conexión');
                alert(' Error de conexion');
            }
            });
        }

        // Hook UI: reset defaults
        document.getElementById('btnResetDefaults')?.addEventListener('click', () => {
            resetearDefaults();
        });

        async function actualizarSensores() {
            try {
                const res = await fetch(`/api/sensor/latest/${encodeURIComponent(deviceCode)}`);
                const data = await res.json();

                // Ajuste de reloj (si el backend lo manda)
                if (data && data.server_now) {
                    const serverMs = Date.parse(data.server_now);
                    if (Number.isFinite(serverMs)) {
                        serverClockOffsetMs = serverMs - Date.now();
                    }
                }
                
                updateConnectedDeviceCards(data);

                const v = (data.voltage == null ? null : Number(data.voltage));
                document.getElementById('voltage').textContent = (v == null || Number.isNaN(v) ? '--' : v.toFixed(2));

                const rssi = (data.wifi_rssi == null ? null : Number(data.wifi_rssi));
                const rssiOk = !(rssi == null || Number.isNaN(rssi) || rssi === 0);
                document.getElementById('rssi').textContent = (!rssiOk ? '--' : String(Math.trunc(rssi)));

                const rbRaw = (data.reboot_count_display != null ? data.reboot_count_display : data.reboot_count);
                const rb = (rbRaw == null ? null : Number(rbRaw));
                lastRebootsBase = (rb == null || Number.isNaN(rb)) ? null : Math.trunc(rb);
                const localOffset = getLocalRebootsOffset(deviceCode);
                const rbShown = (lastRebootsBase == null) ? null : Math.max(0, lastRebootsBase - localOffset);
                document.getElementById('reboots').textContent = (rbShown == null ? '--' : String(Math.trunc(rbShown)));

                // Colores por umbral (valores típicos; además se respetan min/max de alertas si están configurados)
                const alertVminRaw = document.getElementById('alertVmin')?.value;
                const alertVmaxRaw = document.getElementById('alertVmax')?.value;
                const alertVmin = Number(alertVminRaw);
                const alertVmax = Number(alertVmaxRaw);
                const hasVmin = !!(alertVminRaw != null && alertVminRaw.trim() !== '' && Number.isFinite(alertVmin));
                const hasVmax = !!(alertVmaxRaw != null && alertVmaxRaw.trim() !== '' && Number.isFinite(alertVmax));
                if (v == null || Number.isNaN(v)) {
                    setMetricStateById('voltage', 'metric-neutral');
                } else if ((hasVmin && v < alertVmin) || (hasVmax && v > alertVmax)) {
                    setMetricStateById('voltage', 'metric-bad', `Fuera de rango (${hasVmin ? alertVmin : '-'} – ${hasVmax ? alertVmax : '-' } V)`);
                } else {
                    // fallback si no hay min/max
                    const st = v < 1.0 ? 'metric-bad' : (v < 1.8 ? 'metric-warn' : 'metric-good');
                    setMetricStateById('voltage', st);
                }

                if (!rssiOk) {
                    setMetricStateById('rssi', 'metric-neutral');
                } else {
                    const st = rssi >= -60 ? 'metric-good' : (rssi >= -75 ? 'metric-warn' : 'metric-bad');
                    setMetricStateById('rssi', st);
                }

                // Ya no mostramos el umbral en la sección "DISPOSITIVO CONECTADO"

                if (rbShown == null) {
                    setMetricStateById('reboots', 'metric-neutral');
                } else {
                    const st = rbShown === 0 ? 'metric-good' : (rbShown <= 2 ? 'metric-warn' : 'metric-bad');
                    setMetricStateById('reboots', st);
                }

                const rawValve = (data.valve_state || '').toString().toUpperCase();
                const isOn = rawValve === 'ON' || rawValve === '1' || rawValve === 'TRUE';
                const isOff = rawValve === 'OFF' || rawValve === '0' || rawValve === 'FALSE';

                const valveDotChart = document.getElementById('valveDotChart');
                const valveTextChart = document.getElementById('valveTextChart');
                if (isOn) {
                    valveDotChart.className = 'valve-dot on';
                    valveTextChart.textContent = 'ENCENDIDA';
                } else if (isOff) {
                    valveDotChart.className = 'valve-dot off';
                    valveTextChart.textContent = 'APAGADA';
                } else {
                    valveDotChart.className = 'valve-dot';
                    valveTextChart.textContent = 'SIN DATOS';
                }

                // --- Mantener el histórico local como fallback y refrescar gráficas del servidor ---
                try {
                    const sampleDate = parseTsToDate(data.created_at) || nowAdjusted();
                    const nowMs = sampleDate.getTime();
                    const hum = Number.parseFloat(data.humidity);
                    const valveVal = isOn ? 1 : (isOff ? 0 : null);
                    const store = loadStore();
                    ingestSample(store, nowMs, hum, valveVal === 1);
                    // Importante: si SSE está caído, esto mantiene las gráficas vivas.
                    scheduleChartsRebuild();
                } catch {}

                // Estado online/offline del dispositivo basado en “último dato”
                let deviceOnline = null;
                try {
                    const sampleDate = parseTsToDate(data.created_at);
                    const deadRaw = document.getElementById('alertDeadMin')?.value;
                    const deadMin = Number(deadRaw);
                    const maxAgeMs = (deadRaw != null && deadRaw.trim() !== '' && Number.isFinite(deadMin) && deadMin > 0)
                        ? deadMin * 60000
                        : 3 * 60000;
                    const ageMs = sampleDate ? (nowAdjusted().getTime() - sampleDate.getTime()) : Infinity;
                    const lastSampleLabel = (data && data.created_at_madrid)
                        ? String(data.created_at_madrid)
                        : (sampleDate ? sampleDate.toLocaleString('es-ES', { timeZone: TZ, hour12: false }) : '--');
                    deviceOnline = ageMs <= maxAgeMs;
                    setConnectionUI(deviceOnline ? 'online' : 'offline');
                } catch {
                    setConnectionUI('unknown');
                }

                // Rendimiento: no forzar rebuild de gráficas en cada tick
                // (se reconstruyen con throttle por SSE/intervalos)
                
                // Mostrar también la hora del último dato para detectar desfases/datos viejos
                const sampleDateForUi = parseTsToDate(data?.created_at);
                const lastSampleUi = (data && data.created_at_madrid)
                    ? String(data.created_at_madrid)
                    : (sampleDateForUi ? sampleDateForUi.toLocaleString('es-ES', { timeZone: TZ, hour12: false }) : '--');

                if (deviceOnline === false) {
                    setStatusText(` Offline (datos antiguos) · Último: ${lastSampleUi} · Ahora: ${fmtNowEs.format(nowAdjusted())}`);
                    setStatusClass(false);
                } else {
                    setStatusText(` Online · Último: ${lastSampleUi} · Ahora: ${fmtNowEs.format(nowAdjusted())}`);
                    setStatusClass(true);
                }
            } catch(e) {
                setConnectionUI('offline');
                setStatusText(' Sin conexion');
                setStatusClass(false);
            }

            // Zonas: últimos valores por canal
            try {
                const r2 = await fetch(`/api/channels/${encodeURIComponent(deviceCode)}/latest`, { credentials: 'include' });
                if (r2.ok) {
                    const p = await r2.json();
                    updateZonesFromLatestPayload(p);
                }
            } catch {
                // ignore
            }
        }

        async function cargarAlertas() {
            const st = document.getElementById('alertsStatus');
            const listEl = document.getElementById('alertsList');
            try {
                const r = await fetch(`/api/alerts/${encodeURIComponent(deviceCode)}?limit=10`);
                const j = await r.json();
                const rows = Array.isArray(j.rows) ? j.rows : [];
                st.textContent = rows.length ? `Últimas ${rows.length} alertas` : 'Sin alertas';
                listEl.innerHTML = '';
                for (const a of rows) {
                    const item = document.createElement('div');
                    item.className = 'sensor-card';
                    item.style.textAlign = 'left';
                    const when = a.created_at_madrid || (a.created_at ? new Date(a.created_at).toLocaleString('es-ES', { timeZone: TZ, hour12: false }) : '--');
                    item.innerHTML = `
                        <div class="sensor-label">${a.kind} · ${when}</div>
                        <div style="color:#ddd; font-weight:bold;">${a.message}</div>
                    `;
                    listEl.appendChild(item);
                }
            } catch {
                st.textContent = 'No se pudieron cargar alertas';
            }
        }

        function startSSE() {
            try {
                const es = new EventSource(`/api/sse/${encodeURIComponent(deviceCode)}`);
                es.addEventListener('sensor', () => {
                    actualizarSensores();
                    scheduleChartsRebuild();
                });
                es.addEventListener('alert', () => {
                    cargarAlertas();
                });
                es.onerror = () => {
                    try { es.close(); } catch {}
                };
            } catch {
                // ignore
            }
        }

        async function boot() {
            initCollapsibles();
            const ok = await loadDevices();
            if (!ok) return;
            if (!hasDevices) return;

            await cargarConfig();
            await loadChannels();
            renderZonesUI();
            scheduleChartsRebuild();
            rebuildCharts();
            cargarAlertas();
            actualizarSensores();
            startSSE();
            setInterval(actualizarSensores, 15000);
            setInterval(scheduleChartsRebuild, 60000);
            setInterval(cargarAlertas, 60000);
        }

        boot();

        // --- UI acciones rápidas ---
        document.getElementById('btnAddDevice')?.addEventListener('click', async () => {
            const btn = document.getElementById('btnAddDevice');
            await withBusy(btn, 'Añadiendo...', async () => {
            const deviceRaw = prompt('Código del dispositivo (ej: RIEGO_002):');
            if (deviceRaw === null) return; // Cancel
            const device_code = String(deviceRaw || '').trim();
            if (!device_code) return;

            const tokenRaw = prompt('claim_token (código de emparejamiento):');
            if (tokenRaw === null) return; // Cancel
            const claim_token = String(tokenRaw || '').trim();
            if (!claim_token) {
                alert('Debes pegar el claim_token (token del ESP32) para emparejar.');
                return;
            }
            try {
                // Preferido (multi-tenant): claim
                let r = await fetch('/api/device/claim', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({ device_code, claim_token })
                });

                if (r.status === 401) {
                    const next = encodeURIComponent(location.pathname + location.search + location.hash);
                    window.location.href = `/login?next=${next}`;
                    return;
                }

                // Fallback legacy: register (sin cuentas)
                if (r.status === 404 || r.status === 405) {
                    const name = (prompt('Nombre (opcional):') || 'ESP32 Riego').trim();
                    const locationTxt = (prompt('Ubicación (opcional):') || '').trim();
                    r = await fetch('/api/device/register', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include',
                        body: JSON.stringify({ device_code, name, location: locationTxt || null })
                    });
                }

                const j = await r.json().catch(() => ({}));
                if (!r.ok) throw new Error(j.error || 'No se pudo añadir');

                window.location.href = `/panel/${encodeURIComponent(device_code)}`;
            } catch {
                alert('No se pudo añadir el dispositivo (verifica el claim_token)');
            }
            });
        });

        document.getElementById('btnAddValve')?.addEventListener('click', () => {
            (async () => {
                const btn = document.getElementById('btnAddValve');
                await withBusy(btn, 'Añadiendo...', async () => {
                const current = (channels || []).filter(c => c && c.kind === 'valve').length;
                if (current >= 8) {
                    alert('Máximo 8 válvulas por dispositivo (modelo de 8 zonas).');
                    return;
                }
                const nameRaw = prompt('Nombre de la nueva válvula (ej: Válvula 2):');
                if (nameRaw === null) return; // Cancel
                const name = String(nameRaw || '').trim();
                const headers = { 'Content-Type': 'application/json' };
                const saved = (getSavedToken(deviceCode) || '').trim();
                if (saved) headers['X-Device-Token'] = saved;
                let r = await fetch(`/api/channels/${encodeURIComponent(deviceCode)}`, {
                    method: 'POST',
                    headers,
                    credentials: 'include',
                    body: JSON.stringify({ kind: 'valve', name: name || undefined })
                });
                if ((r.status === 401 || r.status === 403) && !saved) {
                    const tRaw = prompt('Este dispositivo requiere token para añadir válvulas. Pégalo aquí:');
                    if (tRaw === null) return; // Cancel
                    const t = String(tRaw || '').trim();
                    if (t) {
                        saveToken(deviceCode, t);
                        r = await fetch(`/api/channels/${encodeURIComponent(deviceCode)}`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json', 'X-Device-Token': t },
                            credentials: 'include',
                            body: JSON.stringify({ kind: 'valve', name: name || undefined })
                        });
                    }
                }
                if (!r.ok) return alert('No se pudo añadir la válvula');
                await loadChannels();
                scheduleChartsRebuild();
                alert('Válvula añadida. La gráfica aparecerá cuando el ESP32 envíe datos de esa válvula.');
                });
            })();
        });
        document.getElementById('btnAddSensor')?.addEventListener('click', () => {
            (async () => {
                const btn = document.getElementById('btnAddSensor');
                await withBusy(btn, 'Añadiendo...', async () => {
                const current = (channels || []).filter(c => c && c.kind === 'soil_sensor').length;
                if (current >= 8) {
                    alert('Máximo 8 sensores de humedad por dispositivo (modelo de 8 zonas).');
                    return;
                }
                const nameRaw = prompt('Nombre del nuevo sensor (ej: Sensor 2):');
                if (nameRaw === null) return; // Cancel
                const name = String(nameRaw || '').trim();
                const headers = { 'Content-Type': 'application/json' };
                const saved = (getSavedToken(deviceCode) || '').trim();
                if (saved) headers['X-Device-Token'] = saved;
                let r = await fetch(`/api/channels/${encodeURIComponent(deviceCode)}`, {
                    method: 'POST',
                    headers,
                    credentials: 'include',
                    body: JSON.stringify({ kind: 'soil_sensor', name: name || undefined })
                });
                if ((r.status === 401 || r.status === 403) && !saved) {
                    const tRaw = prompt('Este dispositivo requiere token para añadir sensores. Pégalo aquí:');
                    if (tRaw === null) return; // Cancel
                    const t = String(tRaw || '').trim();
                    if (t) {
                        saveToken(deviceCode, t);
                        r = await fetch(`/api/channels/${encodeURIComponent(deviceCode)}`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json', 'X-Device-Token': t },
                            credentials: 'include',
                            body: JSON.stringify({ kind: 'soil_sensor', name: name || undefined })
                        });
                    }
                }
                if (!r.ok) return alert('No se pudo añadir el sensor');
                await loadChannels();
                scheduleChartsRebuild();
                alert('Sensor añadido. La gráfica aparecerá cuando el ESP32 envíe datos de ese sensor.');
                });
            })();
        });

        async function renameChannel(channelId, kindLabel) {
            if (!channelId) return;
            const newName = (prompt(`Nuevo nombre para ${kindLabel}:`) || '').trim();
            if (!newName) return;
            const headers = { 'Content-Type': 'application/json' };
            const saved = (getSavedToken(deviceCode) || '').trim();
            if (saved) headers['X-Device-Token'] = saved;

            let r = await fetch(`/api/channels/${encodeURIComponent(deviceCode)}/${encodeURIComponent(channelId)}`,
                { method: 'PATCH', headers, credentials: 'include', body: JSON.stringify({ name: newName }) });

            if ((r.status === 401 || r.status === 403) && !saved) {
                const t = (prompt('Este dispositivo requiere token para renombrar. Pégalo aquí:') || '').trim();
                if (t) {
                    saveToken(deviceCode, t);
                    r = await fetch(`/api/channels/${encodeURIComponent(deviceCode)}/${encodeURIComponent(channelId)}`,
                        { method: 'PATCH', headers: { ...headers, 'X-Device-Token': t }, credentials: 'include', body: JSON.stringify({ name: newName }) });
                }
            }
            if (!r.ok) return alert('No se pudo renombrar');
            await loadChannels();
            scheduleChartsRebuild();
        }

        document.getElementById('btnRenameHum')?.addEventListener('click', () => renameChannel(humChannelId, 'el sensor'));
        document.getElementById('btnRenameValve')?.addEventListener('click', () => renameChannel(valveChannelId, 'la válvula'));

        async function deleteChannelByIndex(kind, kindLabel) {
            const candidates = (channels || [])
                .filter(c => c && c.kind === kind)
                .filter(c => Number(c.channel_index) !== 1);

            if (!candidates.length) {
                alert(`No hay ${kindLabel}s añadidos para eliminar.`);
                return;
            }

            const indices = candidates.map(c => Number(c.channel_index)).filter(n => Number.isFinite(n)).sort((a,b) => a-b);
            const raw = prompt(`Índice de ${kindLabel} a eliminar (disponibles: ${indices.join(', ')}):`);
            if (raw === null) return; // Cancel
            const idx = Number(String(raw).trim());
            if (!Number.isInteger(idx)) return;

            const target = candidates.find(c => Number(c.channel_index) === idx);
            if (!target) {
                alert('Índice no encontrado.');
                return;
            }

            if (!confirm(`¿Eliminar ${kindLabel} ${idx}? Se borrará también su histórico.`)) return;

            const doDelete = async (headers) => {
                return fetch(`/api/channels/${encodeURIComponent(deviceCode)}/${encodeURIComponent(target.id)}`,
                    { method: 'DELETE', headers, credentials: 'include' });
            };

            const baseHeaders = { 'Content-Type': 'application/json' };
            const saved = (getSavedToken(deviceCode) || '').trim();
            const headers1 = { ...baseHeaders };
            if (saved) headers1['X-Device-Token'] = saved;

            let r = await doDelete(headers1);

            if ((r.status === 401 || r.status === 403) && !saved) {
                const tRaw = prompt('Este dispositivo requiere token para eliminar. Pégalo aquí:');
                if (tRaw === null) return; // Cancel
                const t = String(tRaw || '').trim();
                if (t) {
                    saveToken(deviceCode, t);
                    r = await doDelete({ ...baseHeaders, 'X-Device-Token': t });
                }
            }

            const j = await r.json().catch(() => ({}));
            if (!r.ok) {
                alert(j.error || `No se pudo eliminar ${kindLabel}`);
                return;
            }

            await loadChannels();
            scheduleChartsRebuild();
            alert(`${kindLabel} eliminado.`);
        }

        document.getElementById('btnDeleteHum')?.addEventListener('click', () => deleteChannelByIndex('soil_sensor', 'sensor'));
        document.getElementById('btnDeleteValve')?.addEventListener('click', () => deleteChannelByIndex('valve', 'válvula'));

        document.getElementById('btnDeleteDevice')?.addEventListener('click', async () => {
            if (!confirm(`¿Quitar el dispositivo ${deviceCode} de tu cuenta?`)) return;
            const r = await fetch(`/api/devices/${encodeURIComponent(deviceCode)}`, { method: 'DELETE', credentials: 'include' });
            const j = await r.json().catch(() => ({}));
            if (!r.ok) {
                alert(j.error || 'No se pudo eliminar el dispositivo');
                return;
            }
            location.href = '/app';
        });

        document.getElementById('resetRebootsBtn')?.addEventListener('click', async () => {
            if (!confirm('¿Poner el contador de reinicios a 0 (solo en el panel web)?')) return;
            if (lastRebootsBase == null) {
                alert('Aún no hay datos de reinicios para este dispositivo');
                return;
            }

            // Reset local (sin token): guardamos un offset por dispositivo
            setLocalRebootsOffset(deviceCode, lastRebootsBase);
            actualizarSensores();

            // Best-effort: si el backend admite reset sin auth, lo intentamos, pero nunca pedimos token.
            try {
                await fetch(`/api/device/reboots/reset/${encodeURIComponent(deviceCode)}`, { method: 'POST' });
            } catch {}
        });
    </script>
</body>
</html>
