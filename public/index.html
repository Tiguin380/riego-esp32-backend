<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Riego Automatico</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: Arial, sans-serif; background: #1a1a2e; color: #eee; padding: 16px; min-height: 100vh; }
        .container { width: 100%; max-width: none; margin: 0; }
        h1 { color: #4CAF50; margin-bottom: 20px; text-align: center; font-size: 28px; }
        .section { background: #16213e; padding: 20px; border-radius: 12px; margin-bottom: 20px; }
        .section h2 { color: #4CAF50; font-size: 16px; margin-bottom: 15px; border-bottom: 1px solid #333; padding-bottom: 10px; }
        /* Rejilla responsive: evita que en móvil se “salgan” las tarjetas */
        .sensor-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 15px; }
        .sensor-card { background: #0f3460; padding: 15px; border-radius: 8px; text-align: center; min-width: 0; border: 1px solid rgba(255,255,255,0.06); box-shadow: 0 10px 26px rgba(0,0,0,0.25); transition: transform 0.12s ease, border-color 0.12s ease, box-shadow 0.12s ease; }
        .sensor-card:hover { transform: translateY(-1px); border-color: rgba(255,255,255,0.12); box-shadow: 0 14px 32px rgba(0,0,0,0.30); }
        .sensor-label { font-size: 11px; color: #888; text-transform: uppercase; margin-bottom: 5px; }
        .sensor-value { font-size: clamp(22px, 6vw, 32px); font-weight: bold; color: #4CAF50; }
        .sensor-unit { font-size: 14px; color: #666; }

        /* Estado visual para métricas (voltaje/RSSI/uptime/reinicios) */
        .metric-good .sensor-value { color: #33cc33; }
        .metric-warn .sensor-value { color: #ffcc00; }
        .metric-bad  .sensor-value { color: #ff4d4d; }
        .metric-neutral .sensor-value { color: #aaa; }

        .metric-good { border-color: rgba(51,204,51,0.25); box-shadow: 0 12px 28px rgba(51,204,51,0.08), 0 10px 26px rgba(0,0,0,0.25); }
        .metric-warn { border-color: rgba(255,204,0,0.25); box-shadow: 0 12px 28px rgba(255,204,0,0.08), 0 10px 26px rgba(0,0,0,0.25); }
        .metric-bad  { border-color: rgba(255,77,77,0.30); box-shadow: 0 12px 28px rgba(255,77,77,0.10), 0 10px 26px rgba(0,0,0,0.25); }
        .metric-neutral { border-color: rgba(255,255,255,0.08); }
        .valve-indicator { display: flex; align-items: center; justify-content: center; gap: 10px; margin-top: 8px; flex-wrap: wrap; }
        .valve-dot { width: 14px; height: 14px; border-radius: 50%; background: #666; box-shadow: 0 0 10px #000; }
        .valve-dot.on { background: #33cc33; box-shadow: 0 0 18px #33cc33; }
        .valve-dot.off { background: #ff3333; box-shadow: 0 0 18px #ff3333; }
        .valve-text { font-size: 14px; font-weight: bold; color: #ddd; max-width: 100%; overflow: hidden; text-overflow: ellipsis; }
        .leds-container { display: flex; justify-content: center; gap: 15px; margin: 20px 0; }
        .led { width: 40px; height: 40px; border-radius: 50%; border: 3px solid #333; transition: all 0.3s; }
        .control-row { display: flex; gap: 10px; margin-bottom: 15px; align-items: center; }
        .control-row label { flex: 1; color: #aaa; }
        .control-row input, .control-row select { flex: 2; padding: 10px; border: none; border-radius: 6px; background: #0f3460; color: #fff; font-size: 14px; }
        .control-row input[type="range"] { -webkit-appearance: none; appearance: none; height: 8px; }
        .control-row input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 20px; height: 20px; background: #4CAF50; border-radius: 50%; cursor: pointer; }
        .btn-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin: 15px 0; }
        .btn { padding: 12px 8px; border: none; border-radius: 8px; cursor: pointer; font-weight: bold; font-size: 12px; transition: transform 0.1s, opacity 0.2s; }
        .btn:hover { transform: scale(1.05); }
        .btn:active { transform: scale(0.95); }
        .btn-rojo { background: #ff3333; color: white; }
        .btn-verde { background: #33cc33; color: white; }
        .btn-azul { background: #3366ff; color: white; }
        .btn-amarillo { background: #ffcc00; color: black; }
        .btn-cian { background: #00cccc; color: black; }
        .btn-magenta { background: #cc33cc; color: white; }
        .btn-blanco { background: #ffffff; color: black; }
        .btn-off { background: #333; color: #888; }
        .btn-save { background: #4CAF50; color: white; width: 100%; padding: 15px; font-size: 16px; margin-top: 10px; }
        .status { text-align: center; font-size: 12px; color: #666; margin-top: 15px; }
        .status.online { color: #4CAF50; }
        .status.offline { color: #ff3333; }
        .current-color { text-align: center; padding: 10px; background: #0f3460; border-radius: 8px; margin: 10px 0; }
        .current-color span { font-weight: bold; color: #4CAF50; }
        /* Gráficas sin scroll: se ajustan al espacio disponible */
        .charts-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
        @media (max-width: 900px) {
            .charts-grid { grid-template-columns: 1fr; }
        }
        .chart-box { text-align: left; min-width: 0; }
        .chart-wrap { position: relative; width: 100%; height: clamp(160px, 24vh, 260px); }
        .chart-wrap canvas { width: 100% !important; height: 100% !important; display: block; }
        .btn.active { outline: 2px solid rgba(255,255,255,0.35); opacity: 0.95; }
        .summary { display:flex; justify-content:space-between; gap: 12px; flex-wrap: wrap; margin: 8px 0 0; }
        .summary .k { color: #888; font-size: 11px; text-transform: uppercase; }
        .summary .v { color: #ddd; font-weight: bold; }

        .mini-btn { background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.14); color: #ddd; padding: 6px 10px; border-radius: 8px; cursor: pointer; font-size: 12px; }
        .mini-btn:hover { background: rgba(255,255,255,0.12); }
        .mini-btn.danger { border-color: rgba(255,77,77,0.35); color: #ffb3b3; }
        .mini-btn.primary { border-color: rgba(76,175,80,0.35); color: #b8f5c1; }
    </style>
</head>
<body>
    <div class="container">
        <h1> Riego Automatico ESP32</h1>
        <div class="status" style="margin-bottom: 12px;">UI v2026-01-28</div>

        <div class="section" id="deviceSection" style="padding: 14px 20px;">
            <h2> DISPOSITIVO</h2>
            <div class="control-row" style="margin-bottom: 0;">
                <label>Seleccionar:</label>
                <select id="deviceSelect" title="Seleccionar dispositivo"></select>
            </div>
            <div style="display:flex; gap: 10px; margin-top: 10px; flex-wrap: wrap;">
                <button class="mini-btn primary" id="btnAddDevice" type="button">+ Añadir dispositivo</button>
                <button class="mini-btn" id="btnAddValve" type="button">+ Añadir válvula</button>
                <button class="mini-btn" id="btnAddSensor" type="button">+ Añadir sensor humedad</button>
            </div>
            <div class="status" style="margin-top: 10px;" id="deviceMeta">--</div>
        </div>
        <div class="section">
            <h2> SENSORES EN TIEMPO REAL</h2>
            <div class="sensor-grid">
                <div class="sensor-card">
                    <div class="sensor-label">Temperatura</div>
                    <div class="sensor-value" id="temp">--</div>
                    <div class="sensor-unit">C</div>
                </div>
                <div class="sensor-card">
                    <div class="sensor-label">Humedad</div>
                    <div class="sensor-value" id="humidity">--</div>
                    <div class="sensor-unit">%</div>
                </div>
                <div class="sensor-card">
                    <div class="sensor-label">Válvula</div>
                    <div class="sensor-value" id="valve">--</div>
                    <div class="valve-indicator">
                        <div class="valve-dot" id="valveDot"></div>
                        <div class="valve-text" id="valveText">--</div>
                    </div>
                </div>
                <div class="sensor-card">
                    <div class="sensor-label">Voltaje</div>
                    <div class="sensor-value" id="voltage">--</div>
                    <div class="sensor-unit">V</div>
                </div>
                <div class="sensor-card">
                    <div class="sensor-label">WiFi RSSI</div>
                    <div class="sensor-value" id="rssi">--</div>
                    <div class="sensor-unit">dBm</div>
                </div>
                <div class="sensor-card">
                    <div class="sensor-label">Umbral Humedad Baja</div>
                    <div class="sensor-value" id="uptime">--</div>
                    <div class="sensor-unit">%</div>
                </div>
                <div class="sensor-card">
                    <div class="sensor-label">Reinicios</div>
                    <div class="sensor-value" id="reboots">--</div>
                    <div class="sensor-unit">#</div>
                    <div style="margin-top: 10px;">
                        <button class="mini-btn danger" id="resetRebootsBtn" type="button">Reset a 0</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="section">
            <h2> GRÁFICAS EN TIEMPO REAL</h2>
            <div style="display:flex; align-items:center; justify-content:space-between; gap: 12px; flex-wrap: wrap; margin: 4px 0 8px;">
                <div>
                    <div class="sensor-label">FECHA / HORA (ESPAÑA)</div>
                    <div style="font-size: 18px; font-weight: bold; color: #ddd;" id="nowEs">--</div>
                </div>
                <div style="display:flex; gap: 10px; align-items:center; flex-wrap: wrap; justify-content:flex-end;">
                    <button class="btn btn-azul" id="btnDia" type="button">DÍA</button>
                    <button class="btn btn-azul" id="btnMes" type="button">MES</button>
                    <button class="btn btn-azul" id="btnAno" type="button">AÑO</button>
                </div>
            </div>

            <div style="display:flex; gap: 12px; align-items:flex-end; flex-wrap: wrap; margin: 10px 0 6px;">
                <div style="min-width: 220px; flex: 1;">
                    <div class="sensor-label">Sensor de humedad (gráfica)</div>
                    <select id="humChannelSelect" title="Seleccionar sensor de humedad"></select>
                    <div style="margin-top: 8px; display:flex; gap: 8px;">
                        <button class="mini-btn" id="btnRenameHum" type="button">Renombrar</button>
                    </div>
                </div>
                <div style="min-width: 220px; flex: 1;">
                    <div class="sensor-label">Válvula (gráfica)</div>
                    <select id="valveChannelSelect" title="Seleccionar válvula"></select>
                    <div style="margin-top: 8px; display:flex; gap: 8px;">
                        <button class="mini-btn" id="btnRenameValve" type="button">Renombrar</button>
                    </div>
                </div>
            </div>
            <div class="summary">
                <div>
                    <div class="k" id="periodLabel">Periodo</div>
                    <div class="v" id="periodValue">--</div>
                </div>
                <div>
                    <div class="k">Media Humedad</div>
                    <div class="v" id="avgHumidity">--</div>
                </div>
                <div>
                    <div class="k">Tiempo Válvula ON</div>
                    <div class="v" id="totalValveOn">--</div>
                </div>
            </div>
            <div class="charts-grid">
                <div class="sensor-card chart-box">
                    <div class="sensor-label">Humedad del suelo (%)</div>
                    <div class="chart-wrap">
                        <canvas id="humChart"></canvas>
                    </div>
                </div>
                <div class="sensor-card chart-box">
                    <div class="sensor-label">Válvula (ON/OFF) + tiempo activa</div>
                    <div style="display:flex; justify-content:space-between; align-items:center; gap: 10px; margin: 8px 0 6px;">
                        <div class="valve-indicator" style="margin-top: 0; justify-content:flex-start;">
                            <div class="valve-dot" id="valveDotChart"></div>
                            <div class="valve-text" id="valveTextChart">--</div>
                        </div>
                        <div class="sensor-unit" id="valveOnTime">Tiempo ON: --</div>
                    </div>
                    <div class="chart-wrap">
                        <canvas id="valveChart"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <div class="section">
            <h2> CONFIGURACIÓN AUTOMÁTICA</h2>
            <div class="control-row">
                <label>Umbral Humedad Baja:</label>
                <input type="range" id="threshold" min="1" max="100" value="25" title="Umbral de humedad baja">
                <span id="thresholdValue" style="width:50px;text-align:right">25%</span>
            </div>
            <div class="control-row">
                <label>Color si Humedad BAJA:</label>
                <select id="colorBuena" title="Color si humedad baja">
                    <option value="Rojo">Rojo</option>
                    <option value="Verde">Verde</option>
                    <option value="Azul">Azul</option>
                    <option value="Amarillo">Amarillo</option>
                    <option value="Cian">Cian</option>
                    <option value="Magenta">Magenta</option>
                    <option value="Blanco">Blanco</option>
                </select>
            </div>
            <div class="control-row">
                <label>Color si Humedad BUENA:</label>
                <select id="colorBaja" title="Color si humedad buena">
                    <option value="Rojo">Rojo</option>
                    <option value="Verde" selected>Verde</option>
                    <option value="Azul">Azul</option>
                    <option value="Amarillo">Amarillo</option>
                    <option value="Cian">Cian</option>
                    <option value="Magenta">Magenta</option>
                    <option value="Blanco">Blanco</option>
                </select>
            </div>
            <div class="control-row">
                <label>Calibración WET_V (V):</label>
                <input id="wetV" type="number" step="0.001" placeholder="ej: 1.10" />
            </div>
            <div class="control-row">
                <label>Calibración DRY_V (V):</label>
                <input id="dryV" type="number" step="0.001" placeholder="ej: 2.60" />
            </div>
            <div class="control-row">
                <label>Alerta: Humedad baja (min):</label>
                <input id="alertHumLowMin" type="number" min="0" step="1" placeholder="0 = desactivado" />
            </div>
            <div class="control-row">
                <label>Alerta: Válvula ON máx (min):</label>
                <input id="alertValveMaxMin" type="number" min="0" step="1" placeholder="0 = desactivado" />
            </div>
            <div class="control-row">
                <label>Alerta: Sensor muerto (min):</label>
                <input id="alertDeadMin" type="number" min="0" step="1" placeholder="0 = desactivado" />
            </div>
            <div class="control-row">
                <label>Alerta: Voltaje mín (V):</label>
                <input id="alertVmin" type="number" step="0.01" placeholder="vacío = desactivado" />
            </div>
            <div class="control-row">
                <label>Alerta: Voltaje máx (V):</label>
                <input id="alertVmax" type="number" step="0.01" placeholder="vacío = desactivado" />
            </div>
            <div class="control-row">
                <label>Webhook (URL):</label>
                <input id="notifyWebhook" type="url" placeholder="https://..." />
            </div>
            <div class="control-row">
                <label>Telegram Chat ID:</label>
                <input id="notifyTelegram" type="text" placeholder="123456789" />
            </div>
            <button class="btn btn-save" onclick="guardar()"> GUARDAR CONFIGURACION</button>
        </div>

        <div class="section">
            <h2> ALERTAS</h2>
            <div class="status" id="alertsStatus">--</div>
            <div id="alertsList" style="margin-top: 10px; display:flex; flex-direction:column; gap: 8px;"></div>
        </div>

        <div class="status" id="status">Conectando...</div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script>
        let config = { threshold: 25, colorB: 'Rojo', colorG: 'Verde' };

        let channels = [];
        let humChannelId = null;
        let valveChannelId = null;

        let lastRebootsBase = null;

        function rebootsOffsetKey(code) { return `rebootsOffset:${code}`; }
        function getLocalRebootsOffset(code) {
            try {
                const v = localStorage.getItem(rebootsOffsetKey(code));
                if (v == null || v === '') return 0;
                const n = Number(v);
                return Number.isFinite(n) && n >= 0 ? n : 0;
            } catch { return 0; }
        }
        function setLocalRebootsOffset(code, offset) {
            try { localStorage.setItem(rebootsOffsetKey(code), String(Math.max(0, Number(offset) || 0))); } catch {}
        }

        let chartsRebuildTimer = null;
        function scheduleChartsRebuild() {
            if (chartsRebuildTimer) return;
            chartsRebuildTimer = setTimeout(() => {
                chartsRebuildTimer = null;
                rebuildCharts();
            }, 1200);
        }

        const DEFAULT_DEVICE = 'RIEGO_001';
        let deviceCode = (() => {
            const m = location.pathname.match(/\/panel\/([^\/?#]+)/);
            return m ? decodeURIComponent(m[1]) : DEFAULT_DEVICE;
        })();

        function tokenStorageKey(code) { return `deviceToken:${code}`; }
        function getSavedToken(code) {
            try { return localStorage.getItem(tokenStorageKey(code)) || ''; } catch { return ''; }
        }
        function saveToken(code, token) {
            try { localStorage.setItem(tokenStorageKey(code), token || ''); } catch {}
        }

        function consumeTokenFromUrl() {
            try {
                const params = new URLSearchParams(location.search);
                const t = (params.get('token') || params.get('t') || '').trim();
                if (!t) return;
                saveToken(deviceCode, t);
                params.delete('token');
                params.delete('t');
                const qs = params.toString();
                const next = location.pathname + (qs ? `?${qs}` : '') + location.hash;
                history.replaceState({}, '', next);
            } catch {}
        }

        consumeTokenFromUrl();

        async function loadDevices() {
            const section = document.getElementById('deviceSection');
            const select = document.getElementById('deviceSelect');
            const meta = document.getElementById('deviceMeta');
            try {
                const r = await fetch('/api/devices');
                const list = await r.json();
                if (!Array.isArray(list) || list.length === 0) throw new Error('Sin lista');

                select.innerHTML = '';
                for (const d of list) {
                    const opt = document.createElement('option');
                    opt.value = d.device_code;
                    opt.textContent = `${d.device_code} — ${d.name || ''}`.trim();
                    select.appendChild(opt);
                }

                const exists = list.some(d => d.device_code === deviceCode);
                if (!exists) {
                    deviceCode = list[0].device_code;
                    history.replaceState({}, '', `/panel/${encodeURIComponent(deviceCode)}`);
                }
                select.value = deviceCode;

                const current = list.find(d => d.device_code === deviceCode);
                const lastSeen = current?.last_seen_madrid || (current?.last_seen ? new Date(current.last_seen).toLocaleString('es-ES', { timeZone: TZ, hour12: false }) : '--');
                meta.textContent = `${current?.name || deviceCode}${current?.location ? ' · ' + current.location : ''} · Último dato: ${lastSeen}`;

                select.addEventListener('change', () => {
                    const next = select.value;
                    if (next && next !== deviceCode) window.location.href = `/panel/${encodeURIComponent(next)}`;
                });

            } catch {
                if (section) section.style.display = 'none';
            }
        }

        async function loadChannels() {
            try {
                const r = await fetch(`/api/channels/${encodeURIComponent(deviceCode)}`);
                if (!r.ok) throw new Error('channels failed');
                const j = await r.json();
                channels = Array.isArray(j.channels) ? j.channels : [];

                const hums = channels.filter(c => c.kind === 'soil_sensor');
                const valves = channels.filter(c => c.kind === 'valve');

                const humSel = document.getElementById('humChannelSelect');
                const valveSel = document.getElementById('valveChannelSelect');
                humSel.innerHTML = '';
                valveSel.innerHTML = '';

                for (const c of hums) {
                    const opt = document.createElement('option');
                    opt.value = c.id;
                    opt.textContent = `${c.name} (${c.channel_index})`;
                    humSel.appendChild(opt);
                }
                for (const c of valves) {
                    const opt = document.createElement('option');
                    opt.value = c.id;
                    opt.textContent = `${c.name} (${c.channel_index})`;
                    valveSel.appendChild(opt);
                }

                if (!humChannelId || !hums.some(c => c.id === humChannelId)) humChannelId = hums[0]?.id || null;
                if (!valveChannelId || !valves.some(c => c.id === valveChannelId)) valveChannelId = valves[0]?.id || null;

                humSel.value = humChannelId || '';
                valveSel.value = valveChannelId || '';

                humSel.onchange = () => { humChannelId = humSel.value || null; scheduleChartsRebuild(); };
                valveSel.onchange = () => { valveChannelId = valveSel.value || null; scheduleChartsRebuild(); };

                const renameHumBtn = document.getElementById('btnRenameHum');
                const renameValveBtn = document.getElementById('btnRenameValve');
                if (renameHumBtn) renameHumBtn.disabled = hums.length === 0;
                if (renameValveBtn) renameValveBtn.disabled = valves.length === 0;

                // Si no hay canales, ocultar gráficas (pero normalmente habrá canal 1 por defecto)
                document.getElementById('humChannelSelect').disabled = hums.length === 0;
                document.getElementById('valveChannelSelect').disabled = valves.length === 0;

            } catch (e) {
                // Si falla, no rompemos
            }
        }

        // --- Zona horaria España (Europe/Madrid) ---
        const TZ = 'Europe/Madrid';
        const fmtNowEs = new Intl.DateTimeFormat('es-ES', {
            timeZone: TZ,
            year: 'numeric', month: '2-digit', day: '2-digit',
            hour: '2-digit', minute: '2-digit', second: '2-digit',
            hour12: false
        });
        const fmtDateEs = new Intl.DateTimeFormat('es-ES', {
            timeZone: TZ,
            year: 'numeric', month: '2-digit', day: '2-digit'
        });

        function getMadridParts(date) {
            const parts = new Intl.DateTimeFormat('sv-SE', {
                timeZone: TZ,
                year: 'numeric', month: '2-digit', day: '2-digit',
                hour: '2-digit', minute: '2-digit',
                hourCycle: 'h23'
            }).formatToParts(date);
            const m = Object.fromEntries(parts.map(p => [p.type, p.value]));
            return { y: m.year, mo: m.month, d: m.day, h: m.hour, mi: m.minute };
        }

        function getMadridPartsFull(date) {
            const parts = new Intl.DateTimeFormat('sv-SE', {
                timeZone: TZ,
                year: 'numeric', month: '2-digit', day: '2-digit',
                hour: '2-digit', minute: '2-digit', second: '2-digit',
                hourCycle: 'h23'
            }).formatToParts(date);
            const m = Object.fromEntries(parts.map(p => [p.type, p.value]));
            return { y: m.year, mo: m.month, d: m.day, h: m.hour, mi: m.minute, s: m.second };
        }

        function parseTsToDate(ts) {
            if (ts == null) return null;
            if (ts instanceof Date) return ts;
            if (typeof ts === 'number') {
                // Heurística: si viene en segundos (muy pequeño), convertir a ms
                const ms = ts < 1e12 ? ts * 1000 : ts;
                const d = new Date(ms);
                return Number.isNaN(d.getTime()) ? null : d;
            }
            const d = new Date(String(ts));
            return Number.isNaN(d.getTime()) ? null : d;
        }
        function pad2(n) { return String(n).padStart(2, '0'); }
        function formatUptimeSeconds(sec) {
            const n = Number(sec);
            if (!Number.isFinite(n) || n < 0) return '--';
            return formatDuration(n * 1000);
        }
        function formatDuration(ms) {
            const s = Math.floor(ms / 1000);
            const hh = Math.floor(s / 3600);
            const mm = Math.floor((s % 3600) / 60);
            const ss = s % 60;
            if (hh > 0) return `${hh}h ${pad2(mm)}m ${pad2(ss)}s`;
            if (mm > 0) return `${mm}m ${pad2(ss)}s`;
            return `${ss}s`;
        }

        function setMetricStateById(valueId, state, title) {
            const valueEl = document.getElementById(valueId);
            const card = valueEl ? valueEl.closest('.sensor-card') : null;
            if (!card) return;
            card.classList.remove('metric-good', 'metric-warn', 'metric-bad', 'metric-neutral');
            card.classList.add(state);
            if (title) card.title = title;
        }

        function updateThresholdCard() {
            const el = document.getElementById('uptime');
            if (!el) return;
            const t = Number(config.threshold);
            el.textContent = Number.isFinite(t) ? String(Math.round(t)) : '--';
            // Colorear el valor del umbral para que destaque
            // (bajo = verde, medio = amarillo, alto = rojo)
            if (!Number.isFinite(t)) {
                setMetricStateById('uptime', 'metric-neutral', 'Umbral de humedad baja configurado');
            } else if (t <= 30) {
                setMetricStateById('uptime', 'metric-good', 'Umbral bajo');
            } else if (t <= 50) {
                setMetricStateById('uptime', 'metric-warn', 'Umbral medio');
            } else {
                setMetricStateById('uptime', 'metric-bad', 'Umbral alto');
            }
        }

        // --- Persistencia ("datos que va recibiendo") ---
        const STORE_KEY = 'riego_stats_v1';
        function loadStore() {
            try {
                const raw = localStorage.getItem(STORE_KEY);
                if (!raw) return { minutes: {}, days: {}, months: {}, last: null };
                const obj = JSON.parse(raw);
                return {
                    minutes: obj.minutes || {},
                    days: obj.days || {},
                    months: obj.months || {},
                    last: obj.last || null
                };
            } catch {
                return { minutes: {}, days: {}, months: {}, last: null };
            }
        }
        function saveStore(store) {
            localStorage.setItem(STORE_KEY, JSON.stringify(store));
        }
        function ensureBucket(map, key) {
            if (!map[key]) map[key] = { humSum: 0, humCount: 0, valveOnMs: 0 };
            return map[key];
        }
        function pruneStore(store) {
            const dayKeys = Object.keys(store.days).sort();
            if (dayKeys.length > 370) {
                for (let i = 0; i < dayKeys.length - 370; i++) delete store.days[dayKeys[i]];
            }
            const monthKeys = Object.keys(store.months).sort();
            if (monthKeys.length > 36) {
                for (let i = 0; i < monthKeys.length - 36; i++) delete store.months[monthKeys[i]];
            }
            // minutes: mantener últimos 2 días (según keys de days)
            const keepDays = new Set(dayKeys.slice(-2));
            const minuteKeys = Object.keys(store.minutes);
            for (const mk of minuteKeys) {
                const dayPart = mk.slice(0, 10);
                if (!keepDays.has(dayPart)) delete store.minutes[mk];
            }
        }
        function ingestSample(store, sampleMs, humidity, valveIsOn) {
            const now = new Date(sampleMs);
            const p = getMadridParts(now);
            const dayKey = `${p.y}-${p.mo}-${p.d}`;
            const monthKey = `${p.y}-${p.mo}`;
            const minuteKey = `${dayKey}T${p.h}:${p.mi}`;

            // Tiempo ON entre muestras (usamos el estado anterior)
            let dt = 0;
            if (store.last && typeof store.last.t === 'number') {
                dt = Math.max(0, sampleMs - store.last.t);
            }
            const prevOn = store.last ? !!store.last.on : false;
            const onMs = prevOn ? dt : 0;

            const bMin = ensureBucket(store.minutes, minuteKey);
            const bDay = ensureBucket(store.days, dayKey);
            const bMonth = ensureBucket(store.months, monthKey);

            bMin.valveOnMs += onMs;
            bDay.valveOnMs += onMs;
            bMonth.valveOnMs += onMs;

            if (!Number.isNaN(humidity)) {
                bMin.humSum += humidity; bMin.humCount += 1;
                bDay.humSum += humidity; bDay.humCount += 1;
                bMonth.humSum += humidity; bMonth.humCount += 1;
            }

            store.last = { t: sampleMs, on: !!valveIsOn };
            pruneStore(store);
            saveStore(store);
        }

        // --- Modo de visualización ---
        let viewMode = 'day'; // day | month | year
        function setActiveModeButtons(mode) {
            document.getElementById('btnDia').classList.toggle('active', mode === 'day');
            document.getElementById('btnMes').classList.toggle('active', mode === 'month');
            document.getElementById('btnAno').classList.toggle('active', mode === 'year');
        }
        setActiveModeButtons(viewMode);

        document.getElementById('btnDia').addEventListener('click', () => { viewMode = 'day'; setActiveModeButtons(viewMode); rebuildCharts(); });
        document.getElementById('btnMes').addEventListener('click', () => { viewMode = 'month'; setActiveModeButtons(viewMode); rebuildCharts(); });
        document.getElementById('btnAno').addEventListener('click', () => { viewMode = 'year'; setActiveModeButtons(viewMode); rebuildCharts(); });

        // --- Datos para Chart.js ---
        const humLabels = [];
        const humSeries = [];
        const valveLabels = [];
        const valveSeries = [];
        function setSeries(labels, series, newLabels, newSeries) {
            labels.length = 0;
            series.length = 0;
            for (const x of newLabels) labels.push(x);
            for (const y of newSeries) series.push(y);
        }

        const humChart = new Chart(document.getElementById('humChart'), {
            type: 'line',
            data: {
                labels: humLabels,
                datasets: [{
                    label: 'Humedad (%)',
                    data: humSeries,
                    borderColor: '#4CAF50',
                    backgroundColor: 'rgba(76, 175, 80, 0.15)',
                    fill: true,
                    tension: 0.25,
                    pointRadius: 0
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                plugins: { legend: { display: false } },
                scales: {
                    y: { min: 0, max: 100, ticks: { color: '#aaa' }, grid: { color: 'rgba(255,255,255,0.06)' } },
                    x: { ticks: { color: '#888', maxTicksLimit: 6 }, grid: { color: 'rgba(255,255,255,0.04)' } }
                }
            }
        });

        const valveChart = new Chart(document.getElementById('valveChart'), {
            type: 'line',
            data: {
                labels: valveLabels,
                datasets: [{
                    label: 'Válvula (0/1)',
                    data: valveSeries,
                    borderColor: '#33cc33',
                    backgroundColor: 'rgba(51, 204, 51, 0.12)',
                    fill: true,
                    stepped: true,
                    tension: 0,
                    pointRadius: 0
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                plugins: { legend: { display: false } },
                scales: {
                    y: {
                        min: -0.1,
                        max: 1.1,
                        ticks: {
                            color: '#aaa',
                            callback: (v) => (v >= 0.5 ? 'ON' : 'OFF')
                        },
                        grid: { color: 'rgba(255,255,255,0.06)' }
                    },
                    x: { ticks: { color: '#888', maxTicksLimit: 6 }, grid: { color: 'rgba(255,255,255,0.04)' } }
                }
            }
        });

        function rebuildChartsFromStore(storeOpt) {
            const store = storeOpt || loadStore();
            const now = new Date();
            const p = getMadridParts(now);

            let labels = [];
            let hum = [];
            let valve = [];
            let totalHumSum = 0;
            let totalHumCount = 0;
            let totalValveOnMs = 0;

            if (viewMode === 'day') {
                document.getElementById('periodLabel').textContent = 'Día';
                document.getElementById('periodValue').textContent = `${fmtDateEs.format(now)} (últimas 24h)`;

                const entries = Object.entries(store.minutes).sort((a, b) => a[0].localeCompare(b[0]));
                const last = entries.slice(-1440); // 24h * 60
                for (const [k, v] of last) {
                    const avg = v.humCount ? (v.humSum / v.humCount) : null;
                    // Mostrar DD HH:mm para que al cambiar de día se note
                    labels.push(`${k.slice(8, 10)} ${k.slice(11)}`);
                    hum.push(avg === null ? null : Number(avg.toFixed(2)));
                    const duty = Math.max(0, Math.min(1, (v.valveOnMs || 0) / 60000));
                    valve.push(Number(duty.toFixed(2)));
                    totalHumSum += v.humSum || 0;
                    totalHumCount += v.humCount || 0;
                    totalValveOnMs += v.valveOnMs || 0;
                }

                valveChart.options.scales.y.min = -0.1;
                valveChart.options.scales.y.max = 1.1;
                valveChart.options.scales.y.ticks.callback = (v) => (v >= 0.5 ? 'ON' : 'OFF');
                valveChart.data.datasets[0].label = 'Válvula (duty 0..1)';

            } else if (viewMode === 'month') {
                const monthKey = `${p.y}-${p.mo}`;
                document.getElementById('periodLabel').textContent = 'Mes';
                document.getElementById('periodValue').textContent = `${p.mo}/${p.y}`;

                const entries = Object.entries(store.days)
                    .filter(([k]) => k.startsWith(monthKey + '-'))
                    .sort((a, b) => a[0].localeCompare(b[0]));

                for (const [k, v] of entries) {
                    const avg = v.humCount ? (v.humSum / v.humCount) : null;
                    labels.push(k.slice(8, 10));
                    hum.push(avg === null ? null : Number(avg.toFixed(2)));
                    valve.push(Number(((v.valveOnMs || 0) / 3600000).toFixed(2))); // horas
                    totalHumSum += v.humSum || 0;
                    totalHumCount += v.humCount || 0;
                    totalValveOnMs += v.valveOnMs || 0;
                }

                valveChart.options.scales.y.min = 0;
                valveChart.options.scales.y.max = undefined;
                valveChart.options.scales.y.ticks.callback = undefined;
                valveChart.data.datasets[0].label = 'Válvula (horas ON/día)';

            } else {
                const yearKey = `${p.y}-`;
                document.getElementById('periodLabel').textContent = 'Año';
                document.getElementById('periodValue').textContent = `${p.y}`;

                const entries = Object.entries(store.months)
                    .filter(([k]) => k.startsWith(yearKey))
                    .sort((a, b) => a[0].localeCompare(b[0]));

                for (const [k, v] of entries) {
                    const avg = v.humCount ? (v.humSum / v.humCount) : null;
                    labels.push(k.slice(5, 7));
                    hum.push(avg === null ? null : Number(avg.toFixed(2)));
                    valve.push(Number(((v.valveOnMs || 0) / 3600000).toFixed(1))); // horas ON/mes
                    totalHumSum += v.humSum || 0;
                    totalHumCount += v.humCount || 0;
                    totalValveOnMs += v.valveOnMs || 0;
                }

                valveChart.options.scales.y.min = 0;
                valveChart.options.scales.y.max = undefined;
                valveChart.options.scales.y.ticks.callback = undefined;
                valveChart.data.datasets[0].label = 'Válvula (horas ON/mes)';
            }

            const avgHum = totalHumCount ? (totalHumSum / totalHumCount) : null;
            document.getElementById('avgHumidity').textContent = avgHum === null ? '--' : `${avgHum.toFixed(1)}%`;
            document.getElementById('totalValveOn').textContent = totalValveOnMs ? formatDuration(totalValveOnMs) : '--';
            document.getElementById('valveOnTime').textContent = `Tiempo ON (periodo): ${totalValveOnMs ? formatDuration(totalValveOnMs) : '--'}`;

            setSeries(humLabels, humSeries, labels, hum);
            setSeries(valveLabels, valveSeries, labels, valve);
            humChart.update('none');
            valveChart.update('none');

            const valveDotChart = document.getElementById('valveDotChart');
            const valveTextChart = document.getElementById('valveTextChart');
            if (store.last && store.last.on) {
                valveDotChart.className = 'valve-dot on';
                valveTextChart.textContent = 'ENCENDIDA';
            } else if (store.last) {
                valveDotChart.className = 'valve-dot off';
                valveTextChart.textContent = 'APAGADA';
            } else {
                valveDotChart.className = 'valve-dot';
                valveTextChart.textContent = 'SIN DATOS';
            }
        }

        function rangeForMode(mode) {
            const now = new Date();
            // DÍA: usar RAW para que se vea en tiempo real (segundos) y no “a saltos” por minuto.
            if (mode === 'day') return { from: null, to: null, step: 'raw', bucketMs: null };
            if (mode === 'month') return { from: new Date(now.getFullYear(), now.getMonth(), 1), to: now, step: '1h', bucketMs: 3600000 };
            return { from: new Date(now.getFullYear(), 0, 1), to: now, step: '1h', bucketMs: 3600000 }; // year
        }

        function dayKeyForTs(ts) {
            const p = getMadridParts(new Date(ts));
            return `${p.y}-${p.mo}-${p.d}`;
        }
        function monthKeyForTs(ts) {
            const p = getMadridParts(new Date(ts));
            return `${p.y}-${p.mo}`;
        }

        async function rebuildChartsFromServer() {
            // Para rendimiento: limitar puntos en DÍA (raw) y usar canales
            if (!humChannelId && !valveChannelId) throw new Error('no channels');

            const now = new Date();
            let step;
            let limit;
            if (viewMode === 'day') { step = 'raw'; limit = 1500; }
            else if (viewMode === 'month') { step = '1h'; limit = 2000; }
            else { step = '1h'; limit = 4000; }

            const baseHum = humChannelId ? `/api/channel/history/${encodeURIComponent(deviceCode)}/${encodeURIComponent(humChannelId)}?step=${encodeURIComponent(step)}&limit=${limit}` : null;
            const baseValve = valveChannelId ? `/api/channel/history/${encodeURIComponent(deviceCode)}/${encodeURIComponent(valveChannelId)}?step=${encodeURIComponent(step)}&limit=${limit}` : null;

            const [humRes, valveRes] = await Promise.all([
                baseHum ? fetch(baseHum) : Promise.resolve(null),
                baseValve ? fetch(baseValve) : Promise.resolve(null)
            ]);

            if (baseHum && (!humRes || !humRes.ok)) throw new Error('hum history failed');
            if (baseValve && (!valveRes || !valveRes.ok)) throw new Error('valve history failed');

            const humPayload = humRes ? await humRes.json() : { rows: [] };
            const valvePayload = valveRes ? await valveRes.json() : { rows: [] };

            const humRows = Array.isArray(humPayload.rows) ? humPayload.rows : [];
            const valveRows = Array.isArray(valvePayload.rows) ? valvePayload.rows : [];

            let labels = [];
            let hum = [];
            let valve = [];
            let totalHumSum = 0;
            let totalHumCount = 0;
            let totalValveOnMs = 0;

            if (viewMode === 'day') {
                document.getElementById('periodLabel').textContent = 'Día';
                const rangeTo = parseTsToDate(humPayload?.range?.to || valvePayload?.range?.to) || now;
                document.getElementById('periodValue').textContent = `${fmtDateEs.format(rangeTo)} (últimas 24h, tiempo real)`;

                // Unificar labels por timestamp: usamos los del sensor si existen, si no los de válvula.
                const labelSource = humRows.length ? humRows : valveRows;
                for (const r of labelSource) {
                    labels.push(r.ts_madrid_label || (r.ts_madrid || String(r.ts || '')));
                }

                // Serie humedad
                for (const r of humRows) {
                    const v = r.value == null ? null : Number(r.value);
                    hum.push(v == null || Number.isNaN(v) ? null : Number(v.toFixed(2)));
                    if (v != null && !Number.isNaN(v)) { totalHumSum += v; totalHumCount += 1; }
                }

                // Serie válvula + tiempo ON
                let prevT = null;
                let prevOn = false;
                for (const r of valveRows) {
                    const d = parseTsToDate(r.ts);
                    const onNow = Number(r.state || 0) >= 1;
                    valve.push(onNow ? 1 : 0);
                    const t = d ? d.getTime() : null;
                    if (t != null && prevT != null) {
                        const dt = Math.max(0, t - prevT);
                        if (prevOn) totalValveOnMs += dt;
                    }
                    prevT = t;
                    prevOn = onNow;
                }

                // Alinear longitudes (Chart.js agradece arrays consistentes)
                while (hum.length < labels.length) hum.push(null);
                while (valve.length < labels.length) valve.push(null);

                // Estado actual en tarjeta de la gráfica según el último valor del canal
                const valveDotChart = document.getElementById('valveDotChart');
                const valveTextChart = document.getElementById('valveTextChart');
                const lastV = valveRows.length ? valveRows[valveRows.length - 1] : null;
                if (lastV && Number(lastV.state || 0) >= 1) {
                    valveDotChart.className = 'valve-dot on';
                    valveTextChart.textContent = 'ENCENDIDA';
                } else if (lastV) {
                    valveDotChart.className = 'valve-dot off';
                    valveTextChart.textContent = 'APAGADA';
                } else {
                    valveDotChart.className = 'valve-dot';
                    valveTextChart.textContent = 'SIN DATOS';
                }

                valveChart.options.scales.y.min = -0.1;
                valveChart.options.scales.y.max = 1.1;
                valveChart.options.scales.y.ticks.callback = (v) => (v >= 0.5 ? 'ON' : 'OFF');
                valveChart.data.datasets[0].label = 'Válvula (0/1)';

            } else if (viewMode === 'month') {
                const pNow = getMadridParts(new Date());
                document.getElementById('periodLabel').textContent = 'Mes';
                document.getElementById('periodValue').textContent = `${pNow.mo}/${pNow.y}`;

                // En month/year, backend ya devuelve buckets por hora; agrupamos a días aquí (usando claves Madrid del backend)
                const byDayHum = {};
                for (const r of humRows) {
                    const k = r.ts_madrid_day_key || dayKeyForTs(r.ts);
                    const b = byDayHum[k] || (byDayHum[k] = { sum: 0, cnt: 0 });
                    const v = r.value == null ? null : Number(r.value);
                    if (v != null && !Number.isNaN(v)) { b.sum += v; b.cnt += 1; }
                }
                const byDayValve = {};
                for (const r of valveRows) {
                    const k = r.ts_madrid_day_key || dayKeyForTs(r.ts);
                    const b = byDayValve[k] || (byDayValve[k] = { on: 0, cnt: 0 });
                    const s = Number(r.state || 0) >= 1 ? 1 : 0;
                    b.on += s;
                    b.cnt += 1;
                }
                const keys = Array.from(new Set([...Object.keys(byDayHum), ...Object.keys(byDayValve)])).sort();
                for (const k of keys) {
                    labels.push(k.slice(8, 10));
                    const hB = byDayHum[k];
                    const vB = byDayValve[k];
                    const avg = hB && hB.cnt ? (hB.sum / hB.cnt) : null;
                    hum.push(avg == null ? null : Number(avg.toFixed(2)));
                    // Horas ON estimadas: (porcentaje de horas con state=1) * 24
                    const onHours = vB && vB.cnt ? (vB.on / vB.cnt) * 24 : 0;
                    valve.push(Number(onHours.toFixed(2)));
                    if (hB) { totalHumSum += hB.sum; totalHumCount += hB.cnt; }
                    if (vB) { totalValveOnMs += (vB.cnt ? (vB.on / vB.cnt) * 24 * 3600000 : 0); }
                }

                valveChart.options.scales.y.min = 0;
                valveChart.options.scales.y.max = undefined;
                valveChart.options.scales.y.ticks.callback = undefined;
                valveChart.data.datasets[0].label = 'Válvula (horas ON/día)';

            } else {
                const pNow = getMadridParts(new Date());
                document.getElementById('periodLabel').textContent = 'Año';
                document.getElementById('periodValue').textContent = `${pNow.y}`;

                const byMonthHum = {};
                for (const r of humRows) {
                    const k = r.ts_madrid_month_key || monthKeyForTs(r.ts);
                    const b = byMonthHum[k] || (byMonthHum[k] = { sum: 0, cnt: 0 });
                    const v = r.value == null ? null : Number(r.value);
                    if (v != null && !Number.isNaN(v)) { b.sum += v; b.cnt += 1; }
                }
                const byMonthValve = {};
                for (const r of valveRows) {
                    const k = r.ts_madrid_month_key || monthKeyForTs(r.ts);
                    const b = byMonthValve[k] || (byMonthValve[k] = { on: 0, cnt: 0 });
                    const s = Number(r.state || 0) >= 1 ? 1 : 0;
                    b.on += s;
                    b.cnt += 1;
                }
                const keys = Array.from(new Set([...Object.keys(byMonthHum), ...Object.keys(byMonthValve)])).sort();
                for (const k of keys) {
                    labels.push(k.slice(5, 7));
                    const hB = byMonthHum[k];
                    const vB = byMonthValve[k];
                    const avg = hB && hB.cnt ? (hB.sum / hB.cnt) : null;
                    hum.push(avg == null ? null : Number(avg.toFixed(2)));
                    const onHours = vB && vB.cnt ? (vB.on / vB.cnt) * (30 * 24) : 0; // aprox
                    valve.push(Number(onHours.toFixed(1)));
                    if (hB) { totalHumSum += hB.sum; totalHumCount += hB.cnt; }
                    if (vB) { totalValveOnMs += (vB.cnt ? (vB.on / vB.cnt) * (30 * 24) * 3600000 : 0); }
                }

                valveChart.options.scales.y.min = 0;
                valveChart.options.scales.y.max = undefined;
                valveChart.options.scales.y.ticks.callback = undefined;
                valveChart.data.datasets[0].label = 'Válvula (horas ON/mes)';
            }

            const avgHum = totalHumCount ? (totalHumSum / totalHumCount) : null;
            document.getElementById('avgHumidity').textContent = avgHum === null ? '--' : `${avgHum.toFixed(1)}%`;
            document.getElementById('totalValveOn').textContent = totalValveOnMs ? formatDuration(totalValveOnMs) : '--';
            document.getElementById('valveOnTime').textContent = `Tiempo ON (periodo): ${totalValveOnMs ? formatDuration(totalValveOnMs) : '--'}`;

            setSeries(humLabels, humSeries, labels, hum);
            setSeries(valveLabels, valveSeries, labels, valve);
            humChart.update('none');
            valveChart.update('none');
        }

        function rebuildCharts(storeOpt) {
            if (storeOpt) return rebuildChartsFromStore(storeOpt);
            rebuildChartsFromServer().catch(() => rebuildChartsFromStore());
        }

        function tickClock() {
            document.getElementById('nowEs').textContent = fmtNowEs.format(new Date());
        }
        tickClock();
        setInterval(tickClock, 1000);

        async function cargarConfig() {
            try {
                const res = await fetch(`/api/config/${encodeURIComponent(deviceCode)}`);
                const cfg = await res.json();

                let threshold = parseFloat(cfg.humidity_low_threshold);
                if (isNaN(threshold) || threshold < 1) threshold = 25;
                if (threshold > 100) threshold = 100;

                config.threshold = threshold;
                config.colorB = cfg.humidity_low_color || 'Rojo';
                config.colorG = cfg.humidity_good_color || 'Verde';

                const thresholdEl = document.getElementById('threshold');
                const thresholdValueEl = document.getElementById('thresholdValue');
                const colorBuenaEl = document.getElementById('colorBuena');
                const colorBajaEl = document.getElementById('colorBaja');

                thresholdEl.value = config.threshold;
                thresholdValueEl.textContent = config.threshold + '%';
                colorBuenaEl.value = config.colorB;
                colorBajaEl.value = config.colorG;

                updateThresholdCard();

                // Campos avanzados
                document.getElementById('wetV').value = (cfg.wet_v == null ? '' : cfg.wet_v);
                document.getElementById('dryV').value = (cfg.dry_v == null ? '' : cfg.dry_v);
                document.getElementById('alertHumLowMin').value = cfg.alert_humidity_low_minutes ?? 0;
                document.getElementById('alertValveMaxMin').value = cfg.alert_valve_on_max_minutes ?? 0;
                document.getElementById('alertDeadMin').value = cfg.alert_sensor_dead_minutes ?? 0;
                document.getElementById('alertVmin').value = (cfg.alert_voltage_min == null ? '' : cfg.alert_voltage_min);
                document.getElementById('alertVmax').value = (cfg.alert_voltage_max == null ? '' : cfg.alert_voltage_max);
                document.getElementById('notifyWebhook').value = (cfg.notify_webhook_url == null ? '' : cfg.notify_webhook_url);
                document.getElementById('notifyTelegram').value = (cfg.notify_telegram_chat_id == null ? '' : cfg.notify_telegram_chat_id);
            } catch (e) {
                console.log('Error cargando config');
            }
        }

        document.getElementById('threshold').addEventListener('input', (e) => {
            config.threshold = parseInt(e.target.value);
            document.getElementById('thresholdValue').textContent = config.threshold + '%';
            updateThresholdCard();
        });

        document.getElementById('colorBuena').addEventListener('change', (e) => {
            config.colorB = e.target.value;
        });

        document.getElementById('colorBaja').addEventListener('change', (e) => {
            config.colorG = e.target.value;
        });

        async function guardar() {
            try {
                const headersBase = { 'Content-Type': 'application/json' };

                const wetV = document.getElementById('wetV').value;
                const dryV = document.getElementById('dryV').value;
                const alertHumLowMin = document.getElementById('alertHumLowMin').value;
                const alertValveMaxMin = document.getElementById('alertValveMaxMin').value;
                const alertDeadMin = document.getElementById('alertDeadMin').value;
                const alertVmin = document.getElementById('alertVmin').value;
                const alertVmax = document.getElementById('alertVmax').value;
                const notifyWebhook = document.getElementById('notifyWebhook').value;
                const notifyTelegram = document.getElementById('notifyTelegram').value;

                const body = {
                    humidity_low_threshold: config.threshold,
                    humidity_low_color: config.colorB,
                    humidity_good_color: config.colorG,
                    wet_v: wetV === '' ? undefined : Number(wetV),
                    dry_v: dryV === '' ? undefined : Number(dryV),
                    alert_humidity_low_minutes: Number(alertHumLowMin || 0),
                    alert_valve_on_max_minutes: Number(alertValveMaxMin || 0),
                    alert_sensor_dead_minutes: Number(alertDeadMin || 0),
                    alert_voltage_min: alertVmin === '' ? null : Number(alertVmin),
                    alert_voltage_max: alertVmax === '' ? null : Number(alertVmax),
                    notify_webhook_url: notifyWebhook === '' ? null : String(notifyWebhook),
                    notify_telegram_chat_id: notifyTelegram === '' ? null : String(notifyTelegram)
                };

                async function doSave(headers) {
                    return fetch(`/api/config/${encodeURIComponent(deviceCode)}`, {
                        method: 'POST',
                        headers,
                        body: JSON.stringify(body)
                    });
                }

                const saved = (getSavedToken(deviceCode) || '').trim();
                const headers1 = { ...headersBase };
                if (saved) headers1['X-Device-Token'] = saved;

                let res = await doSave(headers1);

                if (res.status === 401 || res.status === 403) {
                    const msg = saved
                        ? 'Token guardado inválido o caducado. Pega el token correcto:'
                        : 'Este dispositivo requiere token para guardar. Pégalo aquí:';
                    const t = (prompt(msg) || '').trim();
                    if (t) {
                        saveToken(deviceCode, t);
                        const headers2 = { ...headersBase, 'X-Device-Token': t };
                        res = await doSave(headers2);
                    }
                }

                if (res.ok) {
                    alert(' Configuracion guardada!\nEl ESP32 aplicara los cambios en 10 segundos.');
                } else {
                    alert(' Error al guardar');
                }
            } catch (e) {
                alert(' Error de conexion');
            }
        }

        async function actualizarSensores() {
            try {
                const res = await fetch(`/api/sensor/latest/${encodeURIComponent(deviceCode)}`);
                const data = await res.json();
                
                document.getElementById('temp').textContent = parseFloat(data.temperature).toFixed(1);
                document.getElementById('humidity').textContent = parseFloat(data.humidity).toFixed(1);

                const v = (data.voltage == null ? null : Number(data.voltage));
                document.getElementById('voltage').textContent = (v == null || Number.isNaN(v) ? '--' : v.toFixed(2));

                const rssi = (data.wifi_rssi == null ? null : Number(data.wifi_rssi));
                document.getElementById('rssi').textContent = (rssi == null || Number.isNaN(rssi) ? '--' : String(Math.trunc(rssi)));

                const rbRaw = (data.reboot_count_display != null ? data.reboot_count_display : data.reboot_count);
                const rb = (rbRaw == null ? null : Number(rbRaw));
                lastRebootsBase = (rb == null || Number.isNaN(rb)) ? null : Math.trunc(rb);
                const localOffset = getLocalRebootsOffset(deviceCode);
                const rbShown = (lastRebootsBase == null) ? null : Math.max(0, lastRebootsBase - localOffset);
                document.getElementById('reboots').textContent = (rbShown == null ? '--' : String(Math.trunc(rbShown)));

                // Colores por umbral (valores típicos; además se respetan min/max de alertas si están configurados)
                const alertVminRaw = document.getElementById('alertVmin')?.value;
                const alertVmaxRaw = document.getElementById('alertVmax')?.value;
                const alertVmin = Number(alertVminRaw);
                const alertVmax = Number(alertVmaxRaw);
                const hasVmin = !!(alertVminRaw != null && alertVminRaw.trim() !== '' && Number.isFinite(alertVmin));
                const hasVmax = !!(alertVmaxRaw != null && alertVmaxRaw.trim() !== '' && Number.isFinite(alertVmax));
                if (v == null || Number.isNaN(v)) {
                    setMetricStateById('voltage', 'metric-neutral');
                } else if ((hasVmin && v < alertVmin) || (hasVmax && v > alertVmax)) {
                    setMetricStateById('voltage', 'metric-bad', `Fuera de rango (${hasVmin ? alertVmin : '-'} – ${hasVmax ? alertVmax : '-' } V)`);
                } else {
                    // fallback si no hay min/max
                    const st = v < 1.0 ? 'metric-bad' : (v < 1.8 ? 'metric-warn' : 'metric-good');
                    setMetricStateById('voltage', st);
                }

                if (rssi == null || Number.isNaN(rssi)) {
                    setMetricStateById('rssi', 'metric-neutral');
                } else {
                    const st = rssi >= -60 ? 'metric-good' : (rssi >= -75 ? 'metric-warn' : 'metric-bad');
                    setMetricStateById('rssi', st);
                }

                // Tarjeta "uptime" ahora muestra el umbral configurado
                updateThresholdCard();

                if (rbShown == null) {
                    setMetricStateById('reboots', 'metric-neutral');
                } else {
                    const st = rbShown === 0 ? 'metric-good' : (rbShown <= 2 ? 'metric-warn' : 'metric-bad');
                    setMetricStateById('reboots', st);
                }

                const rawValve = (data.valve_state || '').toString().toUpperCase();
                const isOn = rawValve === 'ON' || rawValve === '1' || rawValve === 'TRUE';
                const isOff = rawValve === 'OFF' || rawValve === '0' || rawValve === 'FALSE';
                const valveDot = document.getElementById('valveDot');
                const valveText = document.getElementById('valveText');
                const valveValue = document.getElementById('valve');

                if (isOn) {
                    valveDot.className = 'valve-dot on';
                    valveText.textContent = 'ENCENDIDA';
                    valveValue.textContent = 'ON';
                    valveValue.style.color = '#33cc33';
                } else if (isOff) {
                    valveDot.className = 'valve-dot off';
                    valveText.textContent = 'APAGADA';
                    valveValue.textContent = 'OFF';
                    valveValue.style.color = '#ff3333';
                } else {
                    valveDot.className = 'valve-dot';
                    valveText.textContent = 'SIN DATOS';
                    valveValue.textContent = '--';
                    valveValue.style.color = '#aaa';
                }

                const valveDotChart = document.getElementById('valveDotChart');
                const valveTextChart = document.getElementById('valveTextChart');
                if (isOn) {
                    valveDotChart.className = 'valve-dot on';
                    valveTextChart.textContent = 'ENCENDIDA';
                } else if (isOff) {
                    valveDotChart.className = 'valve-dot off';
                    valveTextChart.textContent = 'APAGADA';
                } else {
                    valveDotChart.className = 'valve-dot';
                    valveTextChart.textContent = 'SIN DATOS';
                }

                // --- Mantener el histórico local como fallback y refrescar gráficas del servidor ---
                try {
                    const now = new Date();
                    const nowMs = now.getTime();
                    const hum = Number.parseFloat(data.humidity);
                    const valveVal = isOn ? 1 : (isOff ? 0 : null);
                    const store = loadStore();
                    ingestSample(store, nowMs, hum, valveVal === 1);
                } catch {}

                // Rendimiento: no forzar rebuild de gráficas en cada tick
                // (se reconstruyen con throttle por SSE/intervalos)
                
                document.getElementById('status').textContent = ' Online - ' + fmtNowEs.format(new Date());
                document.getElementById('status').className = 'status online';
            } catch(e) {
                document.getElementById('status').textContent = ' Sin conexion';
                document.getElementById('status').className = 'status offline';
            }
        }

        async function cargarAlertas() {
            const st = document.getElementById('alertsStatus');
            const listEl = document.getElementById('alertsList');
            try {
                const r = await fetch(`/api/alerts/${encodeURIComponent(deviceCode)}?limit=10`);
                const j = await r.json();
                const rows = Array.isArray(j.rows) ? j.rows : [];
                st.textContent = rows.length ? `Últimas ${rows.length} alertas` : 'Sin alertas';
                listEl.innerHTML = '';
                for (const a of rows) {
                    const item = document.createElement('div');
                    item.className = 'sensor-card';
                    item.style.textAlign = 'left';
                    item.innerHTML = `
                        <div class="sensor-label">${a.kind} · ${new Date(a.created_at).toLocaleString('es-ES', { timeZone: TZ, hour12: false })}</div>
                        <div style="color:#ddd; font-weight:bold;">${a.message}</div>
                    `;
                    listEl.appendChild(item);
                }
            } catch {
                st.textContent = 'No se pudieron cargar alertas';
            }
        }

        function startSSE() {
            try {
                const es = new EventSource(`/api/sse/${encodeURIComponent(deviceCode)}`);
                es.addEventListener('sensor', () => {
                    actualizarSensores();
                    scheduleChartsRebuild();
                });
                es.addEventListener('alert', () => {
                    cargarAlertas();
                });
                es.onerror = () => {
                    try { es.close(); } catch {}
                };
            } catch {
                // ignore
            }
        }

        loadDevices();
        cargarConfig();
        updateThresholdCard();
        loadChannels().then(() => scheduleChartsRebuild());
        rebuildCharts();
        cargarAlertas();
        actualizarSensores();
        startSSE();
        setInterval(actualizarSensores, 15000);
        setInterval(scheduleChartsRebuild, 60000);
        setInterval(cargarAlertas, 60000);

        // --- UI acciones rápidas ---
        document.getElementById('btnAddDevice')?.addEventListener('click', async () => {
            const device_code = (prompt('Código del dispositivo (ej: RIEGO_002):') || '').trim();
            if (!device_code) return;
            const name = (prompt('Nombre (opcional):') || 'ESP32 Riego').trim();
            const location = (prompt('Ubicación (opcional):') || '').trim();
            try {
                const r = await fetch('/api/device/register', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ device_code, name, location: location || null })
                });
                if (!r.ok) throw new Error('register failed');
                window.location.href = `/panel/${encodeURIComponent(device_code)}`;
            } catch {
                alert('No se pudo añadir el dispositivo');
            }
        });

        document.getElementById('btnAddValve')?.addEventListener('click', () => {
            (async () => {
                const name = (prompt('Nombre de la nueva válvula (ej: Válvula 2):') || '').trim();
                const headers = { 'Content-Type': 'application/json' };
                const saved = (getSavedToken(deviceCode) || '').trim();
                if (saved) headers['X-Device-Token'] = saved;
                let r = await fetch(`/api/channels/${encodeURIComponent(deviceCode)}`, {
                    method: 'POST',
                    headers,
                    body: JSON.stringify({ kind: 'valve', name: name || undefined })
                });
                if ((r.status === 401 || r.status === 403) && !saved) {
                    const t = (prompt('Este dispositivo requiere token para añadir válvulas. Pégalo aquí:') || '').trim();
                    if (t) {
                        saveToken(deviceCode, t);
                        r = await fetch(`/api/channels/${encodeURIComponent(deviceCode)}`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json', 'X-Device-Token': t },
                            body: JSON.stringify({ kind: 'valve', name: name || undefined })
                        });
                    }
                }
                if (!r.ok) return alert('No se pudo añadir la válvula');
                await loadChannels();
                scheduleChartsRebuild();
                alert('Válvula añadida. La gráfica aparecerá cuando el ESP32 envíe datos de esa válvula.');
            })();
        });
        document.getElementById('btnAddSensor')?.addEventListener('click', () => {
            (async () => {
                const name = (prompt('Nombre del nuevo sensor (ej: Sensor 2):') || '').trim();
                const headers = { 'Content-Type': 'application/json' };
                const saved = (getSavedToken(deviceCode) || '').trim();
                if (saved) headers['X-Device-Token'] = saved;
                let r = await fetch(`/api/channels/${encodeURIComponent(deviceCode)}`, {
                    method: 'POST',
                    headers,
                    body: JSON.stringify({ kind: 'soil_sensor', name: name || undefined })
                });
                if ((r.status === 401 || r.status === 403) && !saved) {
                    const t = (prompt('Este dispositivo requiere token para añadir sensores. Pégalo aquí:') || '').trim();
                    if (t) {
                        saveToken(deviceCode, t);
                        r = await fetch(`/api/channels/${encodeURIComponent(deviceCode)}`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json', 'X-Device-Token': t },
                            body: JSON.stringify({ kind: 'soil_sensor', name: name || undefined })
                        });
                    }
                }
                if (!r.ok) return alert('No se pudo añadir el sensor');
                await loadChannels();
                scheduleChartsRebuild();
                alert('Sensor añadido. La gráfica aparecerá cuando el ESP32 envíe datos de ese sensor.');
            })();
        });

        async function renameChannel(channelId, kindLabel) {
            if (!channelId) return;
            const newName = (prompt(`Nuevo nombre para ${kindLabel}:`) || '').trim();
            if (!newName) return;
            const headers = { 'Content-Type': 'application/json' };
            const saved = (getSavedToken(deviceCode) || '').trim();
            if (saved) headers['X-Device-Token'] = saved;

            let r = await fetch(`/api/channels/${encodeURIComponent(deviceCode)}/${encodeURIComponent(channelId)}`,
                { method: 'PATCH', headers, body: JSON.stringify({ name: newName }) });

            if ((r.status === 401 || r.status === 403) && !saved) {
                const t = (prompt('Este dispositivo requiere token para renombrar. Pégalo aquí:') || '').trim();
                if (t) {
                    saveToken(deviceCode, t);
                    r = await fetch(`/api/channels/${encodeURIComponent(deviceCode)}/${encodeURIComponent(channelId)}`,
                        { method: 'PATCH', headers: { ...headers, 'X-Device-Token': t }, body: JSON.stringify({ name: newName }) });
                }
            }
            if (!r.ok) return alert('No se pudo renombrar');
            await loadChannels();
            scheduleChartsRebuild();
        }

        document.getElementById('btnRenameHum')?.addEventListener('click', () => renameChannel(humChannelId, 'el sensor'));
        document.getElementById('btnRenameValve')?.addEventListener('click', () => renameChannel(valveChannelId, 'la válvula'));

        document.getElementById('resetRebootsBtn')?.addEventListener('click', async () => {
            if (!confirm('¿Poner el contador de reinicios a 0 (solo en el panel web)?')) return;
            if (lastRebootsBase == null) {
                alert('Aún no hay datos de reinicios para este dispositivo');
                return;
            }

            // Reset local (sin token): guardamos un offset por dispositivo
            setLocalRebootsOffset(deviceCode, lastRebootsBase);
            actualizarSensores();

            // Best-effort: si el backend admite reset sin auth, lo intentamos, pero nunca pedimos token.
            try {
                await fetch(`/api/device/reboots/reset/${encodeURIComponent(deviceCode)}`, { method: 'POST' });
            } catch {}
        });
    </script>
</body>
</html>
