esphome:
  name: riegoesp32001
  comment: "Riego automático prueba ESP32"

globals:
  - id: server_umbral
    type: float
    initial_value: '50.0'

esp32:   # <- Aquí se define la plataforma correcta
  board: esp32dev
  framework:
    type: esp-idf
    version: recommended

# -------- WiFi --------
wifi:
  ssid: "AvanzaFibra_K733"
  password: "ju4SgPKk"
  reboot_timeout: 15min

# -------- OTA y API --------
ota:
  platform: esphome
api:
  password: "ju4SgPKk"

web_server:
  port: 80

logger:
  level: DEBUG

# -------- HTTP Request --------
http_request:
  verify_ssl: false
  timeout: 10s

# -------- Script para enviar datos --------
script:
  - id: send_sensor_data
    then:
      - http_request.post:
          url: "https://riego-esp32-backend-production.up.railway.app/api/sensor/data"
          request_headers:
            Content-Type: application/json
          body: !lambda |-
            char json[512];
            snprintf(json, sizeof(json), 
              "{\"device_code\":\"RIEGO_001\",\"temperature\":%.2f,\"humidity\":%.2f,\"soil_voltage\":%.2f,\"rain_level\":%.2f,\"humidity_low_threshold\":%.2f,\"valve_state\":\"%s\",\"humidity_low_color\":\"%s\",\"humidity_good_color\":\"%s\"}",
              0.0,
              id(soil_hum).state,
              id(soil_raw).state,
              id(lluvia_test).state,
              id(humidity_low).state,
              (id(valve_relay).state ? "ON" : "OFF"),
              id(color_critical).state.c_str(),
              id(color_low).state.c_str()
            );
            return std::string(json);

  - id: fetch_config_from_server
    then:
      - http_request.get:
          url: "https://riego-esp32-backend-production.up.railway.app/api/config/RIEGO_001"
          capture_response: true
          max_response_buffer_size: 1024
          on_response:
            then:
              - lambda: |-
                  std::string resp_body = body;
                  ESP_LOGI("HTTP", "Body length: %d", resp_body.length());
                  ESP_LOGI("RAW", "Response: %.200s", resp_body.c_str());
                  
                  // Parse humidity_low_threshold robustly (fallback to local value)
                  float umbral = id(humidity_low).state;
                  {
                    std::string key = "\"humidity_low_threshold\"";
                    size_t pos = resp_body.find(key);
                    if (pos != std::string::npos) {
                      size_t colon = resp_body.find(":", pos + key.length());
                      if (colon != std::string::npos) {
                        size_t start = colon + 1;
                        while (start < resp_body.size() && isspace((unsigned char)resp_body[start])) start++;
                        if (start < resp_body.size() && resp_body[start] == '"') start++;
                        size_t end = start;
                        while (end < resp_body.size() && (isdigit((unsigned char)resp_body[end]) || resp_body[end]=='.' || resp_body[end]=='-')) end++;
                        if (end > start) {
                          umbral = atof(resp_body.substr(start, end - start).c_str());
                          ESP_LOGI("CONFIG", "Parsed umbral: %.1f", umbral);
                          id(server_umbral) = umbral;
                          id(server_threshold).publish_state(umbral);
                          // Aplicar inmediatamente al control local para garantizar coherencia
                          id(humidity_low).publish_state(umbral);
                          ESP_LOGI("CONFIG", "Published umbral to humidity_low: %.1f", umbral);
                        }
                      }
                    }
                  }

                  // Parse humidity_low_color
                  std::string color_low = "Rojo";
                  std::string search_low = "\"humidity_low_color\":\"";
                  size_t pos_l = resp_body.find(search_low);
                  if (pos_l != std::string::npos) {
                    size_t start_l = pos_l + search_low.length();
                    size_t end_l = resp_body.find("\"", start_l);
                    if (end_l != std::string::npos) {
                      color_low = resp_body.substr(start_l, end_l - start_l);
                    }
                  }

                  // Parse humidity_good_color
                  std::string color_good = "Verde";
                  std::string search_good = "\"humidity_good_color\":\"";
                  size_t pos_g = resp_body.find(search_good);
                  if (pos_g != std::string::npos) {
                    size_t start_g = pos_g + search_good.length();
                    size_t end_g = resp_body.find("\"", start_g);
                    if (end_g != std::string::npos) {
                      color_good = resp_body.substr(start_g, end_g - start_g);
                    }
                  }

                  // Parse led_mode
                  std::string led_mode = "auto";
                  std::string search_mode = "\"led_mode\":\"";
                  size_t pos_mode = resp_body.find(search_mode);
                  if (pos_mode != std::string::npos) {
                    size_t start_mode = pos_mode + search_mode.length();
                    size_t end_mode = resp_body.find("\"", start_mode);
                    if (end_mode != std::string::npos) {
                      led_mode = resp_body.substr(start_mode, end_mode - start_mode);
                    }
                  }

                  // Parse led_manual_color
                  std::string led_manual_color = "Off";
                  std::string search_manual = "\"led_manual_color\":\"";
                  size_t pos_manual = resp_body.find(search_manual);
                  if (pos_manual != std::string::npos) {
                    size_t start_manual = pos_manual + search_manual.length();
                    size_t end_manual = resp_body.find("\"", start_manual);
                    if (end_manual != std::string::npos) {
                      led_manual_color = resp_body.substr(start_manual, end_manual - start_manual);
                    }
                  }
                  
                  // Obtener humedad actual del sensor y voltage
                  float humedad_actual = id(soil_hum).state;
                  float soil_v = id(soil_raw).state;
                  ESP_LOGI("SENSOR", "Soil V: %.2f, Hum: %.1f, Umbral: %.1f", soil_v, humedad_actual, umbral);

                  // Hysteresis para evitar toggles rápidos
                  float hys = 1.0; // porcentaje
                  if (humedad_actual > (umbral - hys)) {
                    id(valve_relay).turn_on();
                    ESP_LOGI("VALVE", "ABRIENDO VÁLVULA: Hum %.1f > Umbral %.1f", humedad_actual, umbral);
                  } else if (humedad_actual < (umbral + hys)) {
                    id(valve_relay).turn_off();
                    ESP_LOGI("VALVE", "CERRANDO VÁLVULA: Hum %.1f < Umbral %.1f", humedad_actual, umbral);
                  } else {
                    ESP_LOGI("VALVE", "SIN CAMBIO: Hum %.1f Umbral %.1f", humedad_actual, umbral);
                  }

                  // Lógica para LEDs
                  if (led_mode == "manual") {
                    // Aplicar color manual
                    if (led_manual_color == "Rojo") {
                      auto call = id(rgb_test).turn_on();
                      call.set_rgb(1.0, 0.0, 0.0);
                      call.perform();
                    } else if (led_manual_color == "Verde") {
                      auto call = id(rgb_test).turn_on();
                      call.set_rgb(0.0, 1.0, 0.0);
                      call.perform();
                    } else if (led_manual_color == "Azul") {
                      auto call = id(rgb_test).turn_on();
                      call.set_rgb(0.0, 0.0, 1.0);
                      call.perform();
                    } else if (led_manual_color == "Amarillo") {
                      auto call = id(rgb_test).turn_on();
                      call.set_rgb(1.0, 1.0, 0.0);
                      call.perform();
                    } else if (led_manual_color == "Cian") {
                      auto call = id(rgb_test).turn_on();
                      call.set_rgb(0.0, 1.0, 1.0);
                      call.perform();
                    } else if (led_manual_color == "Magenta") {
                      auto call = id(rgb_test).turn_on();
                      call.set_rgb(1.0, 0.0, 1.0);
                      call.perform();
                    } else if (led_manual_color == "Blanco") {
                      auto call = id(rgb_test).turn_on();
                      call.set_rgb(1.0, 1.0, 1.0);
                      call.perform();
                    } else if (led_manual_color == "Off") {
                      id(rgb_test).turn_off();
                    }
                  } else {
                    // Modo automático basado en humedad
                    if (humedad_actual < umbral) {
                      // Humedad baja - usar color_low
                      if (color_low == "Rojo") {
                        auto call = id(rgb_test).turn_on();
                        call.set_rgb(1.0, 0.0, 0.0);
                        call.perform();
                      } else if (color_low == "Verde") {
                        auto call = id(rgb_test).turn_on();
                        call.set_rgb(0.0, 1.0, 0.0);
                        call.perform();
                      } else if (color_low == "Azul") {
                        auto call = id(rgb_test).turn_on();
                        call.set_rgb(0.0, 0.0, 1.0);
                        call.perform();
                      } else if (color_low == "Amarillo") {
                        auto call = id(rgb_test).turn_on();
                        call.set_rgb(1.0, 1.0, 0.0);
                        call.perform();
                      } else if (color_low == "Cian") {
                        auto call = id(rgb_test).turn_on();
                        call.set_rgb(0.0, 1.0, 1.0);
                        call.perform();
                      } else if (color_low == "Magenta") {
                        auto call = id(rgb_test).turn_on();
                        call.set_rgb(1.0, 0.0, 1.0);
                        call.perform();
                      } else if (color_low == "Blanco") {
                        auto call = id(rgb_test).turn_on();
                        call.set_rgb(1.0, 1.0, 1.0);
                        call.perform();
                      }
                    } else {
                      // Humedad buena - usar color_good
                      if (color_good == "Rojo") {
                        auto call = id(rgb_test).turn_on();
                        call.set_rgb(1.0, 0.0, 0.0);
                        call.perform();
                      } else if (color_good == "Verde") {
                        auto call = id(rgb_test).turn_on();
                        call.set_rgb(0.0, 1.0, 0.0);
                        call.perform();
                      } else if (color_good == "Azul") {
                        auto call = id(rgb_test).turn_on();
                        call.set_rgb(0.0, 0.0, 1.0);
                        call.perform();
                      } else if (color_good == "Amarillo") {
                        auto call = id(rgb_test).turn_on();
                        call.set_rgb(1.0, 1.0, 0.0);
                        call.perform();
                      } else if (color_good == "Cian") {
                        auto call = id(rgb_test).turn_on();
                        call.set_rgb(0.0, 1.0, 1.0);
                        call.perform();
                      } else if (color_good == "Magenta") {
                        auto call = id(rgb_test).turn_on();
                        call.set_rgb(1.0, 0.0, 1.0);
                        call.perform();
                      } else if (color_good == "Blanco") {
                        auto call = id(rgb_test).turn_on();
                        call.set_rgb(1.0, 1.0, 1.0);
                        call.perform();
                      }
                    }
                  }
          on_error:
            then:
              - logger.log: "ERROR al obtener configuracion"

# -------- Parámetros configurables --------
number:
  - platform: template
    name: "Humedad Baja"
    id: humidity_low
    min_value: 1
    max_value: 100
    step: 1
    initial_value: 50
    unit_of_measurement: "%"
    restore_value: true
    optimistic: true

# -------- Selector de Color --------
select:
  - platform: template
    name: "Humedad Baja - Color"
    id: color_critical
    icon: "mdi:palette"
    options:
      - "Rojo"
      - "Verde"
      - "Azul"
      - "Amarillo"
      - "Cian"
      - "Magenta"
      - "Blanco"
    initial_option: "Rojo"
    restore_value: true
    optimistic: true

  - platform: template
    name: "Humedad Buena - Color"
    id: color_low
    icon: "mdi:palette"
    options:
      - "Rojo"
      - "Verde"
      - "Azul"
      - "Amarillo"
      - "Cian"
      - "Magenta"
      - "Blanco"
    initial_option: "Verde"
    restore_value: true
    optimistic: true

  - platform: template
    name: "Color Manual LEDs"
    id: color_manual
    icon: "mdi:led-on"
    options:
      - "Rojo"
      - "Verde"
      - "Azul"
      - "Amarillo"
      - "Cian"
      - "Magenta"
      - "Blanco"
      - "Off"
    initial_option: "Off"
    restore_value: true
    optimistic: true

# -------- I2C (OLED) --------
i2c:
  sda: GPIO21
  scl: GPIO22
  scan: True

# -------- Pantalla OLED 0.96" I2C --------
font:
  - file: "fonts/NotoSans-Regular.ttf"
    id: oled_font
    size: 12

display:
  - platform: ssd1306_i2c
    model: "SSD1306 128x64"
    address: 0x3C
    id: oled_test
    lambda: |-
      // Línea 1: Humedad y voltaje
      it.printf(0, 0, id(oled_font), "Humedad: %.1f%% Volt: %.2fV", id(soil_hum).state, id(soil_raw).state);
      // Línea 2: Umbral configurado (mostrar valor que usa la lógica de control)
      it.printf(0, 16, id(oled_font), "Umbral: %.1f%%", id(humidity_low).state);
      // Línea 3: Estado válvula
      if (!id(valve_relay).state) it.printf(0, 32, id(oled_font), "VALVULA: ON "); else it.printf(0, 32, id(oled_font), "VALVULA: OFF");
      // Línea 4: Lectura lluvia
      it.printf(0, 48, id(oled_font), "Lluvia V: %.2f", id(lluvia_test).state);

# -------- Sensores --------
sensor:
  - platform: adc
    pin: GPIO34
    name: "Soil Voltage"
    id: soil_raw
    update_interval: 5s
    filters:
      - multiply: 3.3

  - platform: template
    name: "Soil Humidity"
    id: soil_hum
    unit_of_measurement: "%"
    update_interval: 5s
    lambda: |-
      float v = id(soil_raw).state;
      // Valores base (ajustables). Mide para afinar wet_v/dry_v si es posible.
      const float wet_v = 0.40f;   // voltaje en suelo MUY húmedo (esperado)
      const float dry_v = 3.50f;   // voltaje en suelo SECO (esperado)

      if (isnan(v)) {
        ESP_LOGW("CAL", "Soil V=NaN -> returning previous state");
        return id(soil_hum).state;
      }

      // Mapeo A (normal): menor voltaje = más humedad
      float v_a = v;
      if (v_a < wet_v) v_a = wet_v;
      if (v_a > dry_v) v_a = dry_v;
      float pct_a = (1.0f - (v_a - wet_v) / (dry_v - wet_v)) * 100.0f;

      // Mapeo B (invertido): mayor voltaje = más humedad (algunos módulos/plásticos se comportan así)
      float v_b = v;
      float pct_b = ( (v_b - wet_v) / (dry_v - wet_v) ) * 100.0f; // inverted scale

      // Clamp
      pct_a = constrain(pct_a, 0.0f, 100.0f);
      pct_b = constrain(pct_b, 0.0f, 100.0f);

      // Selección automática del mejor mapeo:
      // - Si pct_a casi 0 pero pct_b alto -> usar invertido
      // - Si pct_a está en rango razonable -> usar normal
      // - Si ambos plausibles, elegir el más cercano al estado anterior
      float last = id(soil_hum).state;
      bool a_plausible = (pct_a > 5.0f && pct_a < 98.0f);
      bool b_plausible = (pct_b > 5.0f && pct_b < 98.0f);

      float chosen = pct_a;
      const char *mode = "A";
      if (!a_plausible && b_plausible) {
        chosen = pct_b; mode = "B";
      } else if (a_plausible && !b_plausible) {
        chosen = pct_a; mode = "A";
      } else if (!a_plausible && !b_plausible) {
        // ambos fuera de rango: si lectura está por encima de dry_v usamos invertido
        if (v > dry_v - 0.05f && pct_b > pct_a) { chosen = pct_b; mode = "B"; }
        else { chosen = pct_a; mode = "A"; }
      } else {
        // ambos plausibles: elige el que esté más cerca del último valor para estabilidad
        chosen = (fabs(pct_a - last) < fabs(pct_b - last)) ? pct_a : pct_b;
        mode = (chosen == pct_a) ? "A" : "B";
      }

      // Suavizado exponencial ligero para evitar saltos bruscos
      float alpha = 0.35f;
      float smooth = last * (1.0f - alpha) + chosen * alpha;

      ESP_LOGD("CAL", "Soil V=%.3f pctA=%.1f pctB=%.1f chosen=%s -> smooth=%.1f", v, pct_a, pct_b, mode, smooth);
      return smooth;

  - platform: template
    name: "Umbral Servidor"
    id: server_threshold
    unit_of_measurement: "%"
    update_interval: 5s
    lambda: |-
      return id(server_umbral);

  - platform: adc
    pin: GPIO35
    name: "Lluvia Test"
    id: lluvia_test
    update_interval: 5s
    filters:
      - multiply: 3.3

# -------- LED RGB Addressable 6812 (Solo para automations, sin control manual) --------
light:
  - platform: esp32_rmt_led_strip
    rgb_order: GRB
    pin: GPIO26
    num_leds: 4
    chipset: WS2812
    id: rgb_test
    internal: true
    restore_mode: ALWAYS_ON

# Válvula (relé)
switch:
  - platform: gpio
    pin:
      number: GPIO25
    id: valve_relay
    name: "Válvula Riego"
    restore_mode: ALWAYS_OFF

# -------- Intervalo para enviar datos a Railway --------
interval:
  - interval: 5s
    then:
      - script.execute: send_sensor_data

  - interval: 5s
    then:
      - script.execute: fetch_config_from_server

# -------- BOTÓN DE PRUEBA - FORZAR ROJO --------
button:
  - platform: template
    name: "FORZAR LED ROJO"
    on_press:
      then:
        - lambda: |-
            auto call = id(rgb_test).turn_on();
            call.set_rgb(1.0, 0.0, 0.0);
            call.perform();
            ESP_LOGI("TEST", "LED FORZADO A ROJO");

  - platform: template
    name: "FORZAR LED AZUL"
    on_press:
      then:
        - lambda: |-
            auto call = id(rgb_test).turn_on();
            call.set_rgb(0.0, 0.0, 1.0);
            call.perform();
            ESP_LOGI("TEST", "LED FORZADO A AZUL");
