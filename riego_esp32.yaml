esphome:
  name: riegoesp32001
  comment: "Riego automático prueba ESP32"

globals:
  - id: server_umbral
    type: float
    initial_value: '50.0'

  - id: soil_v_min
    type: float
    initial_value: '1000.0'

  - id: soil_v_max
    type: float
    initial_value: '0.0'

esp32:   # <- Aquí se define la plataforma correcta
  board: esp32dev
  framework:
    type: esp-idf
    version: recommended

# -------- WiFi --------
wifi:
  ssid: "AvanzaFibra_K733"
  password: "ju4SgPKk"
  reboot_timeout: 15min

# -------- OTA y API --------
ota:
  platform: esphome
api:
  password: "ju4SgPKk"

web_server:
  port: 80

logger:
  level: DEBUG

# -------- HTTP Request --------
http_request:
  verify_ssl: false
  timeout: 10s

# -------- Script para enviar datos --------
script:
  - id: send_sensor_data
    then:
      - http_request.post:
          url: "https://riego-esp32-backend-production.up.railway.app/api/sensor/data"
          request_headers:
            Content-Type: application/json
          body: !lambda |-
            char json[512];
            snprintf(json, sizeof(json), 
              "{\"device_code\":\"RIEGO_001\",\"temperature\":%.2f,\"humidity\":%.2f,\"soil_voltage\":%.2f,\"rain_level\":%.2f,\"humidity_low_threshold\":%.2f,\"valve_state\":\"%s\",\"humidity_low_color\":\"%s\",\"humidity_good_color\":\"%s\"}",
              0.0,
              id(soil_hum).state,
              id(soil_raw).state,
              0.0,
              id(humidity_low).state,
              (id(valve_relay).state ? "ON" : "OFF"),
              id(color_critical).state.c_str(),
              id(color_low).state.c_str()
            );
            return std::string(json);

  - id: fetch_config_from_server
    then:
      - http_request.get:
          url: "https://riego-esp32-backend-production.up.railway.app/api/config/RIEGO_001"
          capture_response: true
          max_response_buffer_size: 1024
          on_response:
            then:
              - lambda: |-
                  std::string resp_body = body;
                  ESP_LOGI("HTTP", "Body length: %d", resp_body.length());
                  ESP_LOGI("RAW", "Response: %.200s", resp_body.c_str());
                  
                  // Parse humidity_low_threshold robustly (fallback to local value)
                  float umbral = id(humidity_low).state;
                  {
                    std::string key = "\"humidity_low_threshold\"";
                    size_t pos = resp_body.find(key);
                    if (pos != std::string::npos) {
                      size_t colon = resp_body.find(":", pos + key.length());
                      if (colon != std::string::npos) {
                        size_t start = colon + 1;
                        while (start < resp_body.size() && isspace((unsigned char)resp_body[start])) start++;
                        if (start < resp_body.size() && resp_body[start] == '"') start++;
                        size_t end = start;
                        while (end < resp_body.size() && (isdigit((unsigned char)resp_body[end]) || resp_body[end]=='.' || resp_body[end]=='-')) end++;
                        if (end > start) {
                          umbral = atof(resp_body.substr(start, end - start).c_str());
                          ESP_LOGI("CONFIG", "Parsed umbral: %.1f", umbral);
                          id(server_umbral) = umbral;
                          id(server_threshold).publish_state(umbral);
                          // Aplicar inmediatamente al control local para garantizar coherencia
                          id(humidity_low).publish_state(umbral);
                          ESP_LOGI("CONFIG", "Published umbral to humidity_low: %.1f", umbral);
                        }
                      }
                    }
                  }

                  // Parse humidity_low_color
                  std::string color_low = "Rojo";
                  std::string search_low = "\"humidity_low_color\":\"";
                  size_t pos_l = resp_body.find(search_low);
                  if (pos_l != std::string::npos) {
                    size_t start_l = pos_l + search_low.length();
                    size_t end_l = resp_body.find("\"", start_l);
                    if (end_l != std::string::npos) {
                      color_low = resp_body.substr(start_l, end_l - start_l);
                    }
                  }

                  // Parse humidity_good_color
                  std::string color_good = "Verde";
                  std::string search_good = "\"humidity_good_color\":\"";
                  size_t pos_g = resp_body.find(search_good);
                  if (pos_g != std::string::npos) {
                    size_t start_g = pos_g + search_good.length();
                    size_t end_g = resp_body.find("\"", start_g);
                    if (end_g != std::string::npos) {
                      color_good = resp_body.substr(start_g, end_g - start_g);
                    }
                  }

                  // Parse led_mode
                  std::string led_mode = "auto";
                  std::string search_mode = "\"led_mode\":\"";
                  size_t pos_mode = resp_body.find(search_mode);
                  if (pos_mode != std::string::npos) {
                    size_t start_mode = pos_mode + search_mode.length();
                    size_t end_mode = resp_body.find("\"", start_mode);
                    if (end_mode != std::string::npos) {
                      led_mode = resp_body.substr(start_mode, end_mode - start_mode);
                    }
                  }

                  // Parse led_manual_color
                  std::string led_manual_color = "Off";
                  std::string search_manual = "\"led_manual_color\":\"";
                  size_t pos_manual = resp_body.find(search_manual);
                  if (pos_manual != std::string::npos) {
                    size_t start_manual = pos_manual + search_manual.length();
                    size_t end_manual = resp_body.find("\"", start_manual);
                    if (end_manual != std::string::npos) {
                      led_manual_color = resp_body.substr(start_manual, end_manual - start_manual);
                    }
                  }
                  
                  // Obtener humedad actual del sensor y voltage
                  float humedad_actual = id(soil_hum).state;
                  float soil_v = id(soil_raw).state;
                  ESP_LOGI("SENSOR", "Soil V: %.2f, Hum: %.1f, Umbral: %.1f", soil_v, humedad_actual, umbral);

                  // Histéresis para evitar toggles rápidos
                  // Encender (regar) SOLO si la humedad está claramente por DEBAJO del umbral.
                  float hys = 1.0; // porcentaje
                  if (humedad_actual < (umbral - hys)) {
                    id(valve_relay).turn_on();
                    ESP_LOGI("VALVE", "ABRIENDO VÁLVULA: Hum %.1f < Umbral %.1f", humedad_actual, umbral);
                  } else if (humedad_actual > (umbral + hys)) {
                    id(valve_relay).turn_off();
                    ESP_LOGI("VALVE", "CERRANDO VÁLVULA: Hum %.1f > Umbral %.1f", humedad_actual, umbral);
                  } else {
                    ESP_LOGI("VALVE", "SIN CAMBIO: Hum %.1f Umbral %.1f", humedad_actual, umbral);
                  }

                  // Lógica para LEDs
                  if (led_mode == "manual") {
                    // Aplicar color manual
                    if (led_manual_color == "Rojo") {
                      auto call = id(rgb_test).turn_on();
                      call.set_rgb(1.0, 0.0, 0.0);
                      call.perform();
                    } else if (led_manual_color == "Verde") {
                      auto call = id(rgb_test).turn_on();
                      call.set_rgb(0.0, 1.0, 0.0);
                      call.perform();
                    } else if (led_manual_color == "Azul") {
                      auto call = id(rgb_test).turn_on();
                      call.set_rgb(0.0, 0.0, 1.0);
                      call.perform();
                    } else if (led_manual_color == "Amarillo") {
                      auto call = id(rgb_test).turn_on();
                      call.set_rgb(1.0, 1.0, 0.0);
                      call.perform();
                    } else if (led_manual_color == "Cian") {
                      auto call = id(rgb_test).turn_on();
                      call.set_rgb(0.0, 1.0, 1.0);
                      call.perform();
                    } else if (led_manual_color == "Magenta") {
                      auto call = id(rgb_test).turn_on();
                      call.set_rgb(1.0, 0.0, 1.0);
                      call.perform();
                    } else if (led_manual_color == "Blanco") {
                      auto call = id(rgb_test).turn_on();
                      call.set_rgb(1.0, 1.0, 1.0);
                      call.perform();
                    } else if (led_manual_color == "Off") {
                      id(rgb_test).turn_off();
                    }
                  } else {
                    // Modo automático basado en humedad
                    if (humedad_actual < umbral) {
                      // Humedad baja - usar color_low
                      if (color_low == "Rojo") {
                        auto call = id(rgb_test).turn_on();
                        call.set_rgb(1.0, 0.0, 0.0);
                        call.perform();
                      } else if (color_low == "Verde") {
                        auto call = id(rgb_test).turn_on();
                        call.set_rgb(0.0, 1.0, 0.0);
                        call.perform();
                      } else if (color_low == "Azul") {
                        auto call = id(rgb_test).turn_on();
                        call.set_rgb(0.0, 0.0, 1.0);
                        call.perform();
                      } else if (color_low == "Amarillo") {
                        auto call = id(rgb_test).turn_on();
                        call.set_rgb(1.0, 1.0, 0.0);
                        call.perform();
                      } else if (color_low == "Cian") {
                        auto call = id(rgb_test).turn_on();
                        call.set_rgb(0.0, 1.0, 1.0);
                        call.perform();
                      } else if (color_low == "Magenta") {
                        auto call = id(rgb_test).turn_on();
                        call.set_rgb(1.0, 0.0, 1.0);
                        call.perform();
                      } else if (color_low == "Blanco") {
                        auto call = id(rgb_test).turn_on();
                        call.set_rgb(1.0, 1.0, 1.0);
                        call.perform();
                      }
                    } else {
                      // Humedad buena - usar color_good
                      if (color_good == "Rojo") {
                        auto call = id(rgb_test).turn_on();
                        call.set_rgb(1.0, 0.0, 0.0);
                        call.perform();
                      } else if (color_good == "Verde") {
                        auto call = id(rgb_test).turn_on();
                        call.set_rgb(0.0, 1.0, 0.0);
                        call.perform();
                      } else if (color_good == "Azul") {
                        auto call = id(rgb_test).turn_on();
                        call.set_rgb(0.0, 0.0, 1.0);
                        call.perform();
                      } else if (color_good == "Amarillo") {
                        auto call = id(rgb_test).turn_on();
                        call.set_rgb(1.0, 1.0, 0.0);
                        call.perform();
                      } else if (color_good == "Cian") {
                        auto call = id(rgb_test).turn_on();
                        call.set_rgb(0.0, 1.0, 1.0);
                        call.perform();
                      } else if (color_good == "Magenta") {
                        auto call = id(rgb_test).turn_on();
                        call.set_rgb(1.0, 0.0, 1.0);
                        call.perform();
                      } else if (color_good == "Blanco") {
                        auto call = id(rgb_test).turn_on();
                        call.set_rgb(1.0, 1.0, 1.0);
                        call.perform();
                      }
                    }
                  }
          on_error:
            then:
              - logger.log: "ERROR al obtener configuracion"

# -------- Parámetros configurables --------
number:
  - platform: template
    name: "Humedad Baja"
    id: humidity_low
    min_value: 1
    max_value: 100
    step: 1
    initial_value: 50
    unit_of_measurement: "%"
    restore_value: true
    optimistic: true

  - platform: template
    name: "Suelo - Voltaje Mojado (100%)"
    id: soil_wet_v
    min_value: 0.0
    max_value: 3.3
    step: 0.01
    initial_value: 0.60
    unit_of_measurement: "V"
    restore_value: true
    optimistic: true

  - platform: template
    name: "Suelo - Voltaje Seco (0%)"
    id: soil_dry_v
    min_value: 0.0
    max_value: 3.3
    step: 0.01
    initial_value: 2.12
    unit_of_measurement: "V"
    restore_value: true
    optimistic: true

# -------- Selector de Color --------
select:
  - platform: template
    name: "Humedad Baja - Color"
    id: color_critical
    icon: "mdi:palette"
    options:
      - "Rojo"
      - "Verde"
      - "Azul"
      - "Amarillo"
      - "Cian"
      - "Magenta"
      - "Blanco"
    initial_option: "Rojo"
    restore_value: true
    optimistic: true

  - platform: template
    name: "Humedad Buena - Color"
    id: color_low
    icon: "mdi:palette"
    options:
      - "Rojo"
      - "Verde"
      - "Azul"
      - "Amarillo"
      - "Cian"
      - "Magenta"
      - "Blanco"
    initial_option: "Verde"
    restore_value: true
    optimistic: true

  - platform: template
    name: "Color Manual LEDs"
    id: color_manual
    icon: "mdi:led-on"
    options:
      - "Rojo"
      - "Verde"
      - "Azul"
      - "Amarillo"
      - "Cian"
      - "Magenta"
      - "Blanco"
      - "Off"
    initial_option: "Off"
    restore_value: true
    optimistic: true

# -------- I2C (OLED) --------
i2c:
  sda: GPIO21
  scl: GPIO22
  scan: True

# -------- Pantalla OLED 0.96" I2C --------
font:
  - file: "fonts/NotoSans-Regular.ttf"
    id: oled_font
    size: 12

display:
  - platform: ssd1306_i2c
    model: "SSD1306 128x64"
    address: 0x3C
    id: oled_test
    update_interval: 500ms
    lambda: |-
      // Línea 1: lectura actual
      it.printf(0, 0, id(oled_font), "V: %.2f  H: %.0f%%", id(soil_raw).state, id(soil_hum).state);
      // Línea 2: estado válvula
      if (id(valve_relay).state) it.printf(0, 16, id(oled_font), "VALVULA: ON");
      else it.printf(0, 16, id(oled_font), "VALVULA: OFF");
      // Línea 3: umbral
      it.printf(0, 32, id(oled_font), "Umbral: %.0f%%", id(humidity_low).state);
      // Línea 4: min/max observados
      it.printf(0, 48, id(oled_font), "Min:%.2f Max:%.2f", id(soil_v_min), id(soil_v_max));

# -------- Sensores --------
sensor:
  - platform: adc
    pin: GPIO34
    name: "Soil Voltage"
    id: soil_raw
    attenuation: 12db
    unit_of_measurement: "V"
    accuracy_decimals: 2
    update_interval: 500ms
    filters:
      # En ESP32, con `attenuation` ESPHome ya entrega voltios reales.
      # El multiply 3.3 inflaba la lectura (ej: ~7V), por eso se elimina.
      - sliding_window_moving_average:
          window_size: 8
          send_every: 1

  - platform: template
    name: "Soil Humidity"
    id: soil_hum
    unit_of_measurement: "%"
    accuracy_decimals: 1
    update_interval: 500ms
    lambda: |-
      float v = id(soil_raw).state;
      float wet_v = id(soil_wet_v).state; // 100%
      float dry_v = id(soil_dry_v).state; // 0%
      float last_state = id(soil_hum).state;

      auto is_nan = [](float x) -> bool { return x != x; };

      if (is_nan(v) || is_nan(wet_v) || is_nan(dry_v)) {
        ESP_LOGW("CAL", "Soil V/wet/dry = NaN -> returning previous state");
        return is_nan(last_state) ? 0.0f : last_state;
      }

      float lo = fminf(wet_v, dry_v);
      float hi = fmaxf(wet_v, dry_v);
      if ((hi - lo) < 0.02f) {
        ESP_LOGW("CAL", "Calibration too close: wet=%.3f dry=%.3f", wet_v, dry_v);
        return is_nan(last_state) ? 0.0f : last_state;
      }

      // Guardar min/max observados (para ayudarte a calibrar)
      if (v < id(soil_v_min)) id(soil_v_min) = v;
      if (v > id(soil_v_max)) id(soil_v_max) = v;

      float vc = v;
      if (vc < lo) vc = lo;
      if (vc > hi) vc = hi;
      float t = (vc - lo) / (hi - lo); // 0..1
      // Si wet_v < dry_v: menos voltaje = más humedad -> 100% en wet_v
      float chosen = (wet_v < dry_v) ? ((1.0f - t) * 100.0f) : (t * 100.0f);
      if (chosen < 0.0f) chosen = 0.0f;
      if (chosen > 100.0f) chosen = 100.0f;

      // Suavizado exponencial ligero
      float alpha = 0.35f;
      float last = is_nan(last_state) ? chosen : last_state;
      float smooth = last * (1.0f - alpha) + chosen * alpha;

      if (is_nan(smooth)) smooth = chosen;

      ESP_LOGD("CAL", "Soil V=%.3f wet=%.3f dry=%.3f -> %.1f (smooth %.1f)", v, wet_v, dry_v, chosen, smooth);
      return smooth;

  - platform: template
    name: "Umbral Servidor"
    id: server_threshold
    unit_of_measurement: "%"
    update_interval: 5s
    lambda: |-
      return id(server_umbral);



# -------- LED RGB Addressable 6812 (Solo para automations, sin control manual) --------
light:
  - platform: esp32_rmt_led_strip
    rgb_order: GRB
    pin: GPIO26
    num_leds: 4
    chipset: WS2812
    id: rgb_test
    internal: true
    restore_mode: ALWAYS_ON

# Válvula (relé)
switch:
  - platform: gpio
    pin:
      number: GPIO25
      inverted: true
    id: valve_relay
    name: "Válvula Riego"
    restore_mode: ALWAYS_OFF

# -------- Intervalo para enviar datos a Railway --------
interval:
  - interval: 5s
    then:
      - script.execute: send_sensor_data

  - interval: 5s
    then:
      - script.execute: fetch_config_from_server

# -------- BOTÓN DE PRUEBA - FORZAR ROJO --------
button:
  - platform: template
    name: "FORZAR LED ROJO"
    on_press:
      then:
        - lambda: |-
            auto call = id(rgb_test).turn_on();
            call.set_rgb(1.0, 0.0, 0.0);
            call.perform();
            ESP_LOGI("TEST", "LED FORZADO A ROJO");

  - platform: template
    name: "FORZAR LED AZUL"
    on_press:
      then:
        - lambda: |-
            auto call = id(rgb_test).turn_on();
            call.set_rgb(0.0, 0.0, 1.0);
            call.perform();
            ESP_LOGI("TEST", "LED FORZADO A AZUL");
